 conf/battle/battleground.conf     |   62 ++
 conf/maps_athena.conf             |   26 +
 conf/msg_conf/map_msg.conf        |   47 +-
 db/achievement_db.yml             |    1 +
 db/battleground_db.yml            |    1 +
 db/import/achievement_db_bg.yml   |  104 ++
 db/import/battleground_db_ex.yml  |  345 ++++++
 db/import/item_db_bg.yml          |  101 ++
 db/import/map_index.txt           |   26 +
 db/import/mob_avail.yml           |   20 +
 db/import/mob_db_bg.yml           |  331 ++++++
 db/item_db.yml                    |    1 +
 db/mob_db.yml                     |    1 +
 npc/custom/eBG/bg_common.txt      |  534 +++++++++
 npc/custom/eBG/bg_conquest.txt    | 2196 +++++++++++++++++++++++++++++++++++++
 npc/custom/eBG/bg_core.txt        |  260 +++++
 npc/custom/eBG/bg_flavius_ctf.txt |  510 +++++++++
 npc/custom/eBG/bg_flavius_sc.txt  |  995 +++++++++++++++++
 npc/custom/eBG/bg_flavius_td.txt  |  309 ++++++
 npc/custom/eBG/bg_rush.txt        |  596 ++++++++++
 npc/custom/eBG/bg_tierra_boss.txt |  417 +++++++
 npc/custom/eBG/bg_tierra_dom.txt  |  740 +++++++++++++
 npc/custom/eBG/bg_tierra_ti.txt   |  389 +++++++
 npc/re/battleground/bg_common.txt |    2 +-
 npc/scripts_athena.conf           |   24 +-
 npc/scripts_custom.conf           |   12 +
 sql-files/extended_bg.sql         |  158 +++
 src/char/char.cpp                 |  364 ++++++
 src/char/char.hpp                 |    4 +
 src/char/char_mapif.cpp           |   18 +-
 src/common/mmo.hpp                |  120 +-
 src/common/utils.cpp              |   10 +
 src/custom/atcommand.inc          |  257 +++++
 src/custom/atcommand_def.inc      |    9 +
 src/custom/script.inc             |  930 ++++++++++++++++
 src/custom/script_def.inc         |   37 +
 src/map/battle.cpp                |   12 +-
 src/map/battleground.cpp          |  785 ++++++++++++-
 src/map/battleground.hpp          |    3 +
 src/map/buyingstore.cpp           |    7 +
 src/map/chrif.cpp                 |   30 +-
 src/map/clif.cpp                  |  467 +++++++-
 src/map/clif.hpp                  |   15 +
 src/map/itemdb.hpp                |    1 +
 src/map/map.cpp                   |   16 +-
 src/map/map.hpp                   |    6 +
 src/map/mob.cpp                   |    7 +
 src/map/npc.hpp                   |    2 +-
 src/map/pc.cpp                    |  418 ++++++-
 src/map/pc.hpp                    |   16 +
 src/map/script.cpp                |    9 +
 src/map/script.hpp                |   26 +
 src/map/script_constants.hpp      |   47 +
 src/map/skill.cpp                 |  234 +++-
 src/map/skill.hpp                 |    5 +
 src/map/status.cpp                |    4 +
 src/map/trade.cpp                 |    8 +
 57 files changed, 11962 insertions(+), 113 deletions(-)

diff --git a/conf/battle/battleground.conf b/conf/battle/battleground.conf
index 05537ea..18e4549 100644
--- a/conf/battle/battleground.conf
+++ b/conf/battle/battleground.conf
@@ -34,3 +34,65 @@ bg_update_interval: 1000
 // Before a player is warped into a Battleground from the Battleground Queue,
 // check to see if the player's current map has MF_NOWARP.
 bgqueue_nowarp_mapflag: no
+
+//===============================================
+// Extended Battleground Configuration [Easycore]
+//===============================================
+
+// Enables battleground's rotation mode system (Note 1)
+bg_rotation_mode: on
+
+// Time it takes to consider an AFK player and announce it (seconds)
+bg_idle_announce: 30
+
+// Time it takes to autokick an AFK player from arenas (seconds)
+bg_idle_autokick: 60
+
+// Battleground badges & kafrapoints reward rate (Note 2)
+bg_reward_rates: 100
+
+// Battleground badges & kafrapoints reward rates aditional for VIP players (Note 2)
+bg_reward_rates_vip: 50
+
+// Only team leader can kick AFK players through @reportafk? (Note 1)
+bg_reportafk_leaderonly: no
+
+// Players can only queue in towns map? (Note 1)
+bg_queue_onlytowns: no
+
+// Can player trade Battleground & WoE consumables? (Note 1)
+bg_can_trade: yes
+
+// Prevent double login in Battleground maps? (Note 1)
+bg_double_login: yes
+
+// Enable or disable Extended Check Equip feature (Note 1)
+bg_extended_check_equip: yes
+
+// Enable or disable confirmation window when the queue is ready (Note 1)
+// Note: only works when 'bg_queue_interface' is enabled
+bg_queue_confirmation: yes
+
+// Enable or disable battleground's interface when joining the queue (Note 1)
+bg_queue_interface: no
+
+// Gives Increase Agi and Blessing to players when a match ends (Note 1)
+bg_buffs_on_leave: yes
+
+// Balance Teams according players jobs? (Note 1)
+// Note: This break organized groups by party/guild joining
+bg_balance_teams: yes
+
+// Remove active buffs on join/leave a Battleground Arena (0: Disable)
+// 1 = Increase Agi & Blessing
+// 2 = Spirit Link
+// 4 = Full Chemical Protection
+// 8 = Gospel
+// 16 = Kyrie Eleison & Assumptio
+// 32 = Enchant Deadly Poison
+// 64 = Kaite, Koupe & Kaizel
+bg_remove_buffs: 63
+
+// Gives skill damage immunity to Barricade, Emperium, Flags and G. Stones? (Note 1)
+// Note: They are always immune to healing skills
+bg_monsters_skillimmune: no
diff --git a/conf/maps_athena.conf b/conf/maps_athena.conf
index 7ad07e5..cd513ec 100644
--- a/conf/maps_athena.conf
+++ b/conf/maps_athena.conf
@@ -1612,3 +1612,29 @@ map: bl_depth2
 
 //------------------------- Clone Maps ---------------------------
 //------------------------- Extra Maps ---------------------------
+
+map: bat_a03
+map: bat_a04
+map: bat_a05
+map: bat_b03
+map: bat_b04
+map: bat_b05
+map: bat_c04
+map: bat_c05
+map: bat_c06
+map: bat_c07
+map: bat_c08
+map: schg_cas06
+map: schg_cas07
+map: schg_cas08
+map: arug_cas06
+map: arug_cas07
+map: arug_cas08
+map: rush_cas01
+map: rush_cas02
+map: rush_cas03
+map: rush_cas04
+map: region_8
+map: bat_cc
+map: bat_cc2
+map: arena_01
diff --git a/conf/msg_conf/map_msg.conf b/conf/msg_conf/map_msg.conf
index c9eb476..ab72327 100644
--- a/conf/msg_conf/map_msg.conf
+++ b/conf/msg_conf/map_msg.conf
@@ -1450,7 +1450,7 @@
 
 // @iteminfo
 1276: Please enter an item name/ID (usage: @ii/@iteminfo <item name/ID>).
-1277: Item: '%s'/'%s' (%u) Type: %s | Extra Effect: %s
+1277: Item: '%s'/'%s'[%d] (%u) Type: %s | Extra Effect: %s
 1278: None
 1279: With script
 1280: NPC Buy:%dz, Sell:%dz | Weight: %.1f
@@ -1460,7 +1460,7 @@
 
 // @whodrops
 1284: Please enter item name/ID (usage: @whodrops <item name/ID>).
-1285: Item: '%s' (ID: %u)
+1285: Item: '%s'[%d] (ID: %u)
 1286:  - Item is not dropped by mobs.
 1287:  - Common mobs with highest drop chance (only max %d are listed):
 
@@ -1820,5 +1820,48 @@
 1534: Usage: @stockall {<type>}
 1535: %d items are transferred (%d skipped)!
 
+// Extended Battleground [Easycore]
+2000: [Battlegrounds] %s has been kicked for being AFK
+2001: You have been kicked from Battleground for your AFK status
+2002: %s : %s seems to be away. AFK Warning - player can be kicked by @reportafk command
+2003: Double Login detected
+2004: Cannot Trade event reserved Items (Battleground, WoE)
+2005: Player not found.
+2006: [Your Battleground Rank -%d = %d points]
+2007: [Your Battleground Rank +%d = %d points]
+2008: [Your War of Emperium Rank -%d = %d points]
+2009: [Your War of Emperium Rank +%d = %d points]
+2010: %s : %s is no longer AFK...
+2011: Cannot use Emergency Call in this map.
+2012: Unknown skill. Use @guildskill EC/RS/RG/BO
+2013: This command is reserved for Guild Leaders.
+2014: This command is reserved for Team Leaders.
+2015: You need to be in a Guild or in a Battleground Arena.
+2016: EC: %d seconds
+2017: EC: Ready to use!
+2018: BO: %d seconds
+2019: BO: Ready to use!
+2020: RG: %d seconds
+2021: RG: Ready to use!
+2022: RS: %d seconds
+2023: RS: Ready to use!
+2024: Command cannot be used while casting a skill.
+2025: Please enter the name of the new Leader (usage: @leader <name>).
+2026: The player is not part of your Team.
+2027: You are already the Team Leader.
+2028: Team Leader transfered to [%s]
+2029: This command is reserved for Battleground
+2030: Please enter the AFK player's nick (usage: @reportafk <name>).
+2031: You cannot report yourself.
+2032: The player is not AFK in this Battleground
+2034: - AFK [%s] Kicked -
+2035: You will receive announces from Battleground
+2036: You no longer will receive announces from Battleground
+2037: Please write a message (usage: @order <message>).
+2038: Please use @joinbg to enlist in Battlegrounds.
+2039: Waiting for players... (%d/%d)
+2040: [%s] ready in %ds
+2041: Please use the command @joinbg to enlist in Battlegrounds
+
 //Custom translations
 import: conf/msg_conf/import/map_msg_eng_conf.txt
diff --git a/db/achievement_db.yml b/db/achievement_db.yml
index d32e93e..cf479b6 100644
--- a/db/achievement_db.yml
+++ b/db/achievement_db.yml
@@ -52,3 +52,4 @@ Footer:
   - Path: db/re/achievement_db.yml
     Mode: Renewal
   - Path: db/import/achievement_db.yml
+  - Path: db/import/achievement_db_bg.yml
diff --git a/db/battleground_db.yml b/db/battleground_db.yml
index f32700d..ce7a529 100644
--- a/db/battleground_db.yml
+++ b/db/battleground_db.yml
@@ -209,3 +209,4 @@ Body:
 Footer:
   Imports:
   - Path: db/import/battleground_db.yml
+  - Path: db/import/battleground_db_ex.yml
diff --git a/db/import/achievement_db_bg.yml b/db/import/achievement_db_bg.yml
new file mode 100644
index 0000000..f709c45
--- /dev/null
+++ b/db/import/achievement_db_bg.yml
@@ -0,0 +1,104 @@
+# This file is a part of rAthena.
+#   Copyright(C) 2021 rAthena Development Team
+#   https://rathena.org - https://github.com/rathena
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+###########################################################################
+# Achievement Database
+###########################################################################
+#
+# Achievement Settings
+#
+###########################################################################
+# - Id                  Achievement ID.
+#   Group               Achievement group type. (Defaut: None)
+#   Name                Achievement name.
+#   Targets:            List of targets the achievement requires. (Default: null)
+#     - Id              Index value used for import methods.
+#       Mob             Target mob. (Default: 0)
+#       Count           Target count. (Default: 1)
+#   Condition           Conditional statement that must be met for the achievement to be considered complete. (Default: null)
+#   Map                 Map name that is used for the AG_CHATTING type. (Default: -1)
+#   Dependents:         List of achievements that need to be completed before this achievement is considered complete. (Default: null)
+#     - Id: <bool>      Achievement ID pre-requisite.
+#   Rewards:            List of rewards that are given on completion. (Default: null)
+#     Item              Item name.
+#     Amount            Amount of item. (Default: 1)
+#     Script            Bonus Script. (Default: null)
+#     TitleId           Title ID. (Default: 0)
+#   Score               Achievement points that are given on completion. (Default: 0)
+###########################################################################
+
+Header:
+  Type: ACHIEVEMENT_DB
+  Version: 2
+
+Body:
+  - Id: 220050
+    Group: BG_WIN
+    Name: Battleground Champion
+    Condition: " ARG0 >= 50 "
+    Targets:
+      - Id: 0
+        Count: 50
+    Score: 20
+  - Id: 220051
+    Group: BG_LOSE
+    Name: Battleground Perseverant
+    Condition: " ARG0 >= 50 "
+    Targets:
+      - Id: 0
+        Count: 50
+    Score: 5
+  - Id: 220052
+    Group: BG_TIE
+    Name: Battleground Tough
+    Condition: " ARG0 >= 50 "
+    Targets:
+      - Id: 0
+        Count: 50
+    Score: 10
+  - Id: 220053
+    Group: BG_KILL
+    Name: Battleground Killer
+    Condition: " ARG0 >= 500 "
+    Targets:
+      - Id: 0
+        Count: 500
+    Score: 20
+  - Id: 220054
+    Group: BG_DIE
+    Name: Battleground Victim
+    Condition: " ARG0 >= 500 "
+    Targets:
+      - Id: 0
+        Count: 500
+    Score: 5
+  - Id: 220055
+    Group: BG_HEAL
+    Name: Combat Medic
+    Condition: " ARG0 >= 500000 "
+    Targets:
+      - Id: 0
+        Count: 500000
+    Score: 20
+  - Id: 220056
+    Group: BG_DAMAGE
+    Name: Insane Fighter
+    Condition: " ARG0 >= 2500000 "
+    Targets:
+      - Id: 0
+        Count: 2500000
+    Score: 20
\ No newline at end of file
diff --git a/db/import/battleground_db_ex.yml b/db/import/battleground_db_ex.yml
new file mode 100644
index 0000000..b6789c7
--- /dev/null
+++ b/db/import/battleground_db_ex.yml
@@ -0,0 +1,345 @@
+# This file is a part of rAthena.
+#   Copyright(C) 2021 rAthena Development Team
+#   https://rathena.org - https://github.com/rathena
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+###########################################################################
+# Battleground Queue Database
+###########################################################################
+#
+# Battleground Queue Settings
+#
+###########################################################################
+# - Id                Unique ID for the battleground type.
+#   Name              Name of the battleground. Must be the exact same as in the client for players to be able to join.
+#   MinPlayers        Minimum number of players required on each team. (Default: 1)
+#   MaxPlayers        Maximum number of players on each team. (Default: MAX_BG_MEMBERS / 2)
+#   MinLevel          Minimum level required to join the battleground. (Default: 1)
+#   MaxLevel          Maximum level to join the battleground. (Default: MAX_LEVEL value)
+#   Deserter          Amount of time in seconds a player is marked deserter. (Default: 600)
+#   StartDelay        Amount of time in seconds once a queue is filled before players are warped. (Default: 0)
+#   Join:             Which application type is accepted. The entryqueuelist.lub can visually disable these options.
+#     Solo            Able to join a queue as an individual. (Default: true)
+#     Party           Able to join a queue as a party. (Default: true)
+#     Guild           Able to join a queue as a guild. (Default: true)
+#   JobRestrictions   List of jobs that are unable to join the battleground.
+#   Locations:        Battleground location settings.
+#     - Map           The map on which the battleground will be played.
+#       StartEvent    NPC event triggered when the battleground starts.
+#       TeamA:        TeamA settings.
+#         RespawnX    X coordinate for warping on death.
+#         RespawnY    Y coordinate for warping on death.
+#         DeathEvent  NPC event triggered when a player dies.
+#         QuitEvent   NPC event triggered when a player quits.
+#         ActiveEvent NPC event triggered when a player joints an active battleground.
+#         Variable    Name of BG ID variable used in the battleground script.
+#       TeamB:        TeamB settings.
+#         RespawnX    X coordinate for warping on death.
+#         RespawnY    Y coordinate for warping on death.
+#         DeathEvent  NPC event triggered when a player dies.
+#         QuitEvent   NPC event triggered when a player quits.
+#         ActiveEvent NPC event triggered when a player joints an active battleground.
+#         Variable    Name of BG ID variable used in the battleground script.
+###########################################################################
+
+Header:
+  Type: BATTLEGROUND_DB
+  Version: 1
+
+Body:
+  - Id: 6
+    Name: Conquest
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: schg_cas06
+        StartEvent: Conquest::OnStart
+        TeamA:
+          RespawnX: 264
+          RespawnY: 379
+          QuitEvent: Conquest::OnTeam1Quit
+          ActiveEvent: Conquest::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 295
+          RespawnY: 379
+          QuitEvent: Conquest::OnTeam2Quit
+          ActiveEvent: Conquest::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: schg_cas07
+        StartEvent: Conquest::OnStart
+        TeamA:
+          RespawnX: 90
+          RespawnY: 311
+          QuitEvent: Conquest::OnTeam1Quit
+          ActiveEvent: Conquest::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 113
+          RespawnY: 311
+          QuitEvent: Conquest::OnTeam2Quit
+          ActiveEvent: Conquest::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: schg_cas08
+        StartEvent: Conquest::OnStart
+        TeamA:
+          RespawnX: 28
+          RespawnY: 50
+          QuitEvent: Conquest::OnTeam1Quit
+          ActiveEvent: Conquest::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 87
+          RespawnY: 50
+          QuitEvent: Conquest::OnTeam2Quit
+          ActiveEvent: Conquest::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: arug_cas06
+        StartEvent: Conquest::OnStart
+        TeamA:
+          RespawnX: 30
+          RespawnY: 381
+          QuitEvent: Conquest::OnTeam1Quit
+          ActiveEvent: Conquest::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 126
+          RespawnY: 357
+          QuitEvent: Conquest::OnTeam2Quit
+          ActiveEvent: Conquest::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: arug_cas07
+        StartEvent: Conquest::OnStart
+        TeamA:
+          RespawnX: 298
+          RespawnY: 339
+          QuitEvent: Conquest::OnTeam1Quit
+          ActiveEvent: Conquest::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 298
+          RespawnY: 308
+          QuitEvent: Conquest::OnTeam2Quit
+          ActiveEvent: Conquest::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: arug_cas08
+        StartEvent: Conquest::OnStart
+        TeamA:
+          RespawnX: 313
+          RespawnY: 154
+          QuitEvent: Conquest::OnTeam1Quit
+          ActiveEvent: Conquest::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 330
+          RespawnY: 154
+          QuitEvent: Conquest::OnTeam2Quit
+          ActiveEvent: Conquest::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 7
+    Name: Capture The Flag
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: bat_b02
+        StartEvent: Flavius_CTF::OnStart
+        TeamA:
+          RespawnX: 390
+          RespawnY: 10
+          DeathEvent: Flavius_CTF::OnTeam1Die
+          QuitEvent: Flavius_CTF::OnTeam1Quit
+          ActiveEvent: Flavius_CTF::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 10
+          RespawnY: 290
+          DeathEvent: Flavius_CTF::OnTeam2Die
+          QuitEvent: Flavius_CTF::OnTeam2Quit
+          ActiveEvent: Flavius_CTF::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 8
+    Name: Stone Control
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: bat_b04
+        StartEvent: Flavius_SC::OnStart
+        TeamA:
+          RespawnX: 390
+          RespawnY: 10
+          DeathEvent: Flavius_SC::OnTeam1Die
+          QuitEvent: Flavius_SC::OnTeam1Quit
+          ActiveEvent: Flavius_SC::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 10
+          RespawnY: 290
+          DeathEvent: Flavius_SC::OnTeam2Die
+          QuitEvent: Flavius_SC::OnTeam2Quit
+          ActiveEvent: Flavius_SC::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 9
+    Name: Team DeathMatch
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: bat_cc
+        StartEvent: Flavius_TD::OnStart
+        TeamA:
+          RespawnX: 88
+          RespawnY: 139
+          DeathEvent: Flavius_TD::OnTeam1Die
+          QuitEvent: Flavius_TD::OnTeam1Quit
+          ActiveEvent: Flavius_TD::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 96
+          RespawnY: 139
+          DeathEvent: Flavius_TD::OnTeam2Die
+          QuitEvent: Flavius_TD::OnTeam2Quit
+          ActiveEvent: Flavius_TD::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 10
+    Name: Bossnia
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: bat_cc2
+        StartEvent: Tierra_Boss::OnStart
+        TeamA:
+          RespawnX: 88
+          RespawnY: 139
+          DeathEvent: Tierra_Boss::OnTeam1Die
+          QuitEvent: Tierra_Boss::OnTeam1Quit
+          ActiveEvent: Tierra_Boss::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 96
+          RespawnY: 139
+          DeathEvent: Tierra_Boss::OnTeam2Die
+          QuitEvent: Tierra_Boss::OnTeam2Quit
+          ActiveEvent: Tierra_Boss::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 11
+    Name: Rush
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: rush_cas01
+        StartEvent: Rush::OnStart
+        TeamA:
+          RespawnX: 202
+          RespawnY: 230
+          DeathEvent: Rush::OnTeam1Die
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 202
+          RespawnY: 226
+          DeathEvent: Rush::OnTeam2Die
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: rush_cas02
+        StartEvent: Rush::OnReady
+        TeamA:
+          RespawnX: 146
+          RespawnY: 50
+          DeathEvent: Rush::OnTeam1Die
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 146
+          RespawnY: 46
+          DeathEvent: Rush::OnTeam2Die
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: rush_cas03
+        StartEvent: Rush::OnReady
+        TeamA:
+          RespawnX: 60
+          RespawnY: 13
+          DeathEvent: Rush::OnTeam1Die
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 64
+          RespawnY: 13
+          DeathEvent: Rush::OnTeam2Die
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnTeam2Active
+          Variable: $@BG_Team2
+      - Map: rush_cas04
+        StartEvent: Rush::OnReady
+        TeamA:
+          RespawnX: 270
+          RespawnY: 292
+          DeathEvent: Rush::OnTeam1Die
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 270
+          RespawnY: 288
+          DeathEvent: Rush::OnTeam2Die
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 12
+    Name: Domination
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: bat_a04
+        StartEvent: Tierra_DOM::OnStart
+        TeamA:
+          RespawnX: 50
+          RespawnY: 374
+          DeathEvent: Tierra_DOM::OnTeamDie
+          QuitEvent: Tierra_DOM::OnTeam1Quit
+          ActiveEvent: Tierra_DOM::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 42
+          RespawnY: 16
+          DeathEvent: Tierra_DOM::OnTeamDie
+          QuitEvent: Tierra_DOM::OnTeam2Quit
+          ActiveEvent: Tierra_DOM::OnTeam2Active
+          Variable: $@BG_Team2
+  - Id: 13
+    Name: Double Inferno
+    MinPlayers: 1
+    MinLevel: 80
+    Locations:
+      - Map: region_8
+        StartEvent: Tierra_TI::OnStart
+        TeamA:
+          RespawnX: 10
+          RespawnY: 49
+          DeathEvent: Tierra_TI::OnTeamDie
+          QuitEvent: Tierra_TI::OnTeam1Quit
+          ActiveEvent: Tierra_TI::OnTeam1Active
+          Variable: $@BG_Team1
+        TeamB:
+          RespawnX: 89
+          RespawnY: 49
+          DeathEvent: Tierra_TI::OnTeamDie
+          QuitEvent: Tierra_TI::OnTeam2Quit
+          ActiveEvent: Tierra_TI::OnTeam2Active
+          Variable: $@BG_Team2
diff --git a/db/import/item_db_bg.yml b/db/import/item_db_bg.yml
new file mode 100644
index 0000000..e14cc75
--- /dev/null
+++ b/db/import/item_db_bg.yml
@@ -0,0 +1,101 @@
+# This file is a part of rAthena.
+#   Copyright(C) 2021 rAthena Development Team
+#   https://rathena.org - https://github.com/rathena
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+###########################################################################
+# Item Database
+###########################################################################
+#
+# Item Settings
+#
+###########################################################################
+# - Id                      Item ID.
+#   AegisName               Server name to reference the item in scripts and lookups, should use no spaces.
+#   Name                    Name in English for displaying as output.
+#   Type                    Item type. (Default: Etc)
+#   SubType                 Weapon, Ammo or Card type. (Default: 0)
+#   Buy                     Buying price. When not specified, becomes double the sell price. (Default: 0)
+#   Sell                    Selling price. When not specified, becomes half the buy price. (Default: 0)
+#   Weight                  Item weight. Each 10 is 1 weight. (Default: 0)
+#   Attack                  Weapon's attack. (Default: 0)
+#   MagicAttack             Weapon's magic attack. (Default: 0)
+#   Defense                 Armor's defense. (Default: 0)
+#   Range                   Weapon's attack range. (Default: 0)
+#   Slots                   Available slots in item. (Default: 0)
+#   Jobs                    Jobs that can equip the item. (Map default is 'All: true')
+#   Classes                 Upper class types that can equip the item. (Map default is 'All: true')
+#   Gender                  Gender that can equip the item. (Default: Both)
+#   Locations               Equipment's placement. (Default: None)
+#   WeaponLevel             Weapon level. (Default: 1 for Weapons)
+#   ArmorLevel              Armor level. (Default: 1 for Armors)
+#   EquipLevelMin           Minimum required level to equip. (Default: 0)
+#   EquipLevelMax           Maximum level that can equip. (Default: 0)
+#   Refineable              If the item can be refined. (Default: false)
+#   Gradable                If the item can be graded. (Default: false)
+#   View                    View sprite of an item. (Default: 0)
+#   AliasName               Another item's AegisName that will be sent to the client instead of this item's AegisName. (Default: null)
+#   Flags:                  Item flags. (Default: null)
+#     BuyingStore           If the item is available for Buyingstores. (Default: false)
+#     DeadBranch            If the item is a Dead Branch. (Default: false)
+#     Container             If the item is part of a container. (Default: false)
+#     UniqueId              If the item is a unique stack. (Default: false)
+#     BindOnEquip           If the item is bound to the character upon equipping. (Default: false)
+#     DropAnnounce          If the item has a special announcement to self on drop. (Default: false)
+#     NoConsume             If the item is consumed on use. (Default: false)
+#     DropEffect            If the item has a special effect on the ground when dropped by a monster. (Default: None)
+#   Delay:                  Item use delay. (Default: null)
+#     Duration              Duration of delay in seconds.
+#     Status                Status Change used to track delay. (Default: None)
+#   Stack:                  Item stack amount. (Default: null)
+#     Amount                Maximum amount that can be stacked.
+#     Inventory             If the stack is applied to player's inventory. (Default: true)
+#     Cart                  If the stack is applied to the player's cart. (Default: false)
+#     Storage               If the stack is applied to the player's storage. (Default: false)
+#     GuildStorage          If the stack is applied to the player's guild storage. (Default: false)
+#   NoUse:                  Conditions when the item is unusable. (Default: null)
+#     Override              Group level to override these conditions. (Default: 100)
+#     Sitting               If the item can not be used while sitting. (Default: false)
+#   Trade:                  Trade restrictions. (Default: null)
+#     Override              Group level to override these conditions. (Default: 100)
+#     NoDrop                If the item can not be dropped. (Default: false)
+#     NoTrade               If the item can not be traded. (Default: false)
+#     TradePartner          If the item can not be traded to the player's partner. (Default: false)
+#     NoSell                If the item can not be sold. (Default: false)
+#     NoCart                If the item can not be put in a cart. (Default: false)
+#     NoStorage             If the item can not be put in a storage. (Default: false)
+#     NoGuildStorage        If the item can not be put in a guild storage. (Default: false)
+#     NoMail                If the item can not be put in a mail. (Default: false)
+#     NoAuction             If the item can not be put in an auction. (Default: false)
+#   Script                  Script to execute when the item is used/equipped. (Default: null)
+#   EquipScript             Script to execute when the item is equipped. (Default: null)
+#   UnEquipScript           Script to execute when the item is unequipped or when a rental item expires. (Default: null)
+###########################################################################
+
+Header:
+  Type: ITEM_DB
+  Version: 3
+
+Body:
+  - Id: 8965
+    AegisName: Blue_Skull
+    Name: Blue Skull
+    Type: Etc
+    Weight: 0
+  - Id: 8966
+    AegisName: Red_Skull
+    Name: Red Skull
+    Type: Etc
+    Weight: 0
\ No newline at end of file
diff --git a/db/import/map_index.txt b/db/import/map_index.txt
index 4442e54..de369d9 100644
--- a/db/import/map_index.txt
+++ b/db/import/map_index.txt
@@ -16,3 +16,29 @@
 //
 //mymap	1250
 //mymap-2
+
+
+bat_a03
+bat_a04
+bat_a05
+bat_b03
+bat_b04
+bat_b05
+bat_c04
+bat_c05
+bat_c06
+bat_c07
+bat_c08
+schg_cas06
+schg_cas07
+schg_cas08
+arug_cas06
+arug_cas07
+arug_cas08
+rush_cas01
+rush_cas02
+rush_cas03
+rush_cas04
+region_8
+bat_cc
+bat_cc2
\ No newline at end of file
diff --git a/db/import/mob_avail.yml b/db/import/mob_avail.yml
index 789240f..31bfc6f 100644
--- a/db/import/mob_avail.yml
+++ b/db/import/mob_avail.yml
@@ -123,3 +123,23 @@ Header:
 #    Sprite: WHISPER
 #  - Mob: EP14_3_DEATH_B_MOB3
 #    Sprite: DARK_LORD
+
+Body:
+  - Mob: B_EMPEL_1
+    Sprite: S_EMPEL_1
+  - Mob: B_EMPEL_2
+    Sprite: S_EMPEL_2
+  - Mob: B_EMPERIUM
+    Sprite: EMPELIUM
+  - Mob: OBJ_NEUTRAL2
+    Sprite: OBJ_NEUTRAL
+  - Mob: OBJ_FLAG_A2
+    Sprite: OBJ_FLAG_A
+  - Mob: OBJ_FLAG_B2
+    Sprite: OBJ_FLAG_B
+  - Mob: BAPHOMET_BOSSNIA
+    Sprite: BAPHOMET
+  - Mob: LORD_OF_DEATH_BOSSNIA
+    Sprite: LORD_OF_DEATH
+  - Mob: THANATOS_BOSSNIA
+    Sprite: THANATOS
\ No newline at end of file
diff --git a/db/import/mob_db_bg.yml b/db/import/mob_db_bg.yml
new file mode 100644
index 0000000..f64be7c
--- /dev/null
+++ b/db/import/mob_db_bg.yml
@@ -0,0 +1,331 @@
+# This file is a part of rAthena.
+#   Copyright(C) 2021 rAthena Development Team
+#   https://rathena.org - https://github.com/rathena
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+###########################################################################
+# Monster Database
+###########################################################################
+#
+# Monster Settings
+#
+###########################################################################
+# - Id                      Monster ID.
+#   AegisName               Server name to reference the monster in scripts and lookups, should use no spaces.
+#   Name                    Name in English.
+#   JapaneseName            Name in Japanese. (Default: 'Name' value)
+#   Level                   Level. (Default: 1)
+#   Hp                      Total HP. (Default: 1)
+#   Sp                      Total SP. (Default: 1)
+#   BaseExp                 Base experience gained. (Default: 0)
+#   JobExp                  Job experience gained. (Default: 0)
+#   MvpExp                  MVP experience gained. (Default: 0)
+#   Attack                  Minimum attack in pre-renewal and base attack in renewal. (Default: 0)
+#   Attack2                 Maximum attack in pre-renewal and base magic attack in renewal. (Default: 0)
+#   Defense                 Physical defense of the monster, reduces melee and ranged physical attack/skill damage. (Default: 0)
+#   MagicDefense            Magic defense of the monster, reduces magical skill damage. (Default: 0)
+#   Resistance              Physical resistance of the monster, reduces melee and ranged physical attack/skill damage. (Default: 0)
+#   MagicResistance         Magic resistance of the monster, reduces magical skill damage. (Default: 0)
+#   Str                     Strength which affects attack. (Default: 1)
+#   Agi                     Agility which affects flee. (Default: 1)
+#   Vit                     Vitality which affects defense. (Default: 1)
+#   Int                     Intelligence which affects magic attack. (Default: 1)
+#   Dex                     Dexterity which affects hit rate. (Default: 1)
+#   Luk                     Luck which affects perfect dodge/lucky flee/perfect flee/lucky dodge rate. (Default: 1)
+#   AttackRange             Attack range. (Default: 0)
+#   SkillRange              Skill cast range. (Default: 0)
+#   ChaseRange              Chase range. (Default: 0)
+#   Size                    Size. (Default: Small)
+#   Race                    Race. (Default: Formless)
+#   RaceGroups:             List of secondary groups the monster may be part of. (Optional)
+#     <group>: <value>      Group to toggle.
+#   Element                 Element. (Default: Neutral)
+#   ElementLevel            Level of element. (Default: 1)
+#   WalkSpeed               Walk speed. (Default: DEFAULT_WALK_SPEED)
+#   AttackDelay             Attack speed. (Default: 0)
+#   AttackMotion            Attack animation speed. (Default: 0)
+#   DamageMotion            Damage animation speed. (Default: 0)
+#   DamageTaken             Rate at which the monster will receive incoming damage. (Default: 100)
+#   Ai                      Aegis monster type AI behavior. (Default: 06)
+#   Class                   Aegis monster class. (Default: Normal)
+#   Modes:                  List of unique behavior not defined by AI, Class, or Attribute. (Optional)
+#     <mode>: <value>       Mode to toggle.
+#   MvpDrops:               List of possible MVP prize items. Max of MAX_MVP_DROP. (Optional)
+#     - Item                Item name.
+#       Rate                Drop rate of item. (Default: 1)
+#       RandomOptionGroup   Random Option Group applied to item on drop. (Default: None)
+#       Index               Index used for overwriting item. (Optional)
+#   Drops:                  List of possible normal item drops. Max of MAX_MOB_DROP. (Optional)
+#     - Item                Item name.
+#       Rate                Drop rate of item. (Default: 1)
+#       StealProtected      If the item is shielded from TF_STEAL. (Default: false)
+#       RandomOptionGroup   Random Option Group applied to item on drop. (Default: None)
+#       Index               Index used for overwriting item. (Optional)
+###########################################################################
+
+Header:
+  Type: MOB_DB
+  Version: 3
+
+Body:
+  - Id: 20400
+    AegisName: B_EMPEL_1
+    Name: Guardian Stone
+    Level: 90
+    Hp: 300
+    Attack: 1
+    Attack2: 2
+    Defense: 100
+    MagicDefense: 99
+    Size: Large
+    Race: Formless
+    Element: Neutral
+    ElementLevel: 1
+    WalkSpeed: 300
+    AttackDelay: 1288
+    AttackMotion: 288
+    DamageMotion: 384
+    Class: Battlefield
+    Modes:
+      IgnoreMagic: true
+      IgnoreMelee: true
+      IgnoreMisc: true
+      IgnoreRanged: true
+      Detector: true
+      KnockBackImmune: true
+  - Id: 20401
+    AegisName: B_EMPEL_2
+    Name: Guardian Stone
+    Level: 90
+    Hp: 300
+    Attack: 1
+    Attack2: 2
+    Defense: 100
+    MagicDefense: 99
+    Size: Large
+    Race: Formless
+    Element: Neutral
+    ElementLevel: 1
+    WalkSpeed: 300
+    AttackDelay: 1288
+    AttackMotion: 288
+    DamageMotion: 384
+    Class: Battlefield
+    Modes:
+      IgnoreMagic: true
+      IgnoreMelee: true
+      IgnoreMisc: true
+      IgnoreRanged: true
+      Detector: true
+      KnockBackImmune: true
+  - Id: 20402
+    AegisName: B_EMPERIUM
+    Name: Emperium
+    Level: 90
+    Hp: 100
+    Attack: 1
+    Attack2: 2
+    Defense: 100
+    MagicDefense: 99
+    Size: Large
+    Race: Formless
+    Element: Neutral
+    ElementLevel: 1
+    WalkSpeed: 300
+    AttackDelay: 1288
+    AttackMotion: 288
+    DamageMotion: 384
+    Class: Guardian
+    Modes:
+      IgnoreMagic: true
+      IgnoreMelee: true
+      IgnoreMisc: true
+      IgnoreRanged: true
+      Detector: true
+      KnockBackImmune: true
+  - Id: 20403
+    AegisName: OBJ_NEUTRAL2
+    Name: Neutrality Flag
+    Level: 90
+    Hp: 150
+    Attack: 1
+    Attack2: 2
+    Defense: 100
+    MagicDefense: 99
+    Size: Large
+    Race: Formless
+    Element: Neutral
+    ElementLevel: 1
+    WalkSpeed: 300
+    AttackDelay: 1288
+    AttackMotion: 288
+    DamageMotion: 384
+    Class: Guardian
+    Modes:
+      IgnoreMagic: true
+      IgnoreMelee: true
+      IgnoreMisc: true
+      IgnoreRanged: true
+      Detector: true
+      KnockBackImmune: true
+  - Id: 20404
+    AegisName: OBJ_FLAG_A2
+    Name: Lion Flag
+    Level: 90
+    Hp: 150
+    Attack: 1
+    Attack2: 2
+    Defense: 100
+    MagicDefense: 99
+    Size: Large
+    Race: Formless
+    Element: Neutral
+    ElementLevel: 1
+    WalkSpeed: 300
+    AttackDelay: 1288
+    AttackMotion: 288
+    DamageMotion: 384
+    Class: Guardian
+    Modes:
+      IgnoreMagic: true
+      IgnoreMelee: true
+      IgnoreMisc: true
+      IgnoreRanged: true
+      Detector: true
+      KnockBackImmune: true
+  - Id: 20405
+    AegisName: OBJ_FLAG_B2
+    Name: Eagle Flag
+    Level: 90
+    Hp: 150
+    Attack: 1
+    Attack2: 2
+    Defense: 100
+    MagicDefense: 99
+    Size: Large
+    Race: Formless
+    Element: Neutral
+    ElementLevel: 1
+    WalkSpeed: 300
+    AttackDelay: 1288
+    AttackMotion: 288
+    DamageMotion: 384
+    Class: Guardian
+    Modes:
+      IgnoreMagic: true
+      IgnoreMelee: true
+      IgnoreMisc: true
+      IgnoreRanged: true
+      Detector: true
+      KnockBackImmune: true
+  - Id: 21406
+    AegisName: BAPHOMET_BOSSNIA
+    Name: Baphomet
+    Level: 81
+    Hp: 668000
+    BaseExp: 0
+    JobExp: 0
+    MvpExp: 0
+    Attack: 3220
+    Attack2: 4040
+    Defense: 35
+    MagicDefense: 45
+    Agi: 152
+    Vit: 30
+    Int: 85
+    Dex: 120
+    Luk: 95
+    AttackRange: 2
+    SkillRange: 10
+    ChaseRange: 12
+    Size: Large
+    Race: Demon
+    Element: Dark
+    ElementLevel: 3
+    WalkSpeed: 100
+    AttackDelay: 768
+    AttackMotion: 768
+    DamageMotion: 576
+    Ai: 21
+    Class: Boss
+    Modes:
+      Mvp: true
+  - Id: 21407
+    AegisName: LORD_OF_DEATH_BOSSNIA
+    Name: Lord of the Dead
+    JapaneseName: Lord of Death
+    Level: 94
+    Hp: 603383
+    BaseExp: 0
+    JobExp: 0
+    MvpExp: 0
+    Attack: 3430
+    Attack2: 4232
+    Defense: 77
+    MagicDefense: 73
+    Agi: 99
+    Vit: 30
+    Int: 109
+    Dex: 100
+    Luk: 106
+    AttackRange: 3
+    SkillRange: 10
+    ChaseRange: 12
+    Size: Large
+    Race: Demon
+    Element: Dark
+    ElementLevel: 3
+    WalkSpeed: 180
+    AttackDelay: 1446
+    AttackMotion: 1296
+    DamageMotion: 360
+    Ai: 21
+    Class: Boss
+    Modes:
+      Mvp: true
+  - Id: 21408
+    AegisName: THANATOS_BOSSNIA
+    Name: Memory of Thanatos
+    JapaneseName: Thanatos
+    Level: 98
+    Hp: 445660
+    BaseExp: 0
+    JobExp: 0
+    MvpExp: 0
+    Attack: 3812
+    Attack2: 7483
+    Defense: 35
+    MagicDefense: 35
+    Str: 100
+    Agi: 108
+    Vit: 30
+    Int: 86
+    Dex: 147
+    Luk: 32
+    AttackRange: 3
+    SkillRange: 10
+    ChaseRange: 12
+    Size: Large
+    Race: Demon
+    Element: Ghost
+    ElementLevel: 4
+    WalkSpeed: 120
+    AttackDelay: 115
+    AttackMotion: 816
+    DamageMotion: 504
+    Ai: 21
+    Class: Boss
+    Modes:
+      Mvp: true
diff --git a/db/item_db.yml b/db/item_db.yml
index 4b326a4..60d3459 100644
--- a/db/item_db.yml
+++ b/db/item_db.yml
@@ -95,3 +95,4 @@ Footer:
   - Path: db/re/item_db.yml
     Mode: Renewal
   - Path: db/import/item_db.yml
+  - Path: db/import/item_db_bg.yml
diff --git a/db/mob_db.yml b/db/mob_db.yml
index 48e29e9..9ce8522 100644
--- a/db/mob_db.yml
+++ b/db/mob_db.yml
@@ -86,3 +86,4 @@ Footer:
   - Path: db/re/mob_db.yml
     Mode: Renewal
   - Path: db/import/mob_db.yml
+  - Path: db/import/mob_db_bg.yml
diff --git a/npc/custom/eBG/bg_common.txt b/npc/custom/eBG/bg_common.txt
new file mode 100644
index 0000000..877fbeb
--- /dev/null
+++ b/npc/custom/eBG/bg_common.txt
@@ -0,0 +1,534 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  30-01-2023
+// By:
+//  Easycore         (Zephyrus, original author)
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Common NPCs
+// ==============================================================================
+
+// MapFlags
+// *********************************************************************
+
+bat_room	mapflag	nomemo
+bat_room	mapflag	nowarpto
+bat_room	mapflag	nobranch
+bat_room	mapflag	nopenalty
+bat_room	mapflag	noteleport
+bat_room	mapflag	nosave	SavePoint
+//bat_room	mapflag	allow_bg_items // Funcion no agregada [Easycore]
+// Mapflag Town is required to Join BG Queues
+bat_room	mapflag	town
+
+// General Guillaume
+// *********************************************************************
+bat_room,160,159,3	script	General Guillaume	4_M_KY_KIYOM,{
+	cutin "bat_kiyom2",2;
+	mes "[General Guillaume]";
+	mes "Hot-blooded adventurer, we need your ability to win this battle.";
+	next;
+	cutin "bat_kiyom1",2;
+	mes "[General Guillaume]";
+	mes "Our great king, Marcel Marollo VII, is very sick lately. His Majesty has declared that he chosen either me or Prince Croix as the next king amongst his 9 sons.";
+	next;
+	mes "[General Guillaume]";
+	mes "Two kings can't share a nation!";
+	mes "Only the one victorious from His Majesty's appointed battle will be enthroned.";
+	next;
+	mes "[General Guillaume]";
+	mes "This is however, not just a battle between us. This battle will determine the future of this country. I pledge on my honor to prove that I'm the one who can protect this Maroll from outside threats.";
+	close2;
+	cutin "",255;
+	end;
+}
+
+// General Croix
+// *********************************************************************
+bat_room,160,140,3	script	Prince Croix	4_M_CRU_CRUA,{
+	cutin "bat_crua1",2;
+	mes "[Prince Croix]";
+	mes "Wise adventurer, why don't you lend us your power for victory?";
+	next;
+	cutin "bat_crua2",2;
+	mes "[Prince Croix]";
+	mes "I do not wish to shed blood, but I have no choice but to fight for the possibility of peace and for the sake of my people.";
+	next;
+	mes "[Prince Croix]";
+	mes "General Guillaume may have an advantage in this battle as he is the great general of Maroll, but that doesn't automatically mean he'll win. I want to win this battle so that I can grant a better future for my people.";
+	close2;
+	cutin "",255;
+	end;
+}
+
+// Guard Dummy
+// *********************************************************************
+
+bat_room,161,141,3	script	Prince Croix's Aid::bat_aid	4_M_CRU_HEAD,{ end; }
+bat_room,161,139,3	duplicate(bat_aid)	Prince Croix's Aid::bat_aid2	4_M_CRU_HEAD
+bat_room,161,160,3	duplicate(bat_aid)	General Guillaume's Aid::bat_aid3	4_M_KY_HEAD
+bat_room,161,158,3	duplicate(bat_aid)	General Guillaume's Aid::bat_aid4	4_M_KY_HEAD
+
+// Flags
+// *********************************************************************
+
+-	script	Base Flag#bg	FAKE_NPC,{ end; }
+
+// BattleGround Warper - Exit
+// *********************************************************************
+
+bat_room,148,150,4	script	Teleporter#bat	4_F_TELEPORTER,{
+	mes "[Teleporter]";
+	mes "Do you wish to leave the battlefield? Use my service to return to town.";
+	next;
+	if (select("Leave:Don't Leave") == 2) {
+		mes "[Teleporter]";
+		mes "I'll be here whenever you're in need of my service.";
+		close;
+	}
+	set .@spoint$, getsavepoint(0);
+	set .@x, getsavepoint(1);
+	set .@y, getsavepoint(2);
+	mes "[Teleporter]";
+	mes "You will be sent back to " + .@spoint$ + ".";
+	close2;
+	warp .@spoint$, .@x, .@y;
+	end;
+}
+
+// Kafra
+// *********************************************************************
+bat_room,148,147,4	script	Kafra Staff::kaf_bat	4_F_KAFRA9,{
+	cutin "kafra_09",2;
+	callfunc "F_Kafra",0,2,1,150,0;
+}
+
+//== Badges Exchange =======================================
+bat_room,160,150,3	script	Erundek	4_M_MANAGER,{
+	if (checkweight(1201,1) == 0) {
+		mes "- Wait a minute !! -";
+		mes "- Currently you're carrying -";
+		mes "- too many items with you. -";
+		mes "- Please try again -";
+		mes "- after you loose some weight. -";
+		close;
+	}
+	mes "[Erundek]";
+	mes "Do you have the battlefield badges?";
+	mes "I can exchange Bravery Badges and Valor Badges for reward items.";
+	next;
+	switch(select("Exchange Badges", "Check the Catalog")) {
+		case 1:
+			mes "[Erundek]";
+			mes "Which type of items would you like to exchange?";
+			mes "To check more information about the reward items, please use our ^3131FFCatalog^000000.";
+			next;
+			switch(select("Weapon", "Armor", "Accessory", "Consumable")) {
+				case 1:
+					mes "[Erundek]";
+					mes "You chose ^3131FFWeapon^000000.";
+					mes "The following weapons are available for exchange with the battlefield badges.";
+					mes "Please note that items for ^3131FFBravery Badges are indicated as (BB)^000000, and ^3131FFValor Badges as (VB)^000000.";
+					next;
+					switch(select("Dagger/OneSword/TwoSword/TwoSpear", "Staff/Mace/TwoAxe/Shuriken", "Bow/Katar/Music/Whip", "Book/Knuckle", "Revolver/Rifle/Gatling/Shotgun/Launcher")) {
+						case 1:
+							mes "[Erundek]";
+							mes "The following items are available in the ^3131FFDagger, One-Handed Sword, Two-Handed Sword, and Two-Handed Spear^000000 category.";
+							next;
+							setarray .@Weapons[0],13036,7828,13037,7829,13411,7828,13410,7829,1183,7828,1184,7829,1425,7828,1482,7829;
+							break;
+						case 2:
+							mes "[Erundek]";
+							mes "The following items are available in the ^3131FFStaff / Mace / Two-Handed Axe / Huuma Shuriken^000000 category.";
+							next;
+							setarray .@Weapons[0],1632,7828,1633,7829,1634,7828,1635,7829,1543,7828,1542,7829,1380,7828,1379,7829,13305,7828,13306,7829;
+							break;
+						case 3:
+							mes "[Erundek]";
+							mes "The following weapons are available in the ^3131FFBow / Katar / Musical Instrument / Whip^000000 category.";
+							next;
+							setarray .@Weapons[0],1739,7828,1738,7829,1279,7828,1280,7829,1924,7828,1923,7829,1978,7828,1977,7829;
+							break;
+						case 4:
+							mes "[Erundek]";
+							mes "The following weapons are available in the ^3131FFBook / Knuckle^000000 category.";
+							next;
+							setarray .@Weapons[0],1574,7828,1575,7829,1824,7828,1823,7829;
+							break;
+						case 5:
+							mes "[Erundek]";
+							mes "The following weapons are available in the ^3131FFRevolver / Rifle / Gatling Gun / Shotgun / Grenade Launcher^000000 category.";
+							next;
+							setarray .@Weapons[0],13108,7828,13171,7829,13172,7828,13173,7829,13174,7829;
+							break;
+					}
+					.@menu$ = "";
+					for (.@i = 0; .@i < getarraysize(.@Weapons); .@i += 2)
+						.@menu$ += getitemname(.@Weapons[.@i])+((.@Weapons[.@i+1]==7828)?"(BB)":"(VB)")+":";
+					.@i = (select(.@menu$)-1)*2;
+					.@type$ = ((.@Weapons[.@i+1]==7828)?"(BB)":"(VB)");
+					mes "[Erundek]";
+					mes "You chose ^3131FF"+getitemname(.@Weapons[.@i])+.@type$+"^000000.";
+					mes "You can exchange for this item with ^FF0000100 "+getitemname(.@Weapons[.@i+1])+"^000000.";
+					mes "Would you like to exchange?";
+					next;
+					switch(select("Do not exchange", "Exchange")) {
+						case 1:
+							break;
+						case 2:
+							mes "[Erundek]";
+							mes "Would you like to spend ^FF0000100 "+getitemname(.@Weapons[.@i+1])+"^000000 and receive a ^3131FF"+getitemname(.@Weapons[.@i])+.@type$+"^000000?";
+							next;
+							mes "[Erundek]";
+							mes "Remember, Battleground Reward Items are ^FF0000Character Bound^000000. Are you sure you want this item?";
+							next;
+							switch(select("Yes", "No")) {
+							case 1:
+								mes "[Erundek]";
+								if (countitem(.@Weapons[.@i+1]) >= 100) {
+									mes "Thank you for exchanging.";
+									delitem .@Weapons[.@i+1],100;
+									getitem .@Weapons[.@i],1;
+								}
+								else mes "I'm sorry, but you don't have enough badges to exchange.";
+								close;
+							case 2:
+								break;
+							}
+							break;
+					}
+					mes "[Erundek]";
+					mes "Do you need more time to check the items?";
+					close;
+				case 2:
+					mes "[Erundek]";
+					mes "You chose ^3131FFArmor^000000.";
+					mes "The following armors are available for exchange with the battlefield badges.";
+					next;
+					switch(select("Garments / Shoes", "Armor")) {
+						case 1:
+							setarray .@items[0],2538,50,2539,50,2540,50,2435,50,2436,50,2437,50;
+							break;
+						case 2:
+							setarray .@items[0],2376,80,2377,80,2378,80,2379,80,2380,80,2381,80,2382,80;
+							break;
+						}
+					break;
+				case 3:
+					mes "[Erundek]";
+					mes "You chose ^3131FFAccessory^000000.";
+					mes "You can exchange the Medal of Honors with your Badges according to the job classes, as follows:";
+					next;
+					setarray .@items[0],2733,500,2720,500,2721,500,2722,500,2723,500,2724,500,2725,500;
+					.@menu1$ = "Gunslinger:Swordman/Taekwon Master:Thief:Acolyte:Magician:Archer:Merchant";
+					break;
+				case 4:
+					mes "[Erundek]";
+					mes "You chose ^3131FFConsumable^000000.";
+					mes "The following consumable items are available for exchange with the battlefield badges:";
+					next;
+					setarray .@items[0],12269,10,12270,10,12271,5,12272,10,12273,10;
+					break;
+			}
+			break;
+		case 2:
+			mes "[Erundek]";
+			mes "We have many items, so please take a look and purchase deliberately.";
+			close2;
+			readbook 11010,1;
+			end;
+	}
+	.@menu$ = "";
+	if (.@menu1$ != "") .@menu$ = .@menu1$;
+	else for (.@i = 0; .@i < getarraysize(.@items); .@i += 2)
+		.@menu$ += getitemname(.@items[.@i])+":";
+	.@i = (select(.@menu$)-1)*2;
+	mes "[Erundek]";
+	mes "You chose ^3131FF"+getitemname(.@items[.@i])+"^000000.";
+	switch(.@items[.@i]) {
+		case 2720: mes "This item is for Swordman and Taekwon Master Class only."; break;
+		case 2721: mes "This item is for Thief Class only."; break;
+		case 2722: mes "This item is for Acolyte Class only."; break;
+		case 2723: mes "This item is for Magician Class only."; break;
+		case 2724: mes "This item is for Archer Class only."; break;
+		case 2725: mes "This item is for Merchant Class only."; break;
+		case 2733: mes "This item is for Gunslinger only."; break;
+		default: break;
+	}
+	mes "You can exchange for this item with ^FF0000"+.@items[.@i+1]+" "+getitemname(7828)+" or "+.@items[.@i+1]+" "+getitemname(7829)+"^000000.";
+	mes "Would you like to exchange?";
+	next;
+	switch(select("Do not exchange", "Exchange")) {
+		case 1:
+			mes "[Erundek]";
+			mes "Do you need more time to check the items?";
+			break;
+		case 2:
+			mes "[Erundek]";
+			mes "Which Badge do you want to exchange?";
+			mes "You need ^3131FF"+.@items[.@i+1]+" Badges^000000 to exchange.";
+			next;
+			if (.@item[0] < 12269 || .@item[0] > 12273) {
+				mes "[Erundek]";
+				mes "Remember, Battleground Reward Items are ^FF0000Character Bound^000000. Are you sure you want this item?";
+				next;
+			}
+			.@j = select("Bravery Badge", "Valor Badge", "Cancel");
+			mes "[Erundek]";
+			if (.@j == 3) {
+				mes "You cancelled the exchange.";
+				break;
+			}
+			.@cost = ((.@j==1)?7828:7829);
+			if (countitem(.@cost) >= .@items[.@i+1]) {
+				mes "Thank you for exchanging.";
+				delitem .@cost, .@items[.@i+1];
+				getitem .@items[.@i],1;
+			}
+			else mes "You do not have enough "+getitemname(.@cost)+"s.";
+			break;
+	}
+	close;
+}
+
+bat_room,160,148,3	script	Telma	701,{
+	mes "[Telma]";
+	mes "Welcome, mighty warrior.";
+	mes "Do you need supplies for your battles?";
+	mes "I can exchange supplies for your badges...";
+
+	if (select("~ BG Supplies","~ WoE Supplies")==2) {
+		next;
+		mes "[Telma]";
+		mes "These supplies only work on ^FF0000WoE Maps^000000.";
+		switch(select("150 Condensed White Potion:150 Blue Potion:50 Glistening Coat:100 Bottle Grenade:100 Acid Bottle:300 Cobweb:5 Poison Bottle:80 Yellow Gemstone:70 Red Gemstone:60 Blue Gemstone:100 Speed Potion")) {
+		case 1:		callsub S_BuyConsumableWOE,547,150,100;		// Condensed White Potion
+		case 2:		callsub S_BuyConsumableWOE,505,150,100;		// Blue Potion
+		case 3:		callsub S_BuyConsumableWOE,7139,50,30;		// Glistening Coat
+		case 4:		callsub S_BuyConsumableWOE,7135,100,60;		// Bottle Grenade
+		case 5:		callsub S_BuyConsumableWOE,7136,100,60;		// Acid Bottle
+		case 6:		callsub S_BuyConsumableWOE,1025,300,80;		// Cobweb
+		case 7:		callsub S_BuyConsumableWOE,678,5,10;		// Poison Bottle
+		case 8:		callsub S_BuyConsumableWOE,715,80,20;	// Yellow Gemstone
+		case 9:		callsub S_BuyConsumableWOE,716,70,15;	// Red Gemstone
+		case 10:	callsub S_BuyConsumableWOE,717,60,10;	// Blue Gemstone
+		case 11:	callsub S_BuyConsumableWOE,12016,100,100;	// Speed Potion
+		}
+	}
+
+	switch(select("150 Condensed White Potion:100 Blue Potion:15 Poison Bottle:50 Fire Bottle:50 Acid Bottle:50 Plant Bottle:50 Marine Sphere Bottle:50 Glistening Coat:50 Yellow Gemstone:50 Red Gemstone:100 Blue Gemstone:5 Speed Potion:20 Cobweb:10 Awakening Potion:10 Berserk Potion")) {
+		case 1:		callsub S_BuyConsumableBG,547,150;	// Condensed White Potion
+		case 2:		callsub S_BuyConsumableBG,505,100;	// Blue Potion
+		case 3:		callsub S_BuyConsumableBG,678,15;	// Poison Bottle
+		case 4:		callsub S_BuyConsumableBG,7135,50;	// Fire Bottle
+		case 5:		callsub S_BuyConsumableBG,7136,50;	// Acid Bottle
+		case 6:		callsub S_BuyConsumableBG,7137,50;	// Plant Bottle
+		case 7:		callsub S_BuyConsumableBG,7138,50;	// Marine Sphere Bottle
+		case 8:		callsub S_BuyConsumableBG,7139,50;	// Glistening Coat
+		case 9:		callsub S_BuyConsumableBG,715,50;	// Yellow Gemstone
+		case 10:	callsub S_BuyConsumableBG,716,50;	// Red Gemstone
+		case 11:	callsub S_BuyConsumableBG,717,100;	// Blue Gemstone
+		case 12:	callsub S_BuyConsumableBG,12016,5;	// Speed Potion
+		case 13:	callsub S_BuyConsumableBG,1025,20;	// Cobweb
+		case 14:	callsub S_BuyConsumableBG,14510,10;	// Light Awakening Potion
+		case 15:	callsub S_BuyConsumableBG,14511,20;	// Light Berserk Potion
+	}
+	end;
+
+S_BuyConsumableBG:
+	set .@item_id, getarg(0);
+	set .@amt, getarg(1);
+	next;
+	.@bg_item = 1;
+	mes "[Telma]";
+	mes "How many ^0000FF"+ .@amt +" "+ getitemname(.@item_id) +"s^000000 do you want?";
+	mes "1 = "+ .@amt   +" supplies = 1 badge";
+	mes "2 = "+ .@amt*2 +" supplies = 2 badges";
+	mes "3 = "+ .@amt*3 +" supplies = 3 badges";
+	mes "etc..";
+	next;
+	input .@sets;
+	mes "[Telma]";
+	if (.@sets < 1) {
+		mes "Put a positive number, greater than zero.";
+		close;
+	}
+	mes "So you want ^0000FF"+ (.@amt*.@sets) +" "+ getitemname(.@item_id) +"s^000000...";
+	mes "Remember these can only be used in Battleground Arenas";
+	mes "It will cost you "+ .@sets +" badge(s)...";
+	next;
+	switch(select("Give her "+ .@sets +" Bravery Badge(s):Give her "+ .@sets +" Valor Badge(s):Give her "+ .@sets +" War Badges")) {
+		case 1: set .@badge,7828; set .@cost,1; break;
+		case 2: set .@badge,7829; set .@cost,1; break;
+		case 3: set .@badge,7773; set .@cost,1; break;
+	}
+	.@bgchar = getBattleFlag("bg_reserved_char_id");
+	mes "[Telma]";
+	if (countitem(.@badge) < (.@cost*.@sets)) {
+		mes "You do not have enough ^FF0000"+getitemname(.@badge)+"s^000000 to buy "+(.@amt*.@sets)+" "+getitemname(.@item_id)+"s.";
+	} else if (!checkweight(.@item_id, .@amt*.@sets)) {
+		mes "You are overweight or have too many items in your inventory.";
+	} else {
+		delitem .@badge, .@cost*.@sets;
+		// Battleground's Consumables
+		getitem2 .@item_id,(.@amt*.@sets),1,0,0, 254, 0, .@bgchar & 0xFFFF, .@bgchar >> 0x10;
+		mes "Here are your: ^0000FF"+(.@amt*.@sets)+" "+getitemname(.@item_id)+"s^000000!";
+		mes "Remember they can only be used in Battleground Arenas";
+	}
+	close;
+
+S_BuyConsumableWOE:
+	set .@item_id, getarg(0);
+	set .@amt, getarg(1);
+	set .@cost, getarg(2);
+	set .@badge,7773;
+	next;
+	.@bg_item = 0;
+	.@sets = 1;
+	mes "[Telma]";
+	mes "So you want ^0000FF"+ (.@amt*.@sets) +" "+ getitemname(.@item_id) +"s^000000...";
+	next;
+	if (select("Give her ^FF0000"+.@cost+"^000000 War Badge(s)","Cancel")==2) close;
+	.@woechar = getBattleFlag("woe_reserved_char_id");
+	mes "[Telma]";
+	if (countitem(.@badge) < (.@cost*.@sets)) {
+		mes "You do not have enough ^FF0000"+getitemname(.@badge)+"s^000000 to buy "+(.@amt*.@sets)+" "+getitemname(.@item_id)+"s.";
+	} else if (!checkweight(.@item_id, .@amt*.@sets)) {
+		mes "You are overweight or have too many items in your inventory.";
+	} else {
+		delitem .@badge, .@cost*.@sets;
+		// WoE's Consumables
+		getitem2 .@item_id,(.@amt*.@sets),1,0,0, 254, 0, .@woechar & 0xFFFF, .@woechar >> 0x10;
+		mes "Here are your: ^0000FF"+(.@amt*.@sets)+" "+getitemname(.@item_id)+"s^000000!";
+		mes "Remember they can only be used in WoE Maps";
+	}
+	close;
+}
+
+-	script	Maroll Battle Recruiter::BatRecruit	728,{
+	mes "[Maroll Battle Recruiter]";
+	mes "Good day, adventurer.";
+	mes "I'm a knight from a far country called Maroll Kingdom.";
+	next;
+	mes "[Maroll Battle Recruiter]";
+	mes "The two princes of the kingdom are now battling for the throne of Maroll, and are in need of experienced soldiers like you.";
+	next;
+	switch(select("Join Battlegrounds:Warp to Battleground Room:Quit")) {
+		case 1:
+			next;
+			mes "[Maroll Battle Recruiter]";
+			mes "You will be sent to the waiting queue.";
+			close2;
+			doevent("BG_Core::OnDoJoinSolo");
+			end;
+		case 2:
+			mes "[Maroll Battle Recruiter]";
+			mes "May the war god bless you.";
+			close2;
+			getmapxy(.@mapname$,.@x,.@y,BL_NPC);
+			if (.@mapname$ == "prontera")
+				set bat_return,1;
+			else if (.@mapname$ == "moc_ruins")
+				set bat_return,2;
+			else if (.@mapname$ == "aldebaran")
+				set bat_return,3;
+			else if (.@mapname$ == "geffen")
+				set bat_return,4;
+			else if (.@mapname$ == "payon")
+				set bat_return,5;
+			else if (.@mapname$ == "lighthalzen")
+				set bat_return,6;
+			else if (.@mapname$ == "rachel")
+				set bat_return,7;
+			else if (.@mapname$ == "morocc")
+				set bat_return,8;
+			else
+				set bat_return,1;
+			warp "bat_room",154,150;
+			break;
+		case 3:
+			mes "[Maroll Battle Recruiter]";
+			mes "I'll always be stationed here for more soldiers. Feel free to come back whenever you're interested.";
+			close;
+	}
+	end;
+}
+
+prontera,123,83,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit1	728
+moc_ruins,75,162,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit2	728
+aldebaran,146,109,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit3	728
+geffen,109,66,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit4	728
+payon,189,105,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit5	728
+lighthalzen,153,86,5	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit6	728
+rachel,149,138,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit7	728
+
+// BattleGround Warper
+//============================================================
+bat_room,148,150,5	script	Teleporter#Battlefield	124,{
+	mes "[Teleporter]";
+	mes "Do you wish to leave the battlefield? Use my services to return to town.";
+	next;
+	switch(select("Leave:Don't Leave")) {
+	case 1:
+		mes "[Teleporter]";
+		switch(bat_return) {
+		default:
+		case 1:
+			setarray .@mapname$[0],"Prontera.","prontera";
+			setarray .@xy[0],116,72;
+			break;
+		case 2:
+			setarray .@mapname$[0],"Morocc Ruins.","moc_ruins";
+			setarray .@xy[0],152,48;
+			break;
+		case 3:
+			setarray .@mapname$[0],"Al De Baran.","aldebaran";
+			setarray .@xy[0],168,112;
+			break;
+		case 4:
+			setarray .@mapname$[0],"Geffen.","geffen";
+			setarray .@xy[0],120,39;
+			break;
+		case 5:
+			setarray .@mapname$[0],"Payon.","payon";
+			setarray .@xy[0],161,58;
+			break;
+		case 6:
+			setarray .@mapname$[0],"Lighthalzen.","lighthalzen";
+			setarray .@xy[0],159,93;
+			break;
+		case 7:
+			setarray .@mapname$[0],"Rachel.","rachel";
+			setarray .@xy[0],115,124;
+			break;
+		case 8:
+			setarray .@mapname$[0],"Morocc.","morocc";
+			setarray .@xy[0],156,46;
+			break;
+		}
+		mes "You will be sent back to "+.@mapname$[0]+".";
+		close2;
+		warp .@mapname$[1],.@xy[0],.@xy[1];
+		break;
+	case 2:
+		mes "[Teleporter]";
+		mes "I'll be here whenever you're in need of my services.";
+		close;
+	}
+	end;
+}
+
+// Repairman
+//============================================================
+bat_room,142,146,3	script	Repairman#bat_room	52,{
+	callfunc "repairmain","Reparador";
+	end;
+}
\ No newline at end of file
diff --git a/npc/custom/eBG/bg_conquest.txt b/npc/custom/eBG/bg_conquest.txt
new file mode 100644
index 0000000..fed8040
--- /dev/null
+++ b/npc/custom/eBG/bg_conquest.txt
@@ -0,0 +1,2196 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  21-01-2023
+// By:
+//  Easycore         (Zephyrus, original author)
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Conquest 1
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Conquest	FAKE_NPC,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	// ===========
+	// For Barricade, GStone and Emperium Configurations edit db/import/mob_db_bg.yml
+	// ===========
+	// Cementery Walls
+	setwall "schg_cas06",291,376,8,0,0,"conquest_wall_a";
+	setwall "schg_cas06",268,376,8,0,0,"conquest_wall_b";
+	setwall "schg_cas07",93,301,21,0,0,"conquest_wall_c";
+	setwall "schg_cas07",110,301,21,0,0,"conquest_wall_d";
+	setwall "schg_cas08",84,43,6,6,0,"conquest_wall_e";
+	setwall "schg_cas08",26,43,6,6,0,"conquest_wall_f";
+	setwall "arug_cas06",121,353,10,0,0,"conquest_wall_g";
+	setwall "arug_cas06",25,377,10,6,0,"conquest_wall_h";
+	setwall "arug_cas07",291,335,7,6,0,"conquest_wall_i1";
+	setwall "arug_cas07",300,335,6,6,0,"conquest_wall_j1";
+	setwall "arug_cas07",291,312,7,6,0,"conquest_wall_i2";
+	setwall "arug_cas07",300,312,4,6,0,"conquest_wall_j2";
+	setwall "arug_cas08",317,150,8,0,0,"conquest_wall_k";
+	setwall "arug_cas08",326,150,8,0,0,"conquest_wall_l";
+	.Index = -1;
+	end;
+
+OnTeam1Active:
+	warp .Castle$,.GX,.GY;
+	end;
+OnTeam2Active:
+	warp .Castle$,.CX,.CY;
+	end;
+
+OnTeam1Die:
+OnTeam2Die:
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert;
+	end;
+
+OnStart:
+	// Building Teams and Maps
+	if ((.Index++) > 5)
+		.Index = 0;
+	switch(.Index) { // Rotate Castle
+		case 0: set .Castle$,"schg_cas06"; set .GX,264; set .GY,379; set .CX,295; set .CY,379; set .DX,120; set .DY,290; set .AX,119; set .AY,  8; break;
+		case 1: set .Castle$,"schg_cas07"; set .GX, 90; set .GY,311; set .CX,113; set .CY,311; set .DX,136; set .DY,188; set .AX,339; set .AY, 78; break;
+		case 2: set .Castle$,"schg_cas08"; set .GX, 28; set .GY, 50; set .CX, 87; set .CY, 50; set .DX,308; set .DY,208; set .AX,337; set .AY,330; break;
+		case 3: set .Castle$,"arug_cas06"; set .GX, 30; set .GY,381; set .CX,126; set .CY,357; set .DX, 67; set .DY,193; set .AX,275; set .AY, 93; break;
+		case 4: set .Castle$,"arug_cas07"; set .GX,298; set .GY,339; set .CX,298; set .CY,308; set .DX, 43; set .DY,256; set .AX,139; set .AY, 31; break;
+		case 5: set .Castle$,"arug_cas08"; set .GX,313; set .GY,154; set .CX,330; set .CY,154; set .DX,121; set .DY,318; set .AX,141; set .AY, 45; break;
+	}
+	bg_set_cemetery($@BG_Team1,.Castle$,.GX,.GY);
+	bg_set_cemetery($@BG_Team2,.Castle$,.CX,.CY);
+
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+
+	initnpctimer;
+	donpcevent "Conquest_Respawn::OnStart";
+	set .Score, 0;
+	switch(rand(2)) {
+		case 1:
+			set .defender, $@BG_Team1;
+			set .Atacker, $@BG_Team2;
+			break;
+		case 0:
+			set .defender, $@BG_Team2;
+			set .Atacker, $@BG_Team1;
+			break;
+	}
+	// =========================================================================
+	// Build Structures
+	// =========================================================================
+	switch( .Index ) {
+		case 0:
+			setwall .Castle$,114,48,13,6,0,"conq_RL00";
+			setwall .Castle$,114,51,13,6,1,"conq_RL01";
+			setwall .Castle$,114,154,13,6,1,"conq_RL02";
+			setwall .Castle$,116,241,11,6,1,"conq_RL03";
+
+			bg_monster .Defender,.Castle$,115,49," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,117,49," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,119,49," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,121,49," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,123,49," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,125,49," ",1906,"Conquest::OnBarricade0";
+
+			bg_monster .Defender,.Castle$,115,50," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,117,50," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,119,50," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,121,50," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,123,50," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,125,50," ",1906,"Conquest::OnBarricade1";
+
+			bg_monster .Defender,.Castle$,115,153," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,117,153," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,119,153," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,121,153," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,123,153," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,125,153," ",1906,"Conquest::OnBarricade2";
+
+			bg_monster .Defender,.Castle$,116,240," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,118,240," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,120,240," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,122,240," ",1906,"Conquest::OnBarricade3";
+
+			bg_monster .Defender,.Castle$,27,35,"1st Guardian Stone",20400,"Conquest::OnGuardianStone1";
+			bg_monster .Defender,.Castle$,207,75,"2st Guardian Stone",20401,"Conquest::OnGuardianStone2";
+
+			bg_monster .Defender,.Castle$,120,272,"Emperium",20402,"Conquest::OnEmperium";
+			break;
+		case 1:
+			setwall .Castle$,290,98,8,0,0,"conq_RL00";
+			setwall .Castle$,279,98,8,0,1,"conq_RL01";
+			setwall .Castle$,230,213,6,0,1,"conq_RL02";
+			setwall .Castle$,160,141,6,6,1,"conq_RL03";
+
+			bg_monster .Defender,.Castle$,289,98," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,289,100," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,289,102," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,289,104," ",1906,"Conquest::OnBarricade0";
+
+			bg_monster .Defender,.Castle$,280,98," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,280,100," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,280,102," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,281,99," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,281,101," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,281,103," ",1906,"Conquest::OnBarricade1";
+
+			bg_monster .Defender,.Castle$,231,214," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,231,216," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,231,218," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,232,213," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,232,215," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,232,217," ",1906,"Conquest::OnBarricade2";
+
+			bg_monster .Defender,.Castle$,160,140," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,162,140," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,164,140," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,166,140," ",1906,"Conquest::OnBarricade3";
+
+			bg_monster .Defender,.Castle$,231,58,"1st Guardian Stone",20400,"Conquest::OnGuardianStone1";
+			bg_monster .Defender,.Castle$,335,230,"2nd Guardian Stone",20401,"Conquest::OnGuardianStone2";
+
+			bg_monster .Defender,.Castle$,162,193,"Emperium",20402,"Conquest::OnEmperium";
+			break;
+		case 2:
+			setwall .Castle$,326,301,6,6,0,"conq_RL00";
+			setwall .Castle$,325,277,8,6,1,"conq_RL01";
+			setwall .Castle$,200,230,8,0,1,"conq_RL02";
+			setwall .Castle$,285,198,8,0,1,"conq_RL03";
+
+			bg_monster .Defender,.Castle$,326,300," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,328,300," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,330,300," ",1906,"Conquest::OnBarricade0";
+
+			bg_monster .Defender,.Castle$,326,278," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,328,278," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,330,278," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,327,279," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,329,279," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,331,279," ",1906,"Conquest::OnBarricade1";
+
+			bg_monster .Defender,.Castle$,201,231," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,201,233," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,201,235," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,202,232," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,202,234," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,202,236," ",1906,"Conquest::OnBarricade2";
+
+			bg_monster .Defender,.Castle$,284,199," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,284,201," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,284,203," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,284,205," ",1906,"Conquest::OnBarricade3";
+
+			bg_monster .Defender,.Castle$,242,309,"1st Guardian Stone",20400,"Conquest::OnGuardianStone1";
+			bg_monster .Defender,.Castle$,376,251,"2nd Guardian Stone",20401,"Conquest::OnGuardianStone2";
+
+			bg_monster .Defender,.Castle$,338,202,"Emperium",20402,"Conquest::OnEmperium";
+			break;
+		case 3:
+			setwall .Castle$,238,74,8,6,0,"conq_RL00";
+			setwall .Castle$,239,53,8,6,1,"conq_RL01";
+			setwall .Castle$,107,124,6,6,1,"conq_RL02";
+			setwall .Castle$,84,171,8,6,1,"conq_RL03";
+
+			bg_monster .Defender,.Castle$,239,73," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,241,73," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,243,73," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,245,73," ",1906,"Conquest::OnBarricade0";
+
+			bg_monster .Defender,.Castle$,239,55," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,241,55," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,243,55," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,240,54," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,242,54," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,244,54," ",1906,"Conquest::OnBarricade1";
+
+			bg_monster .Defender,.Castle$,107,122," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,109,122," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,111,122," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,108,123," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,110,123," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,112,123," ",1906,"Conquest::OnBarricade2";
+
+			bg_monster .Defender,.Castle$,84,170," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,86,170," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,88,170," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,90,170," ",1906,"Conquest::OnBarricade3";
+
+			bg_monster .Defender,.Castle$,210,234,"1st Guardian Stone",20400,"Conquest::OnGuardianStone1";
+			bg_monster .Defender,.Castle$,308,189,"2nd Guardian Stone",20401,"Conquest::OnGuardianStone2";
+
+			bg_monster .Defender,.Castle$,87,219,"Emperium",20402,"Conquest::OnEmperium";
+			break;
+		case 4:
+			setwall .Castle$,136,136,8,6,0,"conq_RL00";
+			setwall .Castle$,150,223,12,6,1,"conq_RL01";
+			setwall .Castle$,125,342,8,0,1,"conq_RL02";
+			setwall .Castle$,38,314,12,6,1,"conq_RL03";
+
+			bg_monster .Defender,.Castle$,137,137," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,139,137," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,141,137," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,143,137," ",1906,"Conquest::OnBarricade0";
+
+			bg_monster .Defender,.Castle$,151,222," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,153,222," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,155,222," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,157,222," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,159,222," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,161,222," ",1906,"Conquest::OnBarricade1";
+
+			bg_monster .Defender,.Castle$,126,343," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,126,345," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,126,347," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,127,344," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,127,346," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,127,348," ",1906,"Conquest::OnBarricade2";
+
+			bg_monster .Defender,.Castle$,40,315," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,42,315," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,44,315," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,46,315," ",1906,"Conquest::OnBarricade3";
+
+			bg_monster .Defender,.Castle$,33,168,"1st Guardian Stone",20400,"Conquest::OnGuardianStone1";
+			bg_monster .Defender,.Castle$,245,168,"2nd Guardian Stone",20401,"Conquest::OnGuardianStone2";
+
+			bg_monster .Defender,.Castle$,89,256,"Emperium",20402,"Conquest::OnEmperium";
+			break;
+		case 5:
+			setwall .Castle$,138,110,8,6,0,"conq_RL00";
+			setwall .Castle$,139,158,6,6,1,"conq_RL01";
+			setwall .Castle$,138,210,8,6,1,"conq_RL02";
+			setwall .Castle$,138,263,8,6,1,"conq_RL03";
+
+			bg_monster .Defender,.Castle$,139,111," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,141,111," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,143,111," ",1906,"Conquest::OnBarricade0";
+			bg_monster .Defender,.Castle$,145,111," ",1906,"Conquest::OnBarricade0";
+
+			bg_monster .Defender,.Castle$,140,157," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,142,157," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,144,157," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,139,156," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,141,156," ",1906,"Conquest::OnBarricade1";
+			bg_monster .Defender,.Castle$,143,156," ",1906,"Conquest::OnBarricade1";
+
+			bg_monster .Defender,.Castle$,140,209," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,142,209," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,144,209," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,139,208," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,141,208," ",1906,"Conquest::OnBarricade2";
+			bg_monster .Defender,.Castle$,143,208," ",1906,"Conquest::OnBarricade2";
+
+			bg_monster .Defender,.Castle$,139,262," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,141,262," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,143,262," ",1906,"Conquest::OnBarricade3";
+			bg_monster .Defender,.Castle$,145,262," ",1906,"Conquest::OnBarricade3";
+
+			bg_monster .Defender,.Castle$,65,171,"1st Guardian Stone",20400,"Conquest::OnGuardianStone1";
+			bg_monster .Defender,.Castle$,212,149,"2nd Guardian Stone",20401,"Conquest::OnGuardianStone2";
+
+			bg_monster .Defender,.Castle$,141,293,"Emperium",20402,"Conquest::OnEmperium";
+			break;
+	}
+	set .Stone, 2;
+	set .Wall1, 6;
+	set .Wall2, 6;
+	set .Wall3, 4;
+	// ======================================
+	donpceventall("OnEmblemConquest");
+	sleep 2100;
+	bg_warp .Defender,.Castle$,.DX,.DY; // Flag Respawn - Emperium
+	bg_warp .Atacker,.Castle$,.AX,.AY; // Castle Entrance
+	sleep 4000;
+	mapannounce .Castle$,bg_get_data(.Atacker,3) + " : Move on warriors!! Let's capture this Castle!!",1,bg_get_data(.Atacker,4);
+	sleep 4000;
+	mapannounce .Castle$,bg_get_data(.Defender,3) + " : Protect the Castle and it's defenses to all cost!!",1,bg_get_data(.Defender,4);
+	end;
+
+OnGuardianStone1:
+	.Stone--;
+	.Score++;
+	if (playerattached())
+		bg_rankpoints(BGR_GSTONE,1,$@gstone_killed);
+	if (.Stone > 0) mapannounce .castle$,"1st Guardian Stone has fallen - 6 minutes to destroy the 2nd",1,0xFFA500;
+	donpcevent "Conquest::OnCheckGStone";
+	end;
+
+OnGuardianStone2:
+	.Stone--;
+	.Score++;
+	if (playerattached())
+		bg_rankpoints(BGR_GSTONE,1,$@gstone_killed);
+	if (.Stone > 0) mapannounce .castle$,"2nd Guardian Stone has fallen - 6 minutes to destroy the 1st",1,0xFFA500;
+	donpcevent "Conquest::OnCheckGStone";
+	end;
+
+OnCheckGStone:
+	initnpctimer;
+	if (.Stone < 1) {
+		mapannounce .castle$,"Both Guardian Stones has fallen - 6 minutes to destroy the 1st Fortress Gate",1,0xFFA500;
+		killmonster .castle$,"Conquest::OnBarricade0";
+		delwall "conq_RL00";
+	}
+	end;
+
+OnBarricade0:
+	end;
+
+OnBarricade1:
+	if (playerattached())
+		bg_rankpoints(BGR_BARRICADE,1,$@cq_barri);
+	if (set(.Wall1,.Wall1 - 1) < 1) {
+		initnpctimer; // Restart Timer
+		mapannounce .castle$,"1st Fortress Gate has fallen - 6 minutes to destroy the 2nd",1,0xFFA500;
+		set .Score, .Score + 1;
+		delwall "conq_RL01";
+	}
+	end;
+OnBarricade2:
+	if (playerattached())
+		bg_rankpoints(BGR_BARRICADE,1,$@cq_barri);
+	if (set(.Wall2,.Wall2 - 1) < 1) {
+		initnpctimer; // Restart Timer
+		mapannounce .castle$,"2nd Fortress Gate has fallen - 6 minutes to destroy the 3rd",1,0xFFA500;
+		set .Score, .Score + 1;
+		delwall "conq_RL02";
+	}
+	end;
+OnBarricade3:
+	if (playerattached())
+		bg_rankpoints(BGR_BARRICADE,1,$@cq_barri);
+	if (set(.Wall3,.Wall3 - 1) < 1) {
+		initnpctimer; // Restart Timer
+		mapannounce .castle$,"3rd Fortress Gate has fallen - 6 minutes to destroy the Emperium",1,0xFFA500;
+		set .Score, .Score + 1;
+		delwall "conq_RL03";
+	}
+	end;
+
+OnTimer60000:
+	mapannounce .castle$,"Battle of Conquest will ends in 5 minutes",1,0xFFA500;
+	end;
+
+OnTimer300000:
+	mapannounce .castle$,"Battle of Conquest will ends in 1 minute",1,0xFFA500;
+	end;
+
+OnEmperium:
+	set .Score, .Score + 1;
+	mapannounce .castle$,"The " + bg_get_data(.Atacker,2) + " army has won the Battle and captured the Castle!!",1,$@bcolor1;
+	donpcevent "Conquest::OnMatchEnd";
+	end;
+
+OnTimer360000:
+	mapannounce .castle$,"The " + bg_get_data(.Defender,2) + " army has won the Battle and protected the Castle!!",1,$@bcolor2;
+	donpcevent "Conquest::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	stopnpctimer "Conquest_Respawn";
+	killmonster .castle$,"Conquest::OnBarricade0";
+	killmonster .castle$,"Conquest::OnBarricade1";
+	killmonster .castle$,"Conquest::OnBarricade2";
+	killmonster .castle$,"Conquest::OnBarricade3";
+	killmonster .castle$,"Conquest::OnGuardianStone1";
+	killmonster .castle$,"Conquest::OnGuardianStone2";
+	killmonster .castle$,"Conquest::OnEmperium";
+	set $@BG_Status, 2;
+
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	.@Reward = .qty_los;
+	set .@Won,2;
+
+	if (.Score >= 6 ) { // Emperium Taken
+		.@Reward = .qty_win;
+		set .@Won,0;
+	}
+
+	bg_reward(.Atacker,.reward_id,.@Reward,0,0,"BG_CON",1,6,.@Won,.@Won?$@cq_los:$@cq_win);
+
+	set .Score, 6 - .Score; // Switch for Defender
+
+	.@Reward = .qty_los;
+	set .@Won,2;
+
+	// Emperium Defended
+	if (.Score >= 1) {
+		.@Reward = .qty_win;
+		set .@Won,0;
+	}
+
+	bg_reward(.defender,.reward_id,.@Reward,0,0,"BG_CON",1,6,.@Won,.@Won?$@cq_los:$@cq_win);
+	// =======================================================
+	set .Score, 0;
+	sleep 5000;
+	donpcevent "Conquest::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	end;
+
+OnEnd:
+	sleep 1000;
+	delwall "conq_RL00";
+	delwall "conq_RL01";
+	delwall "conq_RL02";
+	delwall "conq_RL03";
+	mapwarp .castle$,"bat_room",154,150;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+schg_cas06,260,383,5	script	Therapist in battle#cq1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+schg_cas06,299,383,3	script	Therapist in battle#cq2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+schg_cas07,86,315,5	script	Therapist in battle#cq3	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+schg_cas07,117,315,3	script	Therapist in battle#cq4	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+schg_cas08,23,50,6	script	Therapist in battle#cq5	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+schg_cas08,92,50,4	script	Therapist in battle#cq6	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+arug_cas06,26,385,5	script	Therapist in battle#cq7	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+arug_cas06,122,361,5	script	Therapist in battle#cq8	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+arug_cas07,304,342,3	script	Therapist in battle#cq9	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+arug_cas07,304,305,1	script	Therapist in battle#cq10	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+arug_cas08,310,154,6	script	Therapist in battle#cq11	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+arug_cas08,333,154,4	script	Therapist in battle#cq12	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+-	script	Conquest_Respawn	FAKE_NPC,{
+	end;
+
+OnStart:
+	initnpctimer;
+	.Index = getvariableofnpc(.Index,"Conquest");
+	.Castle$ = getvariableofnpc(.castle$,"Conquest");
+	.DX = getvariableofnpc(.DX,"Conquest");
+	.DY = getvariableofnpc(.DY,"Conquest");
+	.AX = getvariableofnpc(.AX,"Conquest");
+	.AY = getvariableofnpc(.AY,"Conquest");
+	.Therapist1$ = "Therapist in battle#cq"+((.Index*2)+1);
+	.Therapist2$ = "Therapist in battle#cq"+((.Index*2)+2);
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,.Therapist1$));
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,.Therapist2$));
+	if (.tick < 24) {
+		initnpctimer;
+		end;
+	}
+	if (.tick == 24) {
+		mapannounce .Castle$,"-- Reinforcements entering the Battle of Conquest --",1,0xFFA500;
+		specialeffect 83,AREA,.Therapist1$;
+		specialeffect 83,AREA,.Therapist2$;
+		initnpctimer;
+		end;
+	}
+
+	switch(.Index) {
+		case 0: // schg_cas01 ========================================================================
+			areapercentheal .Castle$,260,376,267,383,100,100;
+			areapercentheal .Castle$,292,376,299,383,100,100;
+			if ($@BG_Team1 == getvariableofnpc(.Defender,"Conquest")) {
+				areawarp .Castle$,260,376,267,383,.Castle$,.DX,.DY;
+				areawarp .Castle$,292,376,299,383,.Castle$,.AX,.AY;
+			} else {
+				areawarp .Castle$,260,376,267,383,.Castle$,.AX,.AY;
+				areawarp .Castle$,292,376,299,383,.Castle$,.DX,.DY;
+			}
+			break;
+		case 1: // schg_cas02 ========================================================================
+			areapercentheal .Castle$,80,301,92,321,100,100;
+			areapercentheal .Castle$,111,301,123,321,100,100;
+			if ($BG_Team1 == getvariableofnpc(.Defender,"Conquest")) {
+				areawarp .Castle$,80,301,92,321,.Castle$,.DX,.DY;
+				areawarp .Castle$,111,301,123,321,.Castle$,.AX,.AY;
+			} else {
+				areawarp .Castle$,80,301,92,321,.Castle$,.AX,.AY;
+				areawarp .Castle$,111,301,123,321,.Castle$,.DX,.DY;
+			}
+			break;
+		case 2: // schg_cas03 ========================================================================
+			areapercentheal .Castle$,18,44,33,55,100,100;
+			areapercentheal .Castle$,82,44,97,55,100,100;
+			if ($BG_Team1 == getvariableofnpc(.Defender,"Conquest")) {
+				areawarp .Castle$,18,44,33,55,.Castle$,.DX,.DY;
+				areawarp .Castle$,82,44,97,55,.Castle$,.AX,.AY;
+			} else {
+				areawarp .Castle$,18,44,33,55,.Castle$,.AX,.AY;
+				areawarp .Castle$,82,44,97,55,.Castle$,.DX,.DY;
+			}
+			break;
+		case 3: // arug_cas01 ========================================================================
+			areapercentheal .Castle$,26,378,33,385,100,100;
+			areapercentheal .Castle$,122,354,129,361,100,100;
+			if ($BG_Team1 == getvariableofnpc(.Defender,"Conquest")) {
+				areawarp .Castle$,26,378,33,385,.Castle$,.DX,.DY;
+				areawarp .Castle$,122,354,129,361,.Castle$,.AX,.AY;
+			} else {
+				areawarp .Castle$,26,378,33,385,.Castle$,.AX,.AY;
+				areawarp .Castle$,122,354,129,361,.Castle$,.DX,.DY;
+			}
+			break;
+		case 4: // arug_cas02 ========================================================================
+			areapercentheal .Castle$,291,336,304,342,100,100;
+			areapercentheal .Castle$,291,305,304,311,100,100;
+			if ($BG_Team1 == getvariableofnpc(.Defender,"Conquest")) {
+				areawarp .Castle$,291,336,304,342,.Castle$,.DX,.DY;
+				areawarp .Castle$,291,305,304,311,.Castle$,.AX,.AY;
+			} else {
+				areawarp .Castle$,291,336,304,342,.Castle$,.AX,.AY;
+				areawarp .Castle$,291,305,304,311,.Castle$,.DX,.DY;
+			}
+			break;
+		case 5: // arug_cas03 ========================================================================
+			areapercentheal .Castle$,310,150,316,157,100,100;
+			areapercentheal .Castle$,327,150,333,157,100,100;
+			if ($BG_Team1 == getvariableofnpc(.Defender,"Conquest")) {
+				areawarp .Castle$,310,150,316,157,.Castle$,.DX,.DY;
+				areawarp .Castle$,327,150,333,157,.Castle$,.AX,.AY;
+			} else {
+				areawarp .Castle$,310,150,316,157,.Castle$,.AX,.AY;
+				areawarp .Castle$,327,150,333,157,.Castle$,.DX,.DY;
+			}
+			break;
+	}
+
+	initnpctimer;
+	end;
+}
+
+// Flags schg_cas06
+// *********************************************************************
+
+schg_cas06,106,302,0	script	LF-01#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("First Gate House:Second Gate House:Cancel")) {
+			case 1:
+				warp "schg_cas06",19,26;
+				end;
+			case 2:
+				warp "schg_cas06",219,90;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,109,302,0	script	LF-02#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-1:Defense Area 1-2:Cancel")) {
+			case 1:
+				warp "schg_cas06",89,43;
+				end;
+			case 2:
+				warp "schg_cas06",141,45;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,112,302,0	script	LF-03#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-1:Defense Area 2-2:Cancel")) {
+			case 1:
+				warp "schg_cas06",137,54;
+				end;
+			case 2:
+				warp "schg_cas06",102,54;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,115,302,0	script	LF-04#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-3:Defense Area 2-4:Cancel")) {
+			case 1:
+				warp "schg_cas06",94,147;
+				end;
+			case 2:
+				warp "schg_cas06",163,140;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,118,302,0	script	LF-05#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-3:Defense Area 2-4:Cancel")) {
+			case 1:
+				warp "schg_cas06",87,220;
+				end;
+			case 2:
+				warp "schg_cas06",151,220;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,121,302,0	script	LF-06#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 3-1:Defense Area 3-2:Cancel")) {
+			case 1:
+				warp "schg_cas06",100,242;
+				end;
+			case 2:
+				warp "schg_cas06",136,242;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,124,302,0	script	LF-07#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Center 1 Area:Center 2 Area:Cancel")) {
+			case 1:
+				warp "schg_cas06",120,168;
+				end;
+			case 2:
+				warp "schg_cas06",119,211;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,127,302,0	script	LF-08#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 1-1:Area 2-1:Area 3-1:Cancel")) {
+			case 1:
+				warp "schg_cas06",89,43;
+				end;
+			case 2:
+				warp "schg_cas06",94,147;
+				end;
+			case 3:
+				warp "schg_cas06",100,242;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,130,302,0	script	LF-09#schg_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 1-2:Area 2-3:Area 3-2:Cancel")) {
+			case 1:
+				warp "schg_cas06",141,45;
+				end;
+			case 2:
+				warp "schg_cas06",163,140;
+				end;
+			case 3:
+				warp "schg_cas06",136,243;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas06,17,45,0	script	Castle#LF_sc06_1::LF_sc06_1	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Flag Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "schg_cas06",120,290;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+schg_cas06,207,95,0	duplicate(LF_sc06_1)	Castle#LF_sc06_2	HIDDEN_NPC
+schg_cas06,99,77,0	duplicate(LF_sc06_1)	Castle#LF_sc06_5	HIDDEN_NPC
+schg_cas06,140,77,0	duplicate(LF_sc06_1)	Castle#LF_sc06_6	HIDDEN_NPC
+schg_cas06,112,212,0	duplicate(LF_sc06_1)	Castle#LF_sc06_9	HIDDEN_NPC
+schg_cas06,127,212,0	duplicate(LF_sc06_1)	Castle#LF_sc06_10	HIDDEN_NPC
+schg_cas06,113,238,0	duplicate(LF_sc06_1)	Castle#LF_sc06_11	HIDDEN_NPC
+schg_cas06,126,238,0	duplicate(LF_sc06_1)	Castle#LF_sc06_12	HIDDEN_NPC
+schg_cas06,95,247,0	duplicate(LF_sc06_1)	Castle#LF_sc06_13	HIDDEN_NPC
+schg_cas06,144,247,0	duplicate(LF_sc06_1)	Castle#LF_sc06_14	HIDDEN_NPC
+
+schg_cas06,111,46,4	script	Castle#LF_sc06_3::LF_sc06_2	GUILD_FLAG,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Flag Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "schg_cas06",120,290;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+schg_cas06,129,46,4	duplicate(LF_sc06_2)	Castle#LF_sc06_4	GUILD_FLAG
+schg_cas06,109,150,4	duplicate(LF_sc06_2)	Castle#LF_sc06_7	GUILD_FLAG
+schg_cas06,130,150,4	duplicate(LF_sc06_2)	Castle#LF_sc06_8	GUILD_FLAG
+
+// Flags schg_cas07
+// *********************************************************************
+
+schg_cas07,143,198,0	script	LF-01#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("First Gate House:Second Gate House:Cancel")) {
+			case 1:
+				warp "schg_cas07",235,44;
+				end;
+			case 2:
+				warp "schg_cas07",302,233;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,143,202,0	script	LF-02#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense area 1-1:Defense area 1-2:Cancel")) {
+			case 1:
+				warp "schg_cas07",317,83;
+				end;
+			case 2:
+				warp "schg_cas07",359,83;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,143,206,0	script	LF-03#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense area 2-1:Defense area 2-2:Cancel")) {
+			case 1:
+				warp "schg_cas07",283,79;
+				end;
+			case 2:
+				warp "schg_cas07",280,122;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,145,208,0	script	LF-04#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense area 3-1:Defense area 3-2:Cancel")) {
+			case 1:
+				warp "schg_cas07",215,110;
+				end;
+			case 2:
+				warp "schg_cas07",255,215;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,180,208,0	script	LF-05#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Center 1 Area:Center 2 Area:Cancel")) {
+			case 1:
+				warp "schg_cas07",338,153;
+				end;
+			case 2:
+				warp "schg_cas07",213,226;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,182,206,0	script	LF-06#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense area 1-1:Defense area 2-1:Defense area 3-1:Cancel")) {
+			case 1:
+				warp "schg_cas07",317,83;
+				end;
+			case 2:
+				warp "schg_cas07",283,79;
+				end;
+			case 3:
+				warp "schg_cas07",215,110;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,182,202,0	script	LF-07#schg_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 1-2:Area 2-2:Area 3-2:Cancel")) {
+			case 1:
+				warp "schg_cas07",359,83;
+				end;
+			case 2:
+				warp "schg_cas07",280,122;
+				end;
+			case 3:
+				warp "schg_cas07",255,215;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas07,235,222,0	script	Andlangr#LF_sc07_1::LF_sc07_1	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "schg_cas07",136,188;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+schg_cas07,157,136,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_2	HIDDEN_NPC
+schg_cas07,168,136,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_3	HIDDEN_NPC
+schg_cas07,320,232,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_4	HIDDEN_NPC
+schg_cas07,295,109,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_5	HIDDEN_NPC
+schg_cas07,295,92,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_6	HIDDEN_NPC
+schg_cas07,285,90,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_7	HIDDEN_NPC
+schg_cas07,285,190,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_8	HIDDEN_NPC
+schg_cas07,238,66,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_9	HIDDEN_NPC
+schg_cas07,230,45,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_10	HIDDEN_NPC
+schg_cas07,233,120,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_11	HIDDEN_NPC
+schg_cas07,247,120,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_12	HIDDEN_NPC
+schg_cas07,261,162,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_13	HIDDEN_NPC
+schg_cas07,244,162,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_14	HIDDEN_NPC
+schg_cas07,235,207,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_15	HIDDEN_NPC
+
+// Flags schg_cas08
+// *********************************************************************
+
+schg_cas08,346,211,0	script	LF-01#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("First Gate House:Second Gate House:Cancel")) {
+			case 1:
+				warp "schg_cas08",262,323;
+				end;
+			case 2:
+				warp "schg_cas08",378,263;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,346,207,0	script	LF-02#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Center 1 Area:Cancel")) {
+			case 1:
+				warp "schg_cas08",306,320;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,346,203,0	script	LF-03#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense area 2-1:Defense area 2-2:Cancel")) {
+			case 1:
+				warp "schg_cas08",309,292;
+				end;
+			case 2:
+				warp "schg_cas08",348,292;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,346,199,0	script	LF-04#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Center 2 Area:Cancel")) {
+			case 1:
+				warp "schg_cas08",266,263;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,346,195,0	script	LF-05#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 3-1:Defense Area 3-2:Cancel")) {
+			case 1:
+				warp "schg_cas08",226,220;
+				end;
+			case 2:
+				warp "schg_cas08",185,249;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,346,191,0	script	LF-06#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Center 3 Area:Cancel")) {
+			case 1:
+				warp "schg_cas08",271,226;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,301,213,0	script	LF-07#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 1-2:Area 2-2:Area 3-2:Cancel")) {
+			case 1:
+				warp "schg_cas08",262,323;
+				end;
+			case 2:
+				warp "schg_cas08",378,263;
+				end;
+			case 3:
+				warp "schg_cas08",306,320;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,301,209,0	script	LF-08#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 2-1:Area 2-2:Center 2 Area:Cancel")) {
+			case 1:
+				warp "schg_cas08",309,292;
+				end;
+			case 2:
+				warp "schg_cas08",348,292;
+				end;
+			case 3:
+				warp "schg_cas08",326,263;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,301,194,0	script	LF-09#schg_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 3-1:Area 3-2:Center 3 Area:Cancel")) {
+			case 1:
+				warp "schg_cas08",226,220;
+				end;
+			case 2:
+				warp "schg_cas08",185,249;
+				end;
+			case 3:
+				warp "schg_cas08",271,226;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+schg_cas08,335,305,0	script	Vidblainn#LF_sc08_1::LF_sc08_1	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "schg_cas08",308,202;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+schg_cas08,322,305,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_2	HIDDEN_NPC
+schg_cas08,352,248,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_3	HIDDEN_NPC
+schg_cas08,320,283,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_4	HIDDEN_NPC
+schg_cas08,337,283,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_5	HIDDEN_NPC
+schg_cas08,233,320,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_6	HIDDEN_NPC
+schg_cas08,207,239,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_7	HIDDEN_NPC
+schg_cas08,207,228,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_8	HIDDEN_NPC
+schg_cas08,266,206,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_9	HIDDEN_NPC
+schg_cas08,266,197,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_10	HIDDEN_NPC
+
+schg_cas08,283,206,2	script	Vidblainn#LF_sc08_11::LF_sc08_2	GUILD_FLAG,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "schg_cas08",308,202;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+schg_cas08,283,197,2	duplicate(LF_sc08_2)	Vidblainn#LF_sc08_12	GUILD_FLAG
+schg_cas08,332,323,6	duplicate(LF_sc08_2)	Vidblainn#LF_sc08_13	GUILD_FLAG
+schg_cas08,343,323,2	duplicate(LF_sc08_2)	Vidblainn#LF_sc08_14	GUILD_FLAG
+
+// Flags arug_cas06
+// *********************************************************************
+
+arug_cas06,74,232,0	script	LF-01#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("First Gate House:Second Gate House:Cancel")) {
+			case 1:
+				warp "arug_cas06",158,237;
+				end;
+			case 2:
+				warp "arug_cas06",297,248;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,77,232,0	script	LF-02#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-1:Defense Area 1-2:Cancel")) {
+			case 1:
+				warp "arug_cas06",197,144;
+				end;
+			case 2:
+				warp "arug_cas06",245,103;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,80,232,0	script	LF-03#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-1:Defense Area 2-2:Cancel")) {
+			case 1:
+				warp "arug_cas06",256,35;
+				end;
+			case 2:
+				warp "arug_cas06",186,26;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,83,232,0	script	LF-04#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-3:Defense Area 2-4:Cancel")) {
+			case 1:
+				warp "arug_cas06",146,65;
+				end;
+			case 2:
+				warp "arug_cas06",176,111;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,86,232,0	script	LF-05#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 3-1:Defense Area 3-2:Cancel")) {
+			case 1:
+				warp "arug_cas06",94,126;
+				end;
+			case 2:
+				warp "arug_cas06",126,126;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,89,232,0	script	LF-06#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 3-3:Defense Area 3-4:Cancel")) {
+			case 1:
+				warp "arug_cas06",68,171;
+				end;
+			case 2:
+				warp "arug_cas06",105,182;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,92,232,0	script	LF-07#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Gate House Fork:Cancel")) {
+			case 1:
+				warp "arug_cas06",233,130;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,95,232,0	script	LF-08#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 1-1:Area 2-1:Area 3-1:Cancel")) {
+			case 1:
+				warp "arug_cas06",197,144;
+				end;
+			case 2:
+				warp "arug_cas06",256,35;
+				end;
+			case 3:
+				warp "arug_cas06",146,65;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,98,232,0	script	LF-09#arug_cas06	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Area 1-2:Area 2-2:Area 3-3:Cancel")) {
+			case 1:
+				warp "arug_cas06",245,103;
+				end;
+			case 2:
+				warp "arug_cas06",186,26;
+				end;
+			case 3:
+				warp "arug_cas06",68,171;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas06,72,176,0	script	Mardol#LF_ar06_1::LF_ar06_1	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "arug_cas06",67,193;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+arug_cas06,103,186,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_2	HIDDEN_NPC,{
+arug_cas06,150,102,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_4	HIDDEN_NPC
+arug_cas06,208,68,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_5	HIDDEN_NPC
+arug_cas06,249,52,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_6	HIDDEN_NPC
+arug_cas06,234,76,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_7	HIDDEN_NPC
+arug_cas06,249,76,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_8	HIDDEN_NPC
+arug_cas06,204,142,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_9	HIDDEN_NPC
+arug_cas06,183,244,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_10	HIDDEN_NPC
+arug_cas06,292,219,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_11	HIDDEN_NPC
+
+arug_cas06,92,126,4	script	Mardol#LF_ar06_3::LF_ar06_2	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "arug_cas06",67,193;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+arug_cas06,127,126,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_3	HIDDEN_NPC
+arug_cas06,102,120,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_12	GUILD_FLAG
+arug_cas06,117,120,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_13	GUILD_FLAG
+arug_cas06,233,140,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_14	GUILD_FLAG
+
+// Flags arug_cas07
+// *********************************************************************
+
+arug_cas07,98,270,0	script	LF-01#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("First Gate House:Second Gate House:Cancel")) {
+			case 1:
+				warp "arug_cas07",10,187;
+				end;
+			case 2:
+				warp "arug_cas07",268,187;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,98,266,0	script	LF-02#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-1:Defense Area 1-2:Cancel")) {
+			case 1:
+				warp "arug_cas07",66,31;
+				end;
+			case 2:
+				warp "arug_cas07",212,31;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,98,262,0	script	LF-03#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-3:Defense Area 1-4:Cancel")) {
+			case 1:
+				warp "arug_cas07",90,120;
+				end;
+			case 2:
+				warp "arug_cas07",188,119;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,98,258,0	script	LF-04#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-1:Defense Area 2-2:Cancel")) {
+			case 1:
+				warp "arug_cas07",119,183;
+				end;
+			case 2:
+				warp "arug_cas07",159,183;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,98,253,0	script	LF-05#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-3:Defense Area 2-4:Cancel")) {
+			case 1:
+				warp "arug_cas07",156,324;
+				end;
+			case 2:
+				warp "arug_cas07",174,372;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,98,249,0	script	LF-06#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 3-1:Defense Area 3-2:Cancel")) {
+			case 1:
+				warp "arug_cas07",28,325;
+				end;
+			case 2:
+				warp "arug_cas07",57,325;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,98,245,0	script	LF-07#arug_cas07	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Center 2nd Area:Center 3rd Area:Cancel")) {
+			case 1:
+				warp "arug_cas07",156,263;
+				end;
+			case 2:
+				warp "arug_cas07",43,354;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas07,216,92,0	script	Cyr#LF_ar07_1::LF_ar07_1	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "arug_cas07",43,256;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+arug_cas07,63,92,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_2	HIDDEN_NPC
+arug_cas07,127,133,4	duplicate(LF_ar07_1)	Cyr#LF_ar07_3	HIDDEN_NPC
+arug_cas07,152,133,4	duplicate(LF_ar07_1)	Cyr#LF_ar07_4	HIDDEN_NPC
+arug_cas07,149,218,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_5	HIDDEN_NPC
+arug_cas07,162,218,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_6	HIDDEN_NPC
+arug_cas07,128,350,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_7	HIDDEN_NPC
+arug_cas07,128,341,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_8	HIDDEN_NPC
+arug_cas07,49,317,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_9	HIDDEN_NPC
+arug_cas07,30,317,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_10	HIDDEN_NPC
+arug_cas07,9,190,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_11	HIDDEN_NPC
+arug_cas07,271,190,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_12	HIDDEN_NPC
+
+arug_cas07,129,178,4	script	Cyr#LF_ar07_13::LF_ar07_2	GUILD_FLAG,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "arug_cas07",43,256;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+arug_cas07,149,178,4	duplicate(LF_ar07_2)	Cyr#LF_ar07_14	GUILD_FLAG
+arug_cas07,132,38,4	duplicate(LF_ar07_2)	Cyr#LF_ar07_15	GUILD_FLAG
+arug_cas07,147,38,4	duplicate(LF_ar07_2)	Cyr#LF_ar07_16	GUILD_FLAG
+
+// Flags arug_cas08
+// *********************************************************************
+
+arug_cas08,122,314,0	script	LF-01#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("First Gate House:Second Gate House:Cancel")) {
+			case 1:
+				warp "arug_cas08",84,158;
+				end;
+			case 2:
+				warp "arug_cas08",197,136;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,125,314,0	script	LF-02#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-1:Defense Area 1-2:Cancel")) {
+			case 1:
+				warp "arug_cas08",65,94;
+				end;
+			case 2:
+				warp "arug_cas08",211,97;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,128,314,0	script	LF-03#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-3:Defense Area 1-4:Cancel")) {
+			case 1:
+				warp "arug_cas08",112,73;
+				end;
+			case 2:
+				warp "arug_cas08",171,73;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,131,314,0	script	LF-04#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-1:Defense Area 2-2:Cancel")) {
+			case 1:
+				warp "arug_cas08",112,152;
+				end;
+			case 2:
+				warp "arug_cas08",172,152;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,134,314,0	script	LF-05#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 2-3:Defense Area 2-4:Cancel")) {
+			case 1:
+				warp "arug_cas08",120,186;
+				end;
+			case 2:
+				warp "arug_cas08",162,186;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,149,314,0	script	LF-06#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 3-1:Defense Area 3-2:Cancel")) {
+			case 1:
+				warp "arug_cas08",116,235;
+				end;
+			case 2:
+				warp "arug_cas08",164,235;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,152,314,0	script	LF-07#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-1:Defense Area 2-1:Defense Area 3-1:Cancel")) {
+			case 1:
+				warp "arug_cas08",65,94;
+				end;
+			case 2:
+				warp "arug_cas08",112,152;
+				end;
+			case 3:
+				warp "arug_cas08",116,235;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,155,314,0	script	LF-08#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-2:Defense Area 2-2:Defense Area 3-2:Cancel")) {
+			case 1:
+				warp "arug_cas08",211,97;
+				end;
+			case 2:
+				warp "arug_cas08",172,152;
+				end;
+			case 3:
+				warp "arug_cas08",164,235;
+				end;
+			case 4:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,158,314,0	script	LF-09#arug_cas08	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch(select("Defense Area 1-4:Defense Area 2-4:Cancel")) {
+			case 1:
+				warp "arug_cas08",171,73;
+				end;
+			case 2:
+				warp "arug_cas08",162,186;
+				end;
+			case 3:
+				close;
+		}
+	}
+	end;
+}
+
+arug_cas08,45,158,0	script	Horn#LF_ar08_01::LF_ar08_01	HIDDEN_NPC,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "arug_cas08",121,318;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+arug_cas08,226,156,0	duplicate(LF_ar08_01)	Horn#LF_ar08_01	HIDDEN_NPC
+arug_cas08,134,62,4	duplicate(LF_ar08_01)	Horn#LF_ar08_02	HIDDEN_NPC
+arug_cas08,149,62,4	duplicate(LF_ar08_01)	Horn#LF_ar08_03	HIDDEN_NPC
+arug_cas08,123,154,0	duplicate(LF_ar08_01)	Horn#LF_ar08_04	HIDDEN_NPC
+arug_cas08,160,154,0	duplicate(LF_ar08_01)	Horn#LF_ar08_05	HIDDEN_NPC
+arug_cas08,135,205,0	duplicate(LF_ar08_01)	Horn#LF_ar08_06	HIDDEN_NPC
+arug_cas08,148,205,0	duplicate(LF_ar08_01)	Horn#LF_ar08_07	HIDDEN_NPC
+arug_cas08,134,260,0	duplicate(LF_ar08_01)	Horn#LF_ar08_08	HIDDEN_NPC
+
+arug_cas08,148,103,4	script	Horn#LF_ar08_10::LF_ar08_02	GUILD_FLAG,{
+	if (getcharid(4) == getvariableofnpc(.Defender,"Conquest")) {
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch(select("Teleport:Cancel")) {
+			case 1:
+				warp "arug_cas08",121,318;
+				end;
+			case 2:
+				close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	bg_flagemblem(getvariableofnpc(.Defender,"Conquest"));
+	end;
+}
+
+arug_cas08,135,103,4	duplicate(LF_ar08_02)	Horn#LF_ar08_11	GUILD_FLAG
+arug_cas08,63,51,7	duplicate(LF_ar08_02)	Horn#LF_ar08_12	GUILD_FLAG
+arug_cas08,214,51,1	duplicate(LF_ar08_02)	Horn#LF_ar08_13	GUILD_FLAG
+
+// MapFlags
+// *********************************************************************
+
+schg_cas06	mapflag	battleground
+schg_cas06	mapflag	nomemo
+schg_cas06	mapflag	nosave	SavePoint
+schg_cas06	mapflag	noteleport
+schg_cas06	mapflag	nowarp
+schg_cas06	mapflag	nowarpto
+schg_cas06	mapflag	noreturn
+schg_cas06	mapflag	nobranch
+schg_cas06	mapflag	nopenalty
+schg_cas06	mapflag	bg_consume
+arug_cas06	mapflag	novending
+
+schg_cas07	mapflag	battleground
+schg_cas07	mapflag	nomemo
+schg_cas07	mapflag	nosave	SavePoint
+schg_cas07	mapflag	noteleport
+schg_cas07	mapflag	nowarp
+schg_cas07	mapflag	nowarpto
+schg_cas07	mapflag	noreturn
+schg_cas07	mapflag	nobranch
+schg_cas07	mapflag	nopenalty
+schg_cas07	mapflag	bg_consume
+arug_cas06	mapflag	novending
+
+schg_cas08	mapflag	battleground
+schg_cas08	mapflag	nomemo
+schg_cas08	mapflag	nosave	SavePoint
+schg_cas08	mapflag	noteleport
+schg_cas08	mapflag	nowarp
+schg_cas08	mapflag	nowarpto
+schg_cas08	mapflag	noreturn
+schg_cas08	mapflag	nobranch
+schg_cas08	mapflag	nopenalty
+schg_cas08	mapflag	bg_consume
+arug_cas06	mapflag	novending
+
+arug_cas06	mapflag	battleground
+arug_cas06	mapflag	nomemo
+arug_cas06	mapflag	nosave	SavePoint
+arug_cas06	mapflag	noteleport
+arug_cas06	mapflag	nowarp
+arug_cas06	mapflag	nowarpto
+arug_cas06	mapflag	noreturn
+arug_cas06	mapflag	nobranch
+arug_cas06	mapflag	nopenalty
+arug_cas06	mapflag	bg_consume
+arug_cas06	mapflag	novending
+
+arug_cas07	mapflag	battleground
+arug_cas07	mapflag	nomemo
+arug_cas07	mapflag	nosave	SavePoint
+arug_cas07	mapflag	noteleport
+arug_cas07	mapflag	nowarp
+arug_cas07	mapflag	nowarpto
+arug_cas07	mapflag	noreturn
+arug_cas07	mapflag	nobranch
+arug_cas07	mapflag	nopenalty
+arug_cas07	mapflag	bg_consume
+arug_cas06	mapflag	novending
+
+arug_cas08	mapflag	battleground
+arug_cas08	mapflag	nomemo
+arug_cas08	mapflag	nosave	SavePoint
+arug_cas08	mapflag	noteleport
+arug_cas08	mapflag	nowarp
+arug_cas08	mapflag	nowarpto
+arug_cas08	mapflag	noreturn
+arug_cas08	mapflag	nobranch
+arug_cas08	mapflag	nopenalty
+arug_cas08	mapflag	bg_consume
+arug_cas06	mapflag	novending
\ No newline at end of file
diff --git a/npc/custom/eBG/bg_core.txt b/npc/custom/eBG/bg_core.txt
new file mode 100644
index 0000000..504f6b1
--- /dev/null
+++ b/npc/custom/eBG/bg_core.txt
@@ -0,0 +1,260 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  30-01-2023
+// By:
+//  Easycore
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//============================================================
+
+// Battleground Core Script
+-	script	BG_Core	-1,{
+	end;
+
+OnInit:
+	//Battleground Index
+	$@BG_Index = -1;
+	//Battleground Status
+	$@BG_Status = 0;
+	//Battleground Arena Names
+	deletearray $@BG_Names$[0],10;
+	//Battleground Sript Handler Names
+	// Comment // to disable a game mode
+	setarray $@BG_Names$[0],
+				"Conquest",    "6",
+				"Flavius_CTF", "7",
+				"Flavius_SC",  "8",
+				"Flavius_TD",  "9",
+				"Tierra_Boss","10",
+				"Rush",       "11",
+				"Tierra_DOM", "12",
+				"Tierra_TI",  "13";
+	//Battleground Message Colors
+	setarray $@BG_Color$[0],"0xA0522D","0x808000","0xFFA500","0xDDA0DD","0x9ACD32","0x4169E1","0x3399FF","0xDC143C","0x9ACD32";
+	///**********************************
+	// Battleground Rank Points - Fame
+	///**********************************
+	// Double Inferno
+	$@skulls =				1;	// Skulls sacrice
+	$@ti_win =				25;	// Victory
+	$@ti_los =				5;	// Defeat
+	$@ti_tie =				10;	// Draw
+	// Stone Control
+	$@sc_stole =			1;	// Stone Stolen
+	$@sc_captured =			5;	// Stone Captured
+	$@sc_win =				25;	// Victory
+	$@sc_los =				5;	// Defeat
+	$@sc_tie =				10;	// Draw
+	// Team DeathMatch
+	$@td_kill =				1;	// Kills
+	$@td_win =				25;	// Victory
+	$@td_los =				5;	// Defeat
+	$@td_tie =				10;	// Draw
+	// Capture the Flag
+	$@ctf_taken =			1;	// Flag picked up
+	$@ctf_captured =		25;	// Flag captured
+	$@ctf_win =				25;	// Victory
+	$@ctf_los =				5;	// Defeat
+	$@ctf_tie =				10;	// Draw
+	// Domination
+	$@dom_bases =			10;	// Base Captured
+	$@dom_off_kill =		1;	// Offensive Kills
+	$@dom_def_kill =		1;	// Defensive Kills
+	$@dom_win =				25;	// Victory
+	$@dom_los =				5;	// Defeat
+	$@dom_tie =				10;	// Draw
+	// Bossnia
+	$@flag_boss =			3;	// Control flag killed
+	$@boss_killed =			15;	// Boss killed
+	$@boss_win =			25;	// Victory
+	$@boss_los =			5;	// Defeat
+	$@boss_tie =			10;	// Draw
+	// Conquest
+	$@gstone_killed =		5;	// Guardian Stone killed
+	$@cq_barri =			1;	// Barricade killed
+	$@cq_win =				10;	// Victory
+	$@cq_los =				5;	// Defeat
+	// Rush
+	$@ru_capture =			10;	// Emperium captured
+	$@ru_win =				25;	// Victory
+	$@ru_los =				5;	// Defeat
+	$@ru_tie =				10;	// Draw
+	// Conquest & Rush
+	$@bg_emp =				25;	// Emperium Broken
+	///**********************************
+	//Battlegrounds Happy Hour
+	.HappyHour = 1;			// (0: disabled | 1: enabled)
+	.HappyHourRates = 20;	// Extra reward rates
+	.BGRewardRates = getbattleflag("bg_reward_rates");
+
+	set .BG_Count, getarraysize($@BG_Names$)/2;
+
+	bindatcmd "joinbg",strnpcinfo(3) + "::OnDoJoin";
+	bindatcmd "rotate",strnpcinfo(3) + "::OnRotate",2,2;
+	bindatcmd "bgstop",strnpcinfo(3) + "::OnBGStop",99,99;
+	bindatcmd "bgsize",strnpcinfo(3) + "::OnBGSize",99,99;
+	bindatcmd "bghappyhour",strnpcinfo(3) + "::OnBGHHCommand",99,99;
+
+	initnpctimer;
+	donpcevent "BG_Core::OnEnd";
+	end;
+
+OnRotateFinished:
+	.@notransfer = 1;
+/// @rotate
+OnTimer120000:
+OnRotate:
+	if ($@BG_Status)
+		end;
+	if ($@BG_Id)
+		$@BG_O_Name$ = bg_queue_info($@BG_Id,0);	// Store Old Arena Name
+	if (($@BG_Index++) >= .BG_Count-1)
+		$@BG_Index = 0;								// Restart Rotation
+	$@BG_Id = atoi($@BG_Names$[($@BG_Index*2)+1]);	// Store new BG_ID
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];	// Store new Script Name
+	$@BG_C_Name$ = bg_queue_info($@BG_Id,0);		// Store new Arena Name
+	.@required = ((bg_queue_info($@BG_Id,1)*2)-bg_queue_info($@BG_Id,3));
+	if ($@BG_O_Name$ != "" && !.@notransfer)
+		bg_queue_transfer_all($@BG_O_Name$,$@BG_C_Name$);
+	if (getbattleflag("feature.bgqueue"))
+		bg_announce "Battleground -- " + $@BG_C_Name$ + " - "+ .@required +" more players to start.",$@BG_Color$[$@BG_Index];
+	initnpctimer;
+	end;
+
+/// @bgstop
+OnBGStop:
+	if ($@BG_Status == 1)
+		donpcevent $@BG_Current$+"::OnMatchEnd";
+	end;
+
+/// @joinbg
+OnDoJoin:
+	if (.@atcmd_numparameters != 1 || set(.@x, atoi(.@atcmd_parameters$[0])) > 2) {
+		message(strcharinfo(0),"Usage: @joinbg <mode>");
+		message(strcharinfo(0),"modes: 0: Solo Join");
+		message(strcharinfo(0),"               1: Party Join");
+		message(strcharinfo(0),"               2: Guild Join");
+		message(strcharinfo(0),"@joinbg failed");
+		end;
+	}
+OnDoJoinSolo:
+	if (!getbattleflag("feature.bgqueue")) {
+		message(strcharinfo(0),"-- Battleground is currently disabled --");
+		end;
+	}
+	if (getcharqueue() != -1) {
+		bg_queue_show(); //Already in Queue
+		end;
+	}
+	switch(.@x) {
+		default:
+		case 0: bg_queue_join($@BG_C_Name$,0); break;
+		case 1: bg_queue_join($@BG_C_Name$,1); break;
+		case 2: bg_queue_join($@BG_C_Name$,2); break;
+	}
+	if (getcharqueue() != -1)
+		donpcevent "BG_Core::OnJoinQueue";
+	end;
+
+/// @bgsize <1-10> <min>
+OnBGSize:
+	.@x = atoi(.@atcmd_parameters$[0]);
+	.@x2 = atoi(.@atcmd_parameters$[1]);
+	if (.@x2 < 1) {
+		message strcharinfo(0), "Usage: @bgsize <0-"+.BG_Count+"> <min players> <max players>";
+		dispbottom "#0 - All Arenas",0xFFFFFF;
+		for(.@i = 0; .@i < .BG_Count; .@i++)
+			announce "#"+(.@i+1)+" - "+bg_queue_info(atoi($@BG_Names$[(.@i*2)+1]),0),bc_self,$@BG_Color$[.@i];
+		end;
+	}
+	if (.@x <= .BG_Count) {
+		bg_set_data(atoi($@BG_Names$[((.@x-1)*2)+1]),0,.@x2,0);
+		message strcharinfo(0),"["+bg_queue_info(atoi($@BG_Names$[((.@x-1)*2)+1]),0)+"] min players is now <"+.@x2+">.";
+	} else {
+		for(.@i = 0; .@i < .BG_Count; .@i++)
+			bg_set_data(atoi($@BG_Names$[(.@i*2)+1]),0,.@x2/2,0);
+		message strcharinfo(0),"[All Arenas] min players is now <"+.@x2+">.";
+	}
+	end;
+
+/// @bghappyhour
+OnBGHHCommand:
+	if (.HappyHour == 0) {
+		message strcharinfo(0),"Happy Hour is currently disabled.";
+		end;
+	}
+	if (getbattleflag("feature.bgqueue") == 0) {
+		message strcharinfo(0),"Battlegrounds are currently disabled.";
+		end;
+	}
+	if (!.HWE)
+		donpcevent "BG_Core::OnDoHappyHour";
+	else
+		donpcevent "BG_Core::OnEndHappyHour";
+	end;
+/// Queue setup join
+OnJoinQueue:
+	if ($@BG_Team1 || $@BG_Team2)
+		end;
+	.@required = ((bg_queue_info($@BG_Id,1)*2)-bg_queue_info($@BG_Id,3));
+	if (.@required)
+		bg_announce "Battleground -- " + $@BG_C_Name$ + " -- "+ .@required +" more players to start.",$@BG_Color$[$@BG_Index];
+	end;
+/// Active game join
+OnJoinActive:
+	.@BG_Count1 = bg_get_data($@BG_Team1,0);
+	.@BG_Count2 = bg_get_data($@BG_Team2,0);
+	.@BG_Max =    bg_queue_info($@BG_Id,2);
+	.@msg$ = "Battleground -- "+ $@BG_C_Name$ +" -- B: "+ .@BG_Count1+"/"+ .@BG_Max +", R: "+.@BG_Count2+"/"+ .@BG_Max +" (Playing)";
+	bg_announce .@msg$,$@BG_Color$[$@BG_Index];
+	end;
+/// Ends arena
+OnEnd:
+	sleep 100;
+	$@BG_Status = 0;
+	if ($@BG_Id) bg_queue_finish($@BG_Id);
+	if ($@BG_Team1) { bg_team_leave $@BG_Team1; bg_destroy $@BG_Team1; $@BG_Team1 = 0; }
+	if ($@BG_Team2) { bg_team_leave $@BG_Team2; bg_destroy $@BG_Team2; $@BG_Team2 = 0; }
+	donpcevent "BG_Core::OnRotateFinished";
+	end;
+/// Battleground Happy Hour
+OnDoHappyHour:
+OnClock1600:
+OnClock2000:
+	if (getbattleflag("feature.bgqueue") == 0 || .HappyHour == 0) end;
+	.HWE = 1;
+	bg_announce "-- Battleground Happy Hour has begun --","0x1E90FF";
+	setbattleflag "bg_reward_rates",getbattleflag("bg_reward_rates")+.HappyHourRates; // +20% Reward Rates
+	end;
+OnEndHappyHour:
+OnClock1800:
+OnClock2200:
+	if (getbattleflag("feature.bgqueue") == 0 || .HappyHour == 0) end;
+	.HWE = 0;
+	bg_announce "-- Battleground Happy Hour is over --","0xEEE8AA";
+	setbattleflag "bg_reward_rates",.BGRewardRates; // Normal Rates
+	end;
+}
+
+function	script	F_EndSpeedBG	{
+	sc_end SC_HIDING;
+	sc_end SC_CLOAKING;
+	sc_end SC_CHASEWALK;
+	// Renewal invisibility
+	sc_end SC_CLOAKINGEXCEED;
+	sc_end SC_CAMOUFLAGE;
+	sc_end SC__INVISIBILITY;
+	sc_end SC_SPEEDUP0;
+	//sc_end SC_SPEEDUP1;
+	sc_end SC_SPEED;
+	sc_end SC_INCREASEAGI;
+	sc_end SC_BERSERK;
+	sc_end SC_WINDWALK;
+	sc_end SC_AVOID;
+	return 0;
+}
diff --git a/npc/custom/eBG/bg_flavius_ctf.txt b/npc/custom/eBG/bg_flavius_ctf.txt
new file mode 100644
index 0000000..fa5b234
--- /dev/null
+++ b/npc/custom/eBG/bg_flavius_ctf.txt
@@ -0,0 +1,510 @@
+//===== rAthena Script =======================================
+//    Extended BattleGround
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  31-05-2023
+// By:
+//  JinYuichi
+//
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Flavius Capture the Flag
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Flavius_CTF	FAKE_NPC,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	.qty_tie = 10;					// Reward amount for draw
+	.condition = 2;					// How much score for win condition
+	// ===========
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+	end;
+
+OnAlphaFlash:
+	if (getvariableofnpc(.Flag_Carrier,"Team1_Flag") == getcharid(0) && $@BG_Status == 1 && $@BG_Current$ == "Flavius_CTF") {
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		viewpointmap "bat_b02",1, .@x, .@y, 1, 0x0000FF;
+		specialeffect 73;
+		emotion ET_HELP,getcharid(3);
+		addtimer 2100, "Flavius_CTF::OnAlphaFlash";
+		percentheal -5,-5;
+	}
+	end;
+
+OnOmegaFlash:
+	if (getvariableofnpc(.Flag_Carrier,"Team2_Flag") == getcharid(0) && $@BG_Status == 1 && $@BG_Current$ == "Flavius_CTF") {
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		viewpointmap "bat_b02",1, .@x, .@y, 2, 0xFF0000;
+		specialeffect 73;
+		emotion ET_HELP,getcharid(3);
+		addtimer 2100, "Flavius_CTF::OnOmegaFlash";
+		percentheal -5,-5;
+	}
+	end;
+
+OnTeam1Active:
+	warp "bat_b02",228,39;
+	donpcevent "BG_Core::OnJoinActive";
+	end;
+OnTeam2Active:
+	warp "bat_b02",30,38;
+	donpcevent "BG_Core::OnJoinActive";
+	end;
+
+OnTeam1Quit:
+	bg_desert;
+OnTeam1Die:
+	// Drop Flag
+	if ($@BG_Status == 1 && $@BG_Current$ == "Flavius_CTF" && getvariableofnpc(.Flag_Carrier,"Team2_Flag") == getcharid(0)) {
+		set getvariableofnpc(.Flag_Carrier,"Team2_Flag"), 0;
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Team2_Flag", .@x, .@y;
+		mapannounce "bat_b02","Omega Flag Droped by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_CTF_DROPPED,1,0);
+		if (killedrid != getcharid(3))
+			bg_rankpoints(BGR_FAME,0,1,killerrid);
+		set getvariableofnpc(.Flag_Status,"Team2_Flag"), 1; // OnFloor
+		initnpctimer "Team2_Flag";
+		enablenpc "Team2_Flag";
+	}
+	end;
+
+OnTeam2Quit:
+	bg_desert;
+OnTeam2Die:
+	// Drop Flag
+	if ($@BG_Status == 1 && $@BG_Current$ == "Flavius_CTF" && getvariableofnpc(.Flag_Carrier,"Team1_Flag") == getcharid(0)) {
+		set getvariableofnpc(.Flag_Carrier,"Team1_Flag"), 0;
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Team1_Flag", .@x, .@y;
+		mapannounce "bat_b02","Alpha Flag Droped by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_CTF_DROPPED,1,0);
+		if (killedrid != getcharid(3))
+			bg_rankpoints(BGR_FAME,0,1,killerrid);
+		set getvariableofnpc(.Flag_Status,"Team1_Flag"), 1; // OnFloor
+		initnpctimer "Team1_Flag";
+		enablenpc "Team1_Flag";
+	}
+	end;
+
+OnStart:
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+	initnpctimer;
+	// BG Variables
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 2100;
+	bg_warp($@BG_Team1,"bat_b02",311,224);
+	bg_warp($@BG_Team2,"bat_b02",87,75);
+	sleep 2100;
+	// Respawn NPC's
+	donpcevent "#guictf_respawn::OnBGStart";
+	donpcevent "#croctf_respawn::OnBGStart";
+	// Start Match!!
+	donpcevent "Flavius_CTF::OnMatchStart";
+	end;
+
+OnMatchStart:
+	// Reset Position Members
+	if (.Team1_Score || .Team2_Score) {
+		bg_warp $@BG_Team1,"bat_b02",311,224;
+		bg_warp $@BG_Team2,"bat_b02",87,75;
+
+		bg_percentheal($@BG_Team1,100,100);
+		bg_emotion(ET_GO,$@BG_Team1);
+
+		bg_percentheal($@BG_Team2,100,100);
+		bg_emotion(ET_GO,$@BG_Team2);
+
+		if (.Team1_Score || .Team2_Score) {
+			bg_clear_buffs($@BG_Team1,SCCB_BUFFS|SCCB_DEBUFFS);
+			bg_clear_buffs($@BG_Team2,SCCB_BUFFS|SCCB_DEBUFFS);
+		}
+	}
+
+	// Flags2Base
+	donpcevent "Team1_Flag::OnBase";
+	donpcevent "Team2_Flag::OnBase";
+	mapannounce "bat_b02","The Flags have been set to their Bases!!",bc_map;
+	end;
+
+OnTeam1Score:
+	bg_soundeffect("tming_success.wav",$@BG_Team1);
+	bg_specialeffect(389,$@BG_Team1);
+	bg_emotion(ET_GO,$@BG_Team1);
+	.Team1_Score++;
+	donpcevent "Flavius_CTF::OnMatchStop";
+	end;
+
+OnTeam2Score:
+	bg_soundeffect("tming_success.wav",$@BG_Team2);
+	bg_specialeffect(389,$@BG_Team2);
+	bg_emotion(ET_GO,$@BG_Team2);
+	.Team2_Score++;
+	donpcevent "Flavius_CTF::OnMatchStop";
+	end;
+
+OnMatchStop:
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+	bg_updatescore "bat_b02",.Team1_Score,.Team2_Score;
+
+	viewpointmap "bat_b02",2, 0, 0, 1, 0x0000FF;
+	viewpointmap "bat_b02",2, 0, 0, 2, 0xFF0000;
+
+	// Team 1 Won
+	if (.Team1_Score >= .condition) {
+		mapannounce "bat_b02","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius CTF!",1,0x0000FF;
+		donpcevent "Flavius_CTF::OnMatchEnd";
+	}
+	// Team 2 Won
+	else if (.Team2_Score >= .condition) {
+		mapannounce "bat_b02","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius CTF!",1,0xFF0000;
+		donpcevent "Flavius_CTF::OnMatchEnd";
+	}
+	// Keep Playing
+	else {
+		sleep 8000;
+		donpcevent "Flavius_CTF::OnMatchStart";
+	}
+	end;
+
+OnTimer240000:
+	mapannounce "bat_b02","The Battle will ends in 4 minutes!!",1,0xA0522D;
+	end;
+
+OnTimer420000:
+	mapannounce "bat_b02","The Battle will ends in 1 minute!!",1,0xA0522D;
+	end;
+
+OnTimer480000:
+	announce "bat_b0248",bc_all;
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+
+	viewpointmap "bat_b02",2, 0, 0, 1, 0x0000FF;
+	viewpointmap "bat_b02",2, 0, 0, 2, 0xFF0000;
+
+	if (.Team1_Score > .Team2_Score)
+		mapannounce "bat_b02","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius CTF!",1,0x0000FF;
+	else if (.Team1_Score < .Team2_Score)
+		mapannounce "bat_b02","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius CTF!",1,0xFF0000;
+	else
+		mapannounce "bat_b02","The battle is over. This is a Tie...!",1,0xA0522D;
+	donpcevent "Flavius_CTF::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+	donpcevent "#guictf_respawn::OnBGStop";
+	donpcevent "#croctf_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	//bg_showdigit($@BG_Team1,0);
+	//bg_showdigit($@BG_Team2,0);
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+
+	if (.Team1_Score > .Team2_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"bat_b02",1,3,0,$@ctf_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los,0,0,"bat_b02",1,3,2,$@ctf_los);
+	} else if (.Team2_Score > .Team1_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_los,0,0,"bat_b02",1,3,2,$@ctf_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"bat_b02",1,3,0,$@ctf_win);
+	} else {
+		bg_reward($@BG_Team1,.reward_id,.qty_tie,0,0,"bat_b02",1,3,1,$@ctf_tie);
+		bg_reward($@BG_Team2,.reward_id,.qty_tie,0,0,"bat_b02",1,3,1,$@ctf_tie);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	donpcevent "Flavius_CTF::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	end;
+OnEnd:
+	sleep 1000;
+	mapwarp "bat_b02","bat_room",154,150;
+	bg_updatescore "bat_b02",0,0;
+	end;
+}
+
+// Battleground Flags
+// *********************************************************************
+
+bat_b02,328,150,0	script	Alpha Crystal::Team1_Flag	1914,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_CTF" || Hp < 1)
+		end;
+
+	// Flag Captured
+	if (getcharid(4) == $@BG_Team2 && .Flag_Status < 2) {
+		set .Flag_Status, 2; // Taken
+		set .Flag_Carrier, getcharid(0);
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b02","Alpha Crystal Taken by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_CTF_TAKEN,1,1);
+		disablenpc "Team1_Flag";
+		addtimer 2100, "Flavius_CTF::OnAlphaFlash";
+		stopnpctimer;
+	} else if (getcharid(4) == $@BG_Team1) {
+		if (.Flag_Status == 0 && getvariableofnpc(.Flag_Carrier,"Team2_Flag") == getcharid(0)) {
+			set getvariableofnpc(.Flag_Carrier,"Team2_Flag"),0;
+			set .Flag_Carrier, 0;
+			mapannounce "bat_b02","Omega Crystal Captured by [ " + strcharinfo(0) + " ]!!",1,0xFF0000;
+			bg_rankpoints(BGR_CTF_CAPTURED,1,1);
+			setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+			stopnpctimer;
+			donpcevent "Flavius_CTF::OnTeam1Score";
+		} else if (.Flag_Status == 1) {
+			mapannounce "bat_b02","Alpha Crystal Returned by [ " + strcharinfo(0) + " ]!!",1,0x0000FF;
+			bg_rankpoints(BGR_FAME,0,1);
+			disablenpc "Team1_Flag";
+			sleep 2100;
+			movenpc "Team1_Flag",328,150; // Back to Base
+			set .Flag_Status, 0;
+			initnpctimer;
+			enablenpc "Team1_Flag";
+		}
+	}
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if (.Flag_Status < 2) {
+		getmapxy .@m$, .@x, .@y, BL_NPC;
+		viewpointmap "bat_b02",1, .@x, .@y, 1, 0x0000FF;
+		specialeffect 223;
+		initnpctimer;
+	}
+	end;
+
+OnBase:
+	movenpc "Team1_Flag",328,150;
+	set .Flag_Status, 0;
+	set .Flag_Carrier, 0;
+	initnpctimer;
+	enablenpc "Team1_Flag";
+	end;
+}
+
+bat_b02,62,150,0	script	Omega Crystal::Team2_Flag	1915,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_CTF" || Hp < 1)
+		end;
+
+	// Flag Captured
+	if (getcharid(4) == $@BG_Team1 && .Flag_Status < 2) {
+		set .Flag_Status, 2; // Taken
+		set .Flag_Carrier, getcharid(0);
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b02","Omega Crystal Taken by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_CTF_TAKEN,1,1);
+		disablenpc "Team2_Flag";
+		addtimer 2100, "Flavius_CTF::OnOmegaFlash";
+		stopnpctimer;
+	} else if (getcharid(4) == $@BG_Team2) {
+		if (.Flag_Status == 0 && getvariableofnpc(.Flag_Carrier,"Team1_Flag") == getcharid(0)) {
+			set getvariableofnpc(.Flag_Carrier,"Team1_Flag"),0;
+			set .Flag_Carrier, 0;
+			mapannounce "bat_b02","Alpha Crystal Captured by [ " + strcharinfo(0) + " ]!!",1,0x0000FF;
+			bg_rankpoints(BGR_CTF_CAPTURED,1,1);
+			setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+			stopnpctimer;
+			donpcevent "Flavius_CTF::OnTeam2Score";
+		} else if (.Flag_Status == 1) {
+			mapannounce "bat_b02","Omega Crystal Returned by [ " + strcharinfo(0) + " ]!!",1,0xFF0000;
+			bg_rankpoints(BGR_FAME,0,1);
+			disablenpc "Team2_Flag";
+			sleep 2100;
+			movenpc "Team2_Flag",62,150; // Back to Base
+			set .Flag_Status, 0;
+			initnpctimer;
+			enablenpc "Team2_Flag";
+		}
+	}
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if (.Flag_Status < 2) {
+		getmapxy .@m$, .@x, .@y, BL_NPC;
+		viewpointmap "bat_b02",1, .@x, .@y, 2, 0xFF0000;
+		specialeffect 223;
+		initnpctimer;
+	}
+	end;
+
+OnBase:
+	movenpc "Team2_Flag",62,150;
+	set .Flag_Status, 0;
+	set .Flag_Carrier, 0;
+	initnpctimer;
+	enablenpc "Team2_Flag";
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+bat_b02,390,13,5	script	Therapist in battle#ctf1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+bat_b02,10,293,5	script	Therapist in battle#ctf2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+bat_b02,390,10,0	script	#guictf_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#ctf1"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_b02",382,2,397,17,100,100;
+		areawarp "bat_b02",382,2,397,17,"bat_b02",311,224;
+	}
+	initnpctimer;
+	end;
+}
+
+bat_b02,10,290,0	script	#croctf_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#ctf2"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_b02",2,282,17,297,100,100;
+		areawarp "bat_b02",2,282,17,297,"bat_b02",87,75;
+	}
+	initnpctimer;
+	end;
+}
+
+// Flags
+// *********************************************************************
+
+bat_b02,304,231,1	duplicate(Base Flag#bg)	Alpha Base#bat23	1_FLAG_LION
+bat_b02,319,231,1	duplicate(Base Flag#bg)	Alpha Base#bat24	1_FLAG_LION
+bat_b02,304,218,1	duplicate(Base Flag#bg)	Alpha Base#bat25	1_FLAG_LION
+bat_b02,319,218,1	duplicate(Base Flag#bg)	Alpha Base#bat26	1_FLAG_LION
+bat_b02,304,231,1	duplicate(Base Flag#bg)	Alpha Base#bat27	1_FLAG_LION
+bat_b02,304,231,1	duplicate(Base Flag#bg)	Alpha Base#bat28	1_FLAG_LION
+bat_b02,335,142,1	duplicate(Base Flag#bg)	Alpha Base#bat29	1_FLAG_LION
+bat_b02,335,157,1	duplicate(Base Flag#bg)	Alpha Base#bat30	1_FLAG_LION
+bat_b02,390,16,1	duplicate(Base Flag#bg)	Alpha Base#bat31	1_FLAG_LION
+bat_b02,292,163,1	duplicate(Base Flag#bg)	Alpha Base#bat32	1_FLAG_LION
+bat_b02,292,136,1	duplicate(Base Flag#bg)	Alpha Base#bat33	1_FLAG_LION
+bat_b02,241,185,1	duplicate(Base Flag#bg)	Alpha Base#bat34	1_FLAG_LION
+bat_b02,247,179,1	duplicate(Base Flag#bg)	Alpha Base#bat35	1_FLAG_LION
+
+bat_b02,96,81,1	duplicate(Base Flag#bg)	Omega Base#bat22	1_FLAG_EAGLE
+bat_b02,96,68,1	duplicate(Base Flag#bg)	Omega Base#bat23	1_FLAG_EAGLE
+bat_b02,79,81,1	duplicate(Base Flag#bg)	Omega Base#bat24	1_FLAG_EAGLE
+bat_b02,79,68,1	duplicate(Base Flag#bg)	Omega Base#bat25	1_FLAG_EAGLE
+bat_b02,96,81,1	duplicate(Base Flag#bg)	Omega Base#bat26	1_FLAG_EAGLE
+bat_b02,96,81,1	duplicate(Base Flag#bg)	Omega Base#bat27	1_FLAG_EAGLE
+bat_b02,59,164,1	duplicate(Base Flag#bg)	Omega Base#bat28	1_FLAG_EAGLE
+bat_b02,59,137,1	duplicate(Base Flag#bg)	Omega Base#bat29	1_FLAG_EAGLE
+bat_b02,10,296,1	duplicate(Base Flag#bg)	Omega Base#bat30	1_FLAG_EAGLE
+bat_b02,110,162,1	duplicate(Base Flag#bg)	Omega Base#bat31	1_FLAG_EAGLE
+bat_b02,110,137,1	duplicate(Base Flag#bg)	Omega Base#bat32	1_FLAG_EAGLE
+bat_b02,152,120,1	duplicate(Base Flag#bg)	Omega Base#bat33	1_FLAG_EAGLE
+bat_b02,158,114,1	duplicate(Base Flag#bg)	Omega Base#bat34	1_FLAG_EAGLE
+
+// MapFlags
+// *********************************************************************
+
+bat_b02	mapflag	battleground	2
+bat_b02	mapflag	nomemo
+bat_b02	mapflag	nosave	SavePoint
+bat_b02	mapflag	noteleport
+bat_b02	mapflag	nowarp
+bat_b02	mapflag	nowarpto
+bat_b02	mapflag	noreturn
+bat_b02	mapflag	nobranch
+bat_b02	mapflag	nopenalty
+bat_b02	mapflag	noecall
+bat_b02	mapflag	bg_consume
+bat_b02	mapflag	novending
diff --git a/npc/custom/eBG/bg_flavius_sc.txt b/npc/custom/eBG/bg_flavius_sc.txt
new file mode 100644
index 0000000..46f8770
--- /dev/null
+++ b/npc/custom/eBG/bg_flavius_sc.txt
@@ -0,0 +1,995 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  25-01-2023
+// By:
+//  Easycore         (Zephyrus, original author)
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Flavius Stone Control
+// ==============================================================================*/
+
+-	script	Flavius_SC	-1,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	.qty_tie = 10;					// Reward amount for draw
+	.condition = 99;				// How much score for win condition
+	// ===========
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert; // Deserter
+OnTeam1Die:
+OnTeam2Die:
+	if ($@BG_Status == 1 && $@BG_Current$ == "Flavius_SC" && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Stone Carrier
+		set .Stone[.@Stone],0;
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Neutral Stone#" + .@Stone, .@x, .@y;
+		mapannounce "bat_b04","Neutral Stone Dropped by [ " + strcharinfo(0) + " ]",1,0xFFFFFF;
+		bg_rankpoints(BGR_SC_DROPPED,1,0);
+		if (killerrid)
+			bg_rankpoints(BGR_FAME,0,1,killerrid);
+		initnpctimer "Neutral Stone#" + .@Stone;
+		deltimer "Flavius_SC::OnFlash";
+		enablenpc "Neutral Stone#" + .@Stone;
+	}
+	end;
+
+
+OnTeam1Active:
+	warp "bat_b04",228,39;
+	donpcevent "BG_Core::OnJoinActive";
+	end;
+OnTeam2Active:
+	warp "bat_b04",30,38;
+	donpcevent "BG_Core::OnJoinActive";
+	end;
+
+OnStart:
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+	initnpctimer;
+	set .guillaume_score, 0;
+	set .croix_score, 0;
+	setarray .Stone[1],0,0,0,0,0,0;
+	setarray .x[1],177,222,222,177,200,199;
+	setarray .y[1],182,182,117,117,105,194;
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1)
+		donpcevent "Neutral Stone#" + .@i + "::OnBGStart";
+
+	bg_updatescore "bat_b04",.guillaume_score,.croix_score;
+	sleep 2000;
+	bg_warp $@BG_Team1,"bat_b04",328,150;
+	bg_warp $@BG_Team2,"bat_b04",62,150;
+	sleep 2000;
+	mapannounce "bat_b04","Control the Stones to achieve victory!",1,$@BG_Color$[$@BG_Index];
+	donpcevent "#guisc_respawn::OnBGStart";
+	donpcevent "#crosc_respawn::OnBGStart";
+	end;
+
+OnGuillaumeScore:
+	set .guillaume_score, .guillaume_score + 1;
+	donpcevent "Flavius_SC::OnValidateScore";
+	end;
+
+OnCroixScore:
+	set .croix_score, .croix_score + 1;
+	donpcevent "Flavius_SC::OnValidateScore";
+	end;
+
+OnValidateScore:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC")
+		end;
+	if (.guillaume_score > .condition)
+		set .guillaume_score,.condition;
+	if (.croix_score > .condition)
+		set .croix_score,.condition;
+
+	bg_updatescore "bat_b04",.guillaume_score,.croix_score;
+	if (.croix_score >= .condition || .guillaume_score >= .condition)
+		donpcevent "Flavius_SC::OnMatchEnd";
+	end;
+
+OnTimer600000:
+	mapannounce "bat_b04","The Battle will end in 5 minutes!!",1,0x9ACD32;
+	end;
+
+OnTimer840000:
+	mapannounce "bat_b04","The Battle will end in 1 minute!!",1,0x9ACD32;
+	end;
+
+OnTimer900000:
+OnMatchEnd:
+	stopnpctimer;
+	donpcevent "#guisc_respawn::OnBGStop";
+	donpcevent "#crosc_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if (.guillaume_score > .croix_score) { // Guillaume Won
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"BG_SC",1,5,0,$@sc_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los,0,0,"BG_SC",1,5,2,$@sc_los);
+		mapannounce "bat_b04","The Guillaume army has won the Battle of Flavius Stone Control!",1,0x0000FF;
+	} else if (.guillaume_score < .croix_score) { // Croix Won
+		bg_reward($@BG_Team1,.reward_id,.qty_los,0,0,"BG_SC",1,5,2,$@sc_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"BG_SC",1,5,0,$@sc_win);
+		mapannounce "bat_b04","The Croix army has won the Battle of Flavius Stone Control!",1,0xFF0000;
+	} else {
+		bg_reward($@BG_Team1,.reward_id,.qty_tie,0,0,"BG_SC",1,5,1,$@sc_tie);
+		bg_reward($@BG_Team2,.reward_id,.qty_tie,0,0,"BG_SC",1,5,1,$@sc_tie);
+		mapannounce "bat_b04","The battle is over. This is a Tie...!",1,0x9ACD32;
+	}
+	// =======================================================
+	set .guillaume_score, 0;
+	set .croix_score, 0;
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1) { // Stop Running Timers
+		stopnpctimer "Neutral Stone#" + .@i;
+		stopnpctimer "csp" + .@i; // Croix Stone Point
+		stopnpctimer "gsp" + .@i; // Guillaume Stone Point
+	}
+	sleep 5000;
+	setarray .Stone[1],0,0,0,0,0,0;
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1) { // Return Stones to Starting Position and Normalize Stone Points
+		donpcevent "Neutral Stone#" + .@i + "::OnBGStop";
+		donpcevent "csp" + .@i + "::OnBGStop";
+		donpcevent "gsp" + .@i + "::OnBGStop";
+	}
+	donpcevent "Flavius_SC::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	end;
+
+OnEnd:
+	sleep 1000;
+	mapwarp "bat_cc","bat_room",154,150;
+	bg_updatescore "bat_cc",0,0;
+	end;
+
+OnFlash:
+	if ($@BG_Status == 1 && $@BG_Current$ == "Flavius_SC" && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) {
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		if (getcharid(4) == $@BG_Team1)
+			viewpointmap "bat_b04",1, .@x, .@y, .@Stone, 0x0000FF;
+		else if (getcharid(4) == $@BG_Team2)
+			viewpointmap "bat_b04",1, .@x, .@y, .@Stone, 0xFF0000;
+		specialeffect(EF_BOWLINGBASH);
+		emotion ET_HELP,getcharid(3);
+		addtimer 2000, "Flavius_SC::OnFlash";
+		percentheal -5,-5;
+	}
+	end;
+}
+
+// Basic Functions
+// *********************************************************************
+
+function	script	SC_StoneCheck	{
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1) {
+		if (getvariableofnpc(.Stone[.@i],"Flavius_SC") == getarg(0))
+			return .@i;
+	}
+	return 0;
+}
+
+// Neutral Stones
+// *********************************************************************
+
+bat_b04,177,182,0	script	Neutral Stone#1	1905,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1 || getcharid(4) == 0)
+		end;
+	set .@Stone,atoi(strnpcinfo(2));
+	if (getvariableofnpc(.Stone[.@Stone],"Flavius_SC") != 0)
+		end; // Already Captured
+	if (callfunc("SC_StoneCheck",getcharid(0)) != 0)
+		end; // Already with a Stone
+
+	callfunc("F_EndSpeedBG");
+	setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+	set getvariableofnpc(.Stone[.@Stone],"Flavius_SC"),getcharid(0);
+	addtimer 2000, "Flavius_SC::OnFlash";
+	disablenpc strnpcinfo(0);
+	stopnpctimer;
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, atoi(strnpcinfo(2)), 0xFFFFFF;
+	end;
+
+OnBGStop:
+	set .@Stone,atoi(strnpcinfo(2));
+	movenpc strnpcinfo(0),getvariableofnpc(.x[.@Stone],"Flavius_SC"),getvariableofnpc(.y[.@Stone],"Flavius_SC");
+	enablenpc strnpcinfo(0);
+	stopnpctimer;
+	end;
+}
+
+bat_b04,222,182,0	duplicate(Neutral Stone#1)	Neutral Stone#2	1905,1,1
+bat_b04,222,117,0	duplicate(Neutral Stone#1)	Neutral Stone#3	1905,1,1
+bat_b04,177,117,0	duplicate(Neutral Stone#1)	Neutral Stone#4	1905,1,1
+bat_b04,200,105,0	duplicate(Neutral Stone#1)	Neutral Stone#5	1905,1,1
+bat_b04,199,194,0	duplicate(Neutral Stone#1)	Neutral Stone#6	1905,1,1
+
+// Stone Point - Croix Team
+// *********************************************************************
+
+bat_b04,85,159,0	script	Stone Point::csp1	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Guillaume Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Croix Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Croix Stone captured by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Croix Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0xFF0000;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnCroixScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,78,159,0	script	Stone Point::csp2	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Guillaume Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Croix Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Croix Stone captured by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Croix Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0xFF0000;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnCroixScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,71,159,0	script	Stone Point::csp3	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Guillaume Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Croix Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Croix Stone captured by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Croix Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0xFF0000;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnCroixScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,85,140,0	script	Stone Point::csp4	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Guillaume Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Croix Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Croix Stone captured by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Croix Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0xFF0000;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnCroixScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,78,140,0	script	Stone Point::csp5	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Guillaume Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Croix Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Croix Stone captured by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Croix Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0xFF0000;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnCroixScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,71,140,0	script	Stone Point::csp6	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Guillaume Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Croix Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Croix Stone captured by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Croix Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0xFF0000;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnCroixScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+// Stone Point - Guillaume Team
+// *********************************************************************
+
+bat_b04,312,159,0	script	Stone Point::gsp1	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Croix Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Guillaume Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Guillaume Stone captured by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Guillaume Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0x0000FF;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnGuillaumeScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,319,159,0	script	Stone Point::gsp2	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Croix Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Guillaume Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Guillaume Stone captured by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Guillaume Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0x0000FF;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnGuillaumeScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,326,159,0	script	Stone Point::gsp3	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Croix Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Guillaume Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Guillaume Stone captured by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Guillaume Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0x0000FF;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnGuillaumeScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,312,140,0	script	Stone Point::gsp4	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Croix Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Guillaume Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Guillaume Stone captured by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Guillaume Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0x0000FF;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnGuillaumeScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,319,140,0	script	Stone Point::gsp5	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Croix Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Guillaume Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Guillaume Stone captured by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Guillaume Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0x0000FF;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnGuillaumeScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bat_b04,326,140,0	script	Stone Point::gsp6	1309,1,1,{
+	unitwalkto(getcharid(3),getnpcid(0));
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_SC" || Hp < 1)
+		end;
+	if (.Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0) { // Croix Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		callfunc("F_EndSpeedBG");
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,true);
+
+		mapannounce "bat_b04","Guillaume Stone has been stolen by [ " + strcharinfo(0) + " ]",1,0xFF0000;
+		bg_rankpoints(BGR_SC_STOLE,1,$@sc_stole);
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	} else if (.Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0) { // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		setpcblock(PCBLOCK_SKILL|PCBLOCK_USEITEM,false);
+
+		mapannounce "bat_b04","Guillaume Stone captured by [ " + strcharinfo(0) + " ]",1,0x0000FF;
+		bg_rankpoints(BGR_SC_CAPTURED,1,$@sc_captured);
+
+		setnpcdisplay strnpcinfo(3),"Guillaume Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bat_b04",1, .@x, .@y, .Point, 0x0000FF;
+	specialeffect 223;
+	if (set(.Count, .Count + 1) >= 5) {
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnGuillaumeScore";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+bat_b04,390,10,0	script	#guisc_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	specialeffect(EF_SANCTUARY);
+	end;
+
+OnTimer25000:
+	areapercentheal "bat_b04",382,2,397,17,100,100;
+	areawarp "bat_b04",382,2,397,17,"bat_b04",311,224;
+	initnpctimer;
+	end;
+}
+
+bat_b04,10,290,0	script	#crosc_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	specialeffect(EF_SANCTUARY);
+	end;
+
+OnTimer25000:
+	areapercentheal "bat_b04",2,282,17,297,100,100;
+	areawarp "bat_b04",2,282,17,297,"bat_b04",87,75;
+	initnpctimer;
+	end;
+}
+
+// Flags
+// *********************************************************************
+
+bat_b04,304,231,1	duplicate(Base Flag#bg)	Alpha Base#sc_1	973
+bat_b04,319,231,1	duplicate(Base Flag#bg)	Alpha Base#sc_2	973
+bat_b04,304,218,1	duplicate(Base Flag#bg)	Alpha Base#sc_3	973
+bat_b04,319,218,1	duplicate(Base Flag#bg)	Alpha Base#sc_4	973
+bat_b04,304,231,1	duplicate(Base Flag#bg)	Alpha Base#sc_5	973
+bat_b04,304,231,1	duplicate(Base Flag#bg)	Alpha Base#sc_6	973
+bat_b04,335,142,1	duplicate(Base Flag#bg)	Alpha Base#sc_7	973
+bat_b04,335,157,1	duplicate(Base Flag#bg)	Alpha Base#sc_8	973
+bat_b04,390,16,1	duplicate(Base Flag#bg)	Alpha Base#sc_9	973
+bat_b04,292,163,1	duplicate(Base Flag#bg)	Alpha Base#sc_10	973
+bat_b04,292,136,1	duplicate(Base Flag#bg)	Alpha Base#sc_11	973
+bat_b04,241,185,1	duplicate(Base Flag#bg)	Alpha Base#sc_12	973
+bat_b04,247,179,1	duplicate(Base Flag#bg)	Alpha Base#sc_13	973
+
+bat_b04,96,81,1	duplicate(Base Flag#bg)	Omega Base#sc_1	974
+bat_b04,96,68,1	duplicate(Base Flag#bg)	Omega Base#sc_2	974
+bat_b04,79,81,1	duplicate(Base Flag#bg)	Omega Base#sc_3	974
+bat_b04,79,68,1	duplicate(Base Flag#bg)	Omega Base#sc_4	974
+bat_b04,96,81,1	duplicate(Base Flag#bg)	Omega Base#sc_5	974
+bat_b04,96,81,1	duplicate(Base Flag#bg)	Omega Base#sc_6	974
+bat_b04,59,164,1	duplicate(Base Flag#bg)	Omega Base#sc_7	974
+bat_b04,59,137,1	duplicate(Base Flag#bg)	Omega Base#sc_8	974
+bat_b04,10,296,1	duplicate(Base Flag#bg)	Omega Base#sc_9	974
+bat_b04,110,162,1	duplicate(Base Flag#bg)	Omega Base#sc_10	974
+bat_b04,110,137,1	duplicate(Base Flag#bg)	Omega Base#sc_11	974
+bat_b04,152,120,1	duplicate(Base Flag#bg)	Omega Base#sc_12	974
+bat_b04,158,114,1	duplicate(Base Flag#bg)	Omega Base#sc_13	974
+
+// MapFlags
+// *********************************************************************
+
+bat_b04	mapflag	battleground	2
+bat_b04	mapflag	nomemo
+bat_b04	mapflag	nosave	SavePoint
+bat_b04	mapflag	noteleport
+bat_b04	mapflag	nowarp
+bat_b04	mapflag	nowarpto
+bat_b04	mapflag	noreturn
+bat_b04	mapflag	nobranch
+bat_b04	mapflag	nopenalty
+bat_b04	mapflag	noecall
+bat_b04	mapflag	bg_consume
+bat_b04	mapflag	novending
\ No newline at end of file
diff --git a/npc/custom/eBG/bg_flavius_td.txt b/npc/custom/eBG/bg_flavius_td.txt
new file mode 100644
index 0000000..11415d6
--- /dev/null
+++ b/npc/custom/eBG/bg_flavius_td.txt
@@ -0,0 +1,309 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  25-01-2023
+// By:
+//  Easycore         (Zephyrus, original author)
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// BattleGround System - Flavius TeamDeathMatch
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Flavius_TD	FAKE_NPC,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	.qty_tie = 10;					// Reward amount for draw
+	.condition = 50;					// Lives for each team
+	// ===========
+	end;
+
+OnTeam1Quit:
+	bg_desert; // Deserter
+OnTeam1Die:
+	if ($@BG_Status == 1 && $@BG_Current$ == "Flavius_TD") {
+		if (killerrid != 0) {
+			set .Team1_Score, .Team1_Score - 1;
+			bg_rankpoints(BGR_TD_KILL,1,$@td_kill,killerrid);
+			bg_rankpoints(BGR_TD_DEATH,1,$@td_death);
+		}
+		donpcevent "Flavius_TD::OnValidateScore";
+	}
+	end;
+
+OnTeam2Quit:
+	bg_desert; // Deserter
+OnTeam2Die:
+	if ($@BG_Status == 1 && $@BG_Current$ == "Flavius_TD") {
+		if (killerrid != 0) {
+			set .Team2_Score, .Team2_Score - 1;
+			bg_rankpoints(BGR_TD_KILL,1,$@td_kill,killerrid);
+			bg_rankpoints(BGR_TD_DEATH,1,$@td_death);
+		}
+		donpcevent "Flavius_TD::OnValidateScore";
+	}
+	end;
+
+OnTeam1Active:
+	warp "bat_cc",88,139;
+	donpcevent "BG_Core::OnJoinActive";
+	end;
+OnTeam2Active:
+	warp "bat_cc",96,139;
+	donpcevent "BG_Core::OnJoinActive";
+	end;
+
+OnStart:
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+	initnpctimer;
+	.Team1_Score = .condition;
+	.Team2_Score = .condition;
+	bg_updatescore "bat_cc",.Team1_Score,.Team2_Score;
+	sleep 2100;
+	bg_warp $@BG_Team1,"bat_cc",53,128;
+	bg_warp $@BG_Team2,"bat_cc",146,55;
+	sleep 2100;
+	mapannounce "bat_cc","Defeat enemies until they have no lives left!",1,$@BG_Color$[$@BG_Index];
+	bg_team_reveal $@BG_Team1,true;
+	bg_team_reveal $@BG_Team2,true;
+	donpcevent "#guitd_respawn::OnBGStart";
+	donpcevent "#crotd_respawn::OnBGStart";
+	donpceventall "OnEmblemTD";
+	end;
+
+OnValidateScore:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Flavius_TD")
+		end;
+
+	bg_updatescore "bat_cc",.Team1_Score,.Team2_Score;
+	set .@Team1Count, bg_get_data($@BG_Team1, 0);
+	set .@Team2Count, bg_get_data($@BG_Team2, 0);
+	// Team 1 Won
+	if (.Team2_Score <= 0) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"BG_TDM",1,4,0,$@td_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los,0,0,"BG_TDM",1,4,2,$@td_los);
+		mapannounce "bat_cc","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius TD!",1,bg_get_data($@BG_Team1,4);
+	}
+	// Team 2 Won
+	else if (.Team1_Score <= 0) {
+		bg_reward($@BG_Team1,.reward_id,.qty_los,0,0,"BG_TDM",1,4,2,$@td_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"BG_TDM",1,4,0,$@td_win);
+		mapannounce "bat_cc","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius TD!",1,bg_get_data($@BG_Team2,4);
+	}
+	// All Team 2 Players quit
+	else if (.@Team2Count == 0) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"BG_TDM",1,4,0,$@td_win);
+		mapannounce "bat_cc","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius TD!",1,bg_get_data($@BG_Team1,4);
+	}
+	// All Team 1 Players quit
+	else if (.@Team1Count == 0) {
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"BG_TDM",1,4,0,$@td_win);
+		mapannounce "bat_cc","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius TD!",1,bg_get_data($@BG_Team2,4);
+	}
+	else end;
+	donpcevent "Flavius_TD::OnMatchEnd";
+	end;
+
+OnTimer600000:
+	mapannounce "bat_cc","The Battle will ends in 5 minutes!!",1,0x808000;
+	end;
+
+OnTimer840000:
+	mapannounce "bat_cc","The Battle will ends in 1 minute!!",1,0x808000;
+	end;
+
+OnTimer900000:
+	// Team 1 Won
+	if (.Team1_Score > .Team2_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"BG_TDM",1,4,0,$@td_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los,0,0,"BG_TDM",1,4,2,$@td_los);
+		mapannounce "bat_cc","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius TD!",1,bg_get_data($@BG_Team1,4);
+	}
+	// Team 2 Won
+	else if (.Team1_Score < .Team2_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_los,0,0,"BG_TDM",1,4,2,$@td_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"BG_TDM",1,4,0,$@td_win);
+		mapannounce "bat_cc","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius TD!",1,bg_get_data($@BG_Team2,4);
+	}
+	else {
+		bg_reward($@BG_Team1,.reward_id,.qty_tie,0,0,"BG_TDM",1,4,1,$@td_tie);
+		bg_reward($@BG_Team2,.reward_id,.qty_tie,0,0,"BG_TDM",1,4,1,$@td_tie);
+		mapannounce "bat_cc","The battle is over. This is a Tie...!",1,0x808000;
+	}
+	donpcevent "Flavius_TD::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	donpcevent "#guitd_respawn::OnBGStop";
+	donpcevent "#crotd_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	set .Team1_Score, 50;
+	set .Team2_Score, 50;
+	sleep 5000;
+	donpcevent "Flavius_TD::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	addrid(5,0,"bat_cc");
+	bg_leave;
+	end;
+
+OnEnd:
+	sleep 1000;
+	mapwarp "bat_cc","bat_room",154,150;
+	bg_updatescore "bat_cc",0,0;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+bat_cc,88,143,5	script	Therapist in battle#td1	4_F_SISTER,{
+	getmapxy(.@map$,.@x,.@y, BL_PC);
+	if (distance(.@x,.@y,88,143) > 6)
+		end;
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+bat_cc,97,143,3	script	Therapist in battle#td2	4_F_SISTER,{
+	getmapxy(.@map$,.@x,.@y, BL_PC);
+	if (distance(.@x,.@y,97,143) > 6)
+		end;
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+bat_cc,88,139,0	script	#guitd_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#td1"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_cc",85,134,92,146,100,100;
+		areawarp "bat_cc",85,134,92,146,"bat_cc",50,131,77,102;
+	}
+	initnpctimer;
+	end;
+}
+
+bat_cc,96,139,0	script	#crotd_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#td2"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_cc",93,134,100,146,100,100;
+		areawarp "bat_cc",93,134,100,146,"bat_cc",50,131,77,102;
+	}
+	initnpctimer;
+	end;
+}
+
+// Flags
+// *********************************************************************
+bat_cc,88,146,4	script	Flag#TD_Blue	GUILD_FLAG,{
+	end;
+OnEmblemTD:
+	bg_flagemblem($@BG_Team1);
+	end;
+}
+bat_cc,97,146,4	script	Flag#TD_Red	GUILD_FLAG,{
+	end;
+OnEmblemTD:
+	bg_flagemblem($@BG_Team2);
+	end;
+}
+
+bat_cc,40,105,1	duplicate(Base Flag#bg)	Alpha Base#td_1	973
+bat_cc,47,105,1	duplicate(Base Flag#bg)	Alpha Base#td_2	973
+
+bat_cc,96,49,1	duplicate(Base Flag#bg)	Omega Base#td_1	974
+bat_cc,103,49,1	duplicate(Base Flag#bg)	Omega Base#td_2	974
+
+bat_cc,76,102,1	duplicate(Base Flag#bg)	Alpha Base#td_3	973
+bat_cc,89,111,1	duplicate(Base Flag#bg)	Alpha Base#td_4	973
+bat_cc,61,130,1	duplicate(Base Flag#bg)	Alpha Base#td_5	973
+bat_cc,51,120,1	duplicate(Base Flag#bg)	Alpha Base#td_6	973
+
+bat_cc,100,72,1	duplicate(Base Flag#bg)	Omega Base#td_3	974
+bat_cc,123,81,1	duplicate(Base Flag#bg)	Omega Base#td_4	974
+bat_cc,138,53,1	duplicate(Base Flag#bg)	Omega Base#td_5	974
+bat_cc,148,63,1	duplicate(Base Flag#bg)	Omega Base#td_6	974
+
+// MapFlags
+// *********************************************************************
+
+bat_cc	mapflag	battleground	2
+bat_cc	mapflag	nomemo
+bat_cc	mapflag	nosave	SavePoint
+bat_cc	mapflag	noteleport
+bat_cc	mapflag	nowarp
+bat_cc	mapflag	nowarpto
+bat_cc	mapflag	noreturn
+bat_cc	mapflag	nobranch
+bat_cc	mapflag	nopenalty
+bat_cc	mapflag	bg_consume
+bat_cc	mapflag	novending
diff --git a/npc/custom/eBG/bg_rush.txt b/npc/custom/eBG/bg_rush.txt
new file mode 100644
index 0000000..3259184
--- /dev/null
+++ b/npc/custom/eBG/bg_rush.txt
@@ -0,0 +1,596 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  30-01-2023
+// By:
+//  Easycore         (Zephyrus, original author)
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Rush
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Rush	FAKE_NPC,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	// ===========
+	// For Emperium Configurations edit db/import/mob_db_bg.yml
+	// ===========
+	setwall "rush_cas01",198,228,10,6,0,"Rush_wall_a";
+	setcell "rush_cas01",198,224,207,233,cell_basilica,1;
+	setwall "rush_cas02",142,48,10,6,0,"Rush_wall_b";
+	setcell "rush_cas02",142,44,151,53,cell_basilica,1;
+	setwall "rush_cas03",62,8,10,0,0,"Rush_wall_c";
+	setcell "rush_cas03",56,6,69,17,cell_basilica,1;
+	setwall "rush_cas04",266,290,10,6,0,"Rush_wall_d";
+	setcell "rush_cas04",266,286,275,295,cell_basilica,1;
+	.Index = -1;
+	end;
+
+OnTeam1Active:
+	warp .Castle$,.GX,.GY;
+	end;
+OnTeam2Active:
+	warp .Castle$,.CX,.CY;
+	end;
+
+OnTeam1Die:
+OnTeam2Die:
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert;
+	end;
+
+OnStart:
+	if ((.Index++) > 3)
+		.Index = 0;
+
+	switch(.Index) {
+		case 0: set .Castle$,"rush_cas01"; set .GX,202; set .GY,230; set .CX,202; set .CY,226; break;
+		case 1: set .Castle$,"rush_cas02"; set .GX,146; set .GY, 50; set .CX,146; set .CY, 46; break;
+		case 2: set .Castle$,"rush_cas03"; set .GX, 60; set .GY, 13; set .CX, 64; set .CY, 13; break;
+		case 3: set .Castle$,"rush_cas04"; set .GX,270; set .GY,292; set .CX,270; set .CY,288; break;
+	}
+	bg_set_cemetery($@BG_Team1,.Castle$,.GX,.GY);
+	bg_set_cemetery($@BG_Team2,.Castle$,.CX,.CY);
+
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+
+	initnpctimer;
+	donpcevent "Rush_Respawn::OnStart";
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	set .Defender, 0; // No Defender
+	// Emperium =====================
+	switch(.Index) {
+		case 0: // =========================================================================
+			bg_monster 0,.Castle$,158,174,"Emperium",20402,"Rush::OnEmperium";
+			break;
+		case 1: // =========================================================================
+			bg_monster 0,.Castle$,271,29,"Emperium",20402,"Rush::OnEmperium";
+			break;
+		case 2: // =========================================================================
+			bg_monster 0,.Castle$,28,102,"Emperium",20402,"Rush::OnEmperium";
+			break;
+		case 3: // =========================================================================
+			bg_monster 0,.Castle$,245,167,"Emperium",20402,"Rush::OnEmperium";
+			break;
+	}
+	// ======================================
+	sleep 2100;
+	switch(.Index) {
+		case 0:
+			bg_warp($@BG_Team1,.Castle$,43,229);
+			bg_warp($@BG_Team2,.Castle$,43,229);
+			break;
+		case 1:
+			bg_warp($@BG_Team1,.Castle$,252,271);
+			bg_warp($@BG_Team2,.Castle$,252,271);
+			break;
+		case 2:
+			bg_warp($@BG_Team1,.Castle$,216,103);
+			bg_warp($@BG_Team2,.Castle$,216,103);
+			break;
+		case 3:
+			bg_warp($@BG_Team1,.Castle$,100,280);
+			bg_warp($@BG_Team2,.Castle$,100,280);
+			break;
+	}
+	sleep 4000;
+	mapannounce .Castle$,"Move on warriors!! Let's capture this Castle!!",1,0xDDA0DD;
+	end;
+
+OnTimer60000:
+	mapannounce .Castle$,"Battle of Rush will ends in 6 minutes",1,0xDDA0DD;
+	end;
+
+OnTimer360000:
+	mapannounce .Castle$,"Battle of Rush will ends in 1 minute",1,0xDDA0DD;
+	end;
+
+OnEmperium:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Rush")
+		end;
+
+	if (.Defender == 0) { // First Capture
+		initnpctimer;
+		set .Defender,getcharid(4);
+		mapannounce .Castle$,bg_get_data(.Defender,3) + " : Castle captured, now prepare to Defend it!!",1,bg_get_data(.Defender,4);
+
+		if (.Defender == $@BG_Team1) {
+			set .Team1_Score,1;
+			set .Attacker,$@BG_Team2;
+		} else {
+			set .Team2_Score,1;
+			set .Attacker,$@BG_Team1;
+		}
+		switch(.Index) {
+			case 0:	bg_rankpoints_area(getcharid(4),.Castle$,142,166,173,177,BGR_RU_CAPTURES,1,$@ru_capture); break;
+			case 1:	bg_rankpoints_area(getcharid(4),.Castle$,250,8,291,49,BGR_RU_CAPTURES,1,$@ru_capture); break;
+			case 2:	bg_rankpoints_area(getcharid(4),.Castle$,21,97,34,106,BGR_RU_CAPTURES,1,$@ru_capture); break;
+			case 3:	bg_rankpoints_area(getcharid(4),.Castle$,234,157,255,177,BGR_RU_CAPTURES,1,$@ru_capture); break;
+		}
+		bg_rankpoints(BGR_EMPERIUM,1,$@bg_emp);
+
+		bg_warp_cemetery(.Attacker); // To Cementery and Wait
+		donpcevent("Rush_Respawn::OnResetTimer"); // Reset Respawn Timer
+		bg_updatescore(.Castle$,.Team1_Score,.Team2_Score);
+
+		// Emperium =====================
+		switch(.Index) {
+			case 0: // =========================================================================
+				bg_monster .Defender,.Castle$,158,174,"Emperium",20402,"Rush::OnEmperium";
+				break;
+			case 1: // =========================================================================
+				bg_monster .Defender,.Castle$,271,29,"Emperium",20402,"Rush::OnEmperium";
+				break;
+			case 2: // =========================================================================
+				bg_monster .Defender,.Castle$,28,102,"Emperium",20402,"Rush::OnEmperium";
+				break;
+			case 3: // =========================================================================
+				bg_monster .Defender,.Castle$,245,167,"Emperium",20402,"Rush::OnEmperium";
+				break;
+		}
+		// ======================================
+		initnpctimer "Rush_Respawn";
+
+		sleep 5000;
+		mapannounce .Castle$,bg_get_data(.Attacker,3) + " : Capture the Castle, it's our last chance to Win!!",1,bg_get_data(.Attacker,4);
+		end;
+	}
+
+	// Second Capture
+	mapannounce .Castle$,bg_get_data(.Attacker,3) + " : Castle captured, we won the Battle!!",1,bg_get_data(.Attacker,4);
+	if (.Defender == $@BG_Team1)
+		set .Team2_Score,2;
+	else
+		set .Team1_Score,2;
+
+	donpcevent "Rush::OnMatchEnd";
+	end;
+
+OnTimer420000:
+	if (.Defender == 0)
+		mapannounce .Castle$,"Castle captured Fail. No winners",1,0xDDA0DD;
+	else {
+		mapannounce .Castle$,bg_get_data(.Defender,3) + " : Castle protected, we won the Battle!!",1,bg_get_data(.Defender,4);
+		if (.Defender == $@BG_Team1)
+			set .Team1_Score,3;
+		else
+			set .Team2_Score,3;
+	}
+OnMatchEnd:
+	stopnpctimer;
+	stopnpctimer "Rush_Respawn";
+	killmonster .Castle$,"Rush::OnEmperium";
+	bg_updatescore .Castle$,.Team1_Score,.Team2_Score;
+	$@BG_Status = 2;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	.@Reward = .qty_los;
+	if (.Team1_Score > .Team2_Score) {
+		set .@Won,0;
+		.@Reward = .qty_win;
+	} else
+		set .@Won,2;
+
+	bg_reward($@BG_Team1,.reward_id,.@Reward,0,0,"BG_RUSH",1,7,.@Won,.@Won?$@ru_los:$@ru_win);
+	// =======================================================
+	.@Reward = .qty_los;
+	if (.Team2_Score > .Team1_Score) {
+		set .@Won,0;
+		.@Reward = .qty_win;
+	} else
+		set .@Won,2;
+
+	bg_reward($@BG_Team2,.reward_id,.@Reward,0,0,"BG_RUSH",1,7,.@Won,.@Won?$@ru_los:$@ru_win);
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	donpcevent "Rush::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	bg_updatescore .Castle$,.Team1_Score,.Team2_Score;
+	end;
+
+OnEnd:
+	sleep 1000;
+	mapwarp .castle$,"bat_room",154,150;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+-	script	Rush_Respawn	FAKE_NPC,{
+	end;
+
+OnResetTimer:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnStart:
+	initnpctimer;
+	.Index = getvariableofnpc(.Index,"Rush");
+	.Castle$ = getvariableofnpc(.Castle$,"Rush");
+	.Therapist1$ = "Therapist in battle#rh"+((.Index*2)+1);
+	.Therapist2$ = "Therapist in battle#rh"+((.Index*2)+2);
+	switch(.Index) {
+		case 0:
+			setcell(.Castle$,198,224,207,233,CELL_BASILICA,1);
+			break;
+		case 1:
+			setcell(.Castle$,142,44,151,52,CELL_BASILICA,1);
+			break;
+		case 2:
+			setcell(.Castle$,58,7,69,17,CELL_BASILICA,1);
+			break;
+		case 3:
+			setcell(.Castle$,266,286,275,294,CELL_BASILICA,1);
+			break;
+	}
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,.Therapist1$));
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,.Therapist2$));
+	if (.tick < 24) {
+		initnpctimer;
+		end;
+	}
+	if (.tick == 24) {
+		mapannounce .Castle$,"-- Reinforcements entering the Battle of Rush --",1,0xDDA0DD;
+		specialeffect 83,AREA,.Therapist1$;
+		specialeffect 83,AREA,.Therapist2$;
+		initnpctimer;
+		end;
+	}
+
+	set .Defender,getvariableofnpc(.Defender,"Rush");
+	switch(getvariableofnpc(.Index,"Rush")) {
+		case 0: // rush_cas01 ========================================================================
+			areapercentheal .Castle$,198,224,207,233,100,100;
+			if (.Defender == 0)
+				areawarp .Castle$,198,224,207,233,.Castle$,43,229;
+			else if ($BG_Team1 == .Defender) {
+				areawarp .Castle$,198,229,207,233,.Castle$,71,36;
+				areawarp .Castle$,198,224,207,227,.Castle$,43,229;
+			} else {
+				areawarp .Castle$,198,229,207,233,.Castle$,43,229;
+				areawarp .Castle$,198,224,207,227,.Castle$,71,36;
+			}
+			break;
+		case 1: // rush_cas02 ========================================================================
+			areapercentheal .Castle$,142,44,151,53,100,100;
+			if (.Defender == 0)
+				areawarp .Castle$,142,44,151,53,.Castle$,252,271;
+			else if ($BG_Team1 == .Defender) {
+				areawarp .Castle$,142,49,151,53,.Castle$,40,235;
+				areawarp .Castle$,142,44,151,47,.Castle$,252,271;
+			} else {
+				areawarp .Castle$,142,49,151,53,.Castle$,252,271;
+				areawarp .Castle$,142,44,151,47,.Castle$,40,235;
+			}
+			break;
+		case 2: // rush_cas03 ========================================================================
+			areapercentheal .Castle$,56,6,69,17,100,100;
+			if (.Defender == 0)
+				areawarp .Castle$,56,6,69,17,.Castle$,216,103;
+			else if ($BG_Team1 == .Defender) {
+				areawarp .Castle$,56,6,61,17,.Castle$,31,190;
+				areawarp .Castle$,63,6,69,17,.Castle$,216,103;
+			} else {
+				areawarp .Castle$,56,6,61,17,.Castle$,216,103;
+				areawarp .Castle$,63,6,69,17,.Castle$,31,190;
+			}
+			break;
+		case 3: // rush_cas04 ========================================================================
+			areapercentheal .Castle$,266,286,275,295,100,100;
+			if (.Defender == 0)
+				areawarp .Castle$,266,286,275,295,.Castle$,100,280;
+			else if ($BG_Team1 == .Defender) {
+				areawarp .Castle$,266,291,275,295,.Castle$,116,89;
+				areawarp .Castle$,266,286,275,289,.Castle$,100,280;
+			} else {
+				areawarp .Castle$,266,291,275,295,.Castle$,100,280;
+				areawarp .Castle$,266,286,275,289,.Castle$,116,89;
+			}
+			break;
+	}
+
+	initnpctimer;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+rush_cas01,198,230,6	script	Therapist in battle#rh1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+rush_cas01,198,226,6	script	Therapist in battle#rh2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+rush_cas02,142,50,6	script	Therapist in battle#rh3	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+rush_cas02,142,46,6	script	Therapist in battle#rh4	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+rush_cas03,60,17,4	script	Therapist in battle#rh5	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+rush_cas03,64,17,4	script	Therapist in battle#rh6	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+rush_cas04,266,292,6	script	Therapist in battle#rh7	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+rush_cas04,266,288,6	script	Therapist in battle#rh8	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+// Warp Portals
+// *********************************************************************
+
+rush_cas01,157,135,0	warp	rush106-1	1,1,rush_cas01,184,40
+rush_cas01,161,41,0	warp	rush102-1	1,1,rush_cas01,57,202
+rush_cas01,184,44,0	warp	rush106	1,1,rush_cas01,157,140
+rush_cas01,203,21,0	warp	rush105-1	1,1,rush_cas01,45,25
+rush_cas01,210,41,0	warp	rush101-1	1,1,rush_cas01,84,215
+rush_cas01,35,183,0	warp	rush104	1,1,rush_cas01,71,82
+rush_cas01,45,21,0	warp	rush105	1,1,rush_cas01,203,25
+rush_cas01,53,202,0	warp	rush102	1,1,rush_cas01,165,41
+rush_cas01,64,164,0	warp	rush103	1,1,rush_cas01,98,25
+rush_cas01,71,86,0	warp	rush104-1	1,1,rush_cas01,35,187
+rush_cas01,88,215,0	warp	rush101	1,1,rush_cas01,206,41
+rush_cas01,98,21,0	warp	rush103-1	1,1,rush_cas01,64,168
+
+rush_cas02,259,212,0	warp	rush201	1,1,rush_cas02,72,240
+rush_cas02,75,240,0	warp	rush201-1	1,5,rush_cas02,256,212
+rush_cas02,232,189,0	warp	rush202	1,1,rush_cas02,74,261
+rush_cas02,78,261,0	warp	rush202-1	1,1,rush_cas02,236,189
+rush_cas02,229,208,0	warp	rush203	1,1,rush_cas02,70,282
+rush_cas02,74,282,0	warp	rush203-1	1,1,rush_cas02,225,208
+rush_cas02,7,261,0	warp	rush204	1,1,rush_cas02,55,30
+rush_cas02,59,30,0	warp	rush204-1	1,1,rush_cas02,11,261
+rush_cas02,28,31,0	warp	rush205	1,1,rush_cas02,251,42
+rush_cas02,254,45,0	warp	rush205-1	1,1,rush_cas02,24,31
+
+rush_cas03,194,71,0	warp	rush301	1,1,rush_cas03,129,194
+rush_cas03,125,194,0	warp	rush301-1	1,1,rush_cas03,199,70
+rush_cas03,164,86,0	warp	rush302	1,1,rush_cas03,66,189
+rush_cas03,70,189,0	warp	rush302-1	1,1,rush_cas03,166,81
+rush_cas03,150,67,0	warp	rush303	1,1,rush_cas03,9,187
+rush_cas03,5,187,0	warp	rush303-1	1,1,rush_cas03,151,62
+rush_cas03,165,232,0	warp	rush304	1,1,rush_cas03,193,49
+rush_cas03,188,49,0	warp	rush304-1	1,1,rush_cas03,165,228
+rush_cas03,195,42,0	warp	rush305	1,1,rush_cas03,19,227
+rush_cas03,15,227,0	warp	rush305-1	1,1,rush_cas03,195,46
+rush_cas03,13,175,0	warp	rush306	1,1,rush_cas03,162,194
+rush_cas03,166,194,0	warp	rush306-1	1,1,rush_cas03,13,179
+rush_cas03,156,231,0	warp	rush307	1,1,rush_cas03,18,88
+rush_cas03,14,88,0	warp	rush307-1	1,1,rush_cas03,156,227
+
+rush_cas04,106,217,0	warp	rush407	1,1,rush_cas04,131,15
+rush_cas04,115,210,0	warp	rush408	1,1,rush_cas04,92,215
+rush_cas04,135,15,0	warp	rush407-1	1,1,rush_cas04,110,217
+rush_cas04,135,92,0	warp	rush402-1	1,1,rush_cas04,34,282
+rush_cas04,152,92,0	warp	rush404-1	1,1,rush_cas04,59,255
+rush_cas04,154,16,0	warp	rush414	1,1,rush_cas04,252,11
+rush_cas04,17,206,0	warp	rush406-1	1,1,rush_cas04,29,219
+rush_cas04,212,46,0	warp	rush415	1,1,rush_cas04,225,158
+rush_cas04,225,154,0	warp	rush415-1	1,1,rush_cas04,212,42
+rush_cas04,237,74,0	warp	rush412-1	1,1,rush_cas04,62,213
+rush_cas04,256,11,0	warp	rush414-1	1,1,rush_cas04,159,16
+rush_cas04,266,47,0	warp	rush409-1	1,1,rush_cas04,45,175
+rush_cas04,27,215,0	warp	rush406-2	1,1,rush_cas04,17,202
+rush_cas04,34,286,0	warp	rush402	1,1,rush_cas04,131,92
+rush_cas04,38,243,0	warp	rush406	1,1,rush_cas04,29,219
+rush_cas04,38,259,0	warp	rush403-1	1,1,rush_cas04,43,271
+rush_cas04,42,175,0	warp	rush409	1,1,rush_cas04,266,43
+rush_cas04,43,191,0	warp	rush410-1	1,1,rush_cas04,70,185
+rush_cas04,47,271,0	warp	rush403	1,1,rush_cas04,38,255
+rush_cas04,50,248,0	warp	rush405	1,1,rush_cas04,54,229
+rush_cas04,58,232,0	warp	rush405-1	1,1,rush_cas04,62,213
+rush_cas04,63,255,0	warp	rush404	1,1,rush_cas04,156,92
+rush_cas04,65,215,0	warp	rush412	1,1,rush_cas04,233,74
+rush_cas04,66,223,0	warp	rush401	1,1,rush_cas04,96,53
+rush_cas04,70,182,0	warp	rush410	1,1,rush_cas04,39,191
+rush_cas04,79,244,0	warp	rush413-1	1,1,rush_cas04,91,250
+rush_cas04,88,248,0	warp	rush411-1	1,1,rush_cas04,76,242
+rush_cas04,90,218,0	warp	rush408-1	1,1,rush_cas04,111,210
+rush_cas04,92,53,0	warp	rush401-1	1,1,rush_cas04,62,223
+rush_cas04,93,209,0	warp	rush411	1,1,rush_cas04,92,250
+rush_cas04,95,251,0	warp	rush413	1,1,rush_cas04,91,209
+
+// MapFlags
+// *********************************************************************
+
+rush_cas01	mapflag	battleground	2
+rush_cas01	mapflag	nomemo
+rush_cas01	mapflag	nosave	SavePoint
+rush_cas01	mapflag	noteleport
+rush_cas01	mapflag	nowarp
+rush_cas01	mapflag	nowarpto
+rush_cas01	mapflag	noreturn
+rush_cas01	mapflag	nobranch
+rush_cas01	mapflag	nopenalty
+rush_cas01	mapflag	bg_consume
+rush_cas01	mapflag	novending
+
+rush_cas02	mapflag	battleground	2
+rush_cas02	mapflag	nomemo
+rush_cas02	mapflag	nosave	SavePoint
+rush_cas02	mapflag	noteleport
+rush_cas02	mapflag	nowarp
+rush_cas02	mapflag	nowarpto
+rush_cas02	mapflag	noreturn
+rush_cas02	mapflag	nobranch
+rush_cas02	mapflag	nopenalty
+rush_cas02	mapflag	bg_consume
+rush_cas02	mapflag	novending
+
+rush_cas03	mapflag	battleground	2
+rush_cas03	mapflag	nomemo
+rush_cas03	mapflag	nosave	SavePoint
+rush_cas03	mapflag	noteleport
+rush_cas03	mapflag	nowarp
+rush_cas03	mapflag	nowarpto
+rush_cas03	mapflag	noreturn
+rush_cas03	mapflag	nobranch
+rush_cas03	mapflag	nopenalty
+rush_cas03	mapflag	bg_consume
+rush_cas03	mapflag	novending
+
+rush_cas04	mapflag	battleground	2
+rush_cas04	mapflag	nomemo
+rush_cas04	mapflag	nosave	SavePoint
+rush_cas04	mapflag	noteleport
+rush_cas04	mapflag	nowarp
+rush_cas04	mapflag	nowarpto
+rush_cas04	mapflag	noreturn
+rush_cas04	mapflag	nobranch
+rush_cas04	mapflag	nopenalty
+rush_cas04	mapflag	bg_consume
+rush_cas04	mapflag	novending
diff --git a/npc/custom/eBG/bg_tierra_boss.txt b/npc/custom/eBG/bg_tierra_boss.txt
new file mode 100644
index 0000000..3cd1683
--- /dev/null
+++ b/npc/custom/eBG/bg_tierra_boss.txt
@@ -0,0 +1,417 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  27-01-2023
+// By:
+//  Easycore
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// Battleground Queue Engine
+// *********************************************************************
+
+// ==============================================================================
+// BattleGround System - Tierra Bossnia
+// ==============================================================================*/
+
+-	script	Tierra_Boss	-1,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	.qty_tie = 10;					// Reward amount for draw
+	.qty_bos =  3;					// Extra reward amount for each boss killed
+	.condition = 3;					// How many bosses team must defeat for victory (Min 1 Max 3)
+	// ===========
+	// For Bosses Configurations edit db/import/mob_db_bg.yml
+	end;
+
+OnTeam1Active:
+	warp "bat_cc2",61,120;
+	end;
+OnTeam2Active:
+	warp "bat_cc2",138,63;
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	if (!$@BG_Status) end;
+	bg_desert;
+	end;
+
+OnTeam1Die:
+OnTeam2Die:
+	end;
+
+OnStart:
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+	initnpctimer;
+	.guillaume_boss = 0;
+	.croix_boss = 0;
+	.Neutral_Base = 0;
+	sleep 2000;
+	bg_warp($@BG_Team1,"bat_cc2",61,120);
+	bg_warp($@BG_Team2,"bat_cc2",138,63);
+	sleep 2000;
+	donpcevent "#gtb_respawn::OnBGStart";
+	donpcevent "#ctb_respawn::OnBGStart";
+	bg_updatescore "bat_cc2",.croix_boss,.guillaume_boss;
+	sleep 3000;
+	donpcevent "Balance_Flag::OnBGStart";
+	donpcevent "Guillaume_Boss::OnSummon";
+	donpcevent "Croix_Boss::OnSummon";
+	donpceventall "OnEmblemBOSS";
+	mapannounce "bat_cc2","-- Capture the Balance Flag to remove immunity of Enemy Guardians --",1,0x483D8B;
+	end;
+
+OnNeutralReset:
+	set .Neutral_Base, 0;
+	killmonster "bat_cc2","Tierra_Boss::OnNeutralBreak";
+	setunitdata(getvariableofnpc(.Boss,"Guillaume_Boss"),UMOB_DMGIMMUNE,1);
+	setunitdata(getvariableofnpc(.Boss,"Croix_Boss"),UMOB_DMGIMMUNE,1);
+	set .Flag, bg_monster(0,"bat_cc2",100,92,"Balance Flag",20403,"Tierra_Boss::OnNeutralBreak");
+	sleep 2000;
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_Boss")
+		end;
+	mapannounce "bat_cc2","-- Balance Flag returned to normality --",1,0x483D8B;
+	end;
+
+OnNeutralBreak:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_Boss")
+		end;
+	set .Neutral_Base, getcharid(4);
+	if (getcharid(4) == $@BG_Team1) {
+		mapannounce "bat_cc2","-- Guillaume captured the Balance Flag. Croix guardian is now vulnerable to attacks!! --",1,0x0000FF;
+		setunitdata(getvariableofnpc(.Boss,"Guillaume_Boss"),UMOB_DMGIMMUNE,1);
+		setunitdata(getvariableofnpc(.Boss,"Croix_Boss"),UMOB_DMGIMMUNE,0);
+		showscript("I am vulnerable! Protect me!",getvariableofnpc(.Boss,"Croix_Boss"));
+		set .Flag, bg_monster(.Neutral_Base,"bat_cc2",100,92,"Guillaume Flag",20404,"Tierra_Boss::OnNeutralBreak");
+		setunitdata(.Flag, UMOB_GROUP_ID, 100);
+	} else if (getcharid(4) == $@BG_Team2) {
+		mapannounce "bat_cc2","-- Croix captured the Balance Flag. Guillaume guardian is now vulnerable to attacks!! --",1,0xFF0000;
+		setunitdata(getvariableofnpc(.Boss,"Guillaume_Boss"),UMOB_DMGIMMUNE,0);
+		setunitdata(getvariableofnpc(.Boss,"Croix_Boss"),UMOB_DMGIMMUNE,1);
+		showscript("I am vulnerable! Protect me!",getvariableofnpc(.Boss,"Guillaume_Boss"));
+		set .Flag, bg_monster(.Neutral_Base,"bat_cc2",100,92,"Croix Flag",20405,"Tierra_Boss::OnNeutralBreak");
+		setunitdata(.Flag, UMOB_GROUP_ID, 101);
+	} else {
+		set .Neutral_Base, 0;
+		setunitdata(getvariableofnpc(.Boss,"Guillaume_Boss"),UMOB_DMGIMMUNE,1);
+		setunitdata(getvariableofnpc(.Boss,"Croix_Boss"),UMOB_DMGIMMUNE,1);
+		set .Flag, bg_monster(0,"bat_cc2",100,92,"Balance Flag",20403,"Tierra_Boss::OnNeutralBreak");
+	}
+	bg_rankpoints(BGR_BOSS_FLAGS,1,$@flag_boss);
+	end;
+
+OnTimer600000:
+	mapannounce "bat_cc2","Battle of Tierra Bossnia will end in 5 minutes",1,0x483D8B;
+	end;
+OnTimer840000:
+	mapannounce "bat_cc2","Battle of Tierra Bossnia will end in 1 minute",1,0x483D8B;
+	end;
+
+OnTimer900000:
+OnMatchEnd:
+	stopnpctimer;
+	stopnpctimer "Guillaume_Boss";
+	stopnpctimer "Croix_Boss";
+	donpcevent "#gtb_respawn::OnBGStop";
+	donpcevent "#ctb_respawn::OnBGStop";
+	donpcevent "Balance_Flag::OnBGStop";
+	killmonster "bat_cc2","Guillaume_Boss::OnBoss";
+	killmonster "bat_cc2","Croix_Boss::OnBoss";
+	set $@BG_Status, 2;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if (.guillaume_boss < .croix_boss) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win + (getvariableofnpc(.croix_boss, "Tierra_Boss")*.qty_bos),0,0,"BG_Boss",1,1,0,$@boss_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los + (getvariableofnpc(.guillaume_boss, "Tierra_Boss")*.qty_bos),0,0,"BG_Boss",1,1,2,$@boss_los);
+		mapannounce "bat_cc2","The Guillaume army has won the Battle of Tierra Bossnia!",1,0x0000FF;
+	} else if (.guillaume_boss > .croix_boss) {
+		bg_reward($@BG_Team1,.reward_id,.qty_los + (getvariableofnpc(.croix_boss, "Tierra_Boss")*.qty_bos),0,0,"BG_Boss",1,1,2,$@boss_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win + (getvariableofnpc(.guillaume_boss, "Tierra_Boss")*.qty_bos),0,0,"BG_Boss",1,1,0,$@boss_win);
+		mapannounce "bat_cc2","The Croix army has won the Battle of Tierra Bossnia!",1,0xFF0000;
+	} else {
+		bg_reward($@BG_Team1,.reward_id,.qty_tie + (getvariableofnpc(.croix_boss, "Tierra_Boss")*.qty_bos),0,0,"BG_Boss",1,1,1,$@boss_tie);
+		bg_reward($@BG_Team2,.reward_id,.qty_tie + (getvariableofnpc(.guillaume_boss, "Tierra_Boss")*.qty_bos),0,0,"BG_Boss",1,1,1,$@boss_tie);
+		mapannounce "bat_cc2","The battle is over. This is a Tie...!",1,0x483D8B;
+	}
+	// =======================================================
+	set .Neutral_Base, 0;
+	set .guillaume_boss, 0;
+	set .croix_boss, 0;
+	sleep 5000;
+	donpcevent "Tierra_Boss::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	end;
+OnEnd:
+	sleep 1000;
+	mapwarp "bat_cc2","bat_room",154,150;
+	bg_updatescore "bat_cc2",50,50;
+	bg_updatescore "bat_cc2",.croix_boss,.guillaume_boss;
+	end;
+}
+
+-	script	Guillaume_Boss	-1,{
+	end;
+
+OnSummon:
+	set .@Boss, 21406 + getvariableofnpc(.guillaume_boss, "Tierra_Boss");
+	mapannounce "bat_cc2","-- Guillaume Guardian [" + strmobinfo(2,.@Boss) + "] entering the battle --",1,0x0000FF;
+	set .Boss, bg_monster($@BG_Team1,"bat_cc2",53,128,"Guillaume Guardian",.@Boss,"Guillaume_Boss::OnBoss");
+	setunitdata(.Boss,UMOB_DMGIMMUNE,1);
+	setunitdata(.Boss, UMOB_GROUP_ID, 100);
+	switch(.@Boss) {
+		case 21406: setunittitle(.Boss,"[First Guardian]"); break;
+		case 21407: setunittitle(.Boss,"[Second Guardian]"); break;
+		case 21408: setunittitle(.Boss,"[Last Guardian]"); break;
+	}
+	initnpctimer;
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if (.Boss) {
+		bg_monster_reveal .Boss,1,0x0000FF;
+		getunitdata(.Boss, .@mobdata);
+		.btick++;
+		if (.btick > 4 && distance(54,127,.@mobdata[UMOB_X],.@mobdata[UMOB_Y]) > 15) {
+			unitwarp(.Boss, "this", 54, 127);
+			.btick = 0;
+		} else if (.btick > 4)
+			.btick = 0;
+		initnpctimer;
+	}
+	end;
+
+OnBoss:
+	stopnpctimer;
+	bg_monster_reveal .Boss,2,0x0000FF; // Hide Spot
+	set getvariableofnpc(.guillaume_boss, "Tierra_Boss"), getvariableofnpc(.guillaume_boss, "Tierra_Boss") + 1;
+	bg_updatescore "bat_cc2",getvariableofnpc(.croix_boss,"Tierra_Boss"),getvariableofnpc(.guillaume_boss,"Tierra_Boss");
+	set .Boss, 0;
+	if (playerattached())
+		bg_rankpoints(BGR_BOSS_KILLED,1,$@boss_killed);
+	if (getvariableofnpc(.guillaume_boss, "Tierra_Boss") >= getvariableofnpc(.condition,"Tierra_Boss"))
+		donpcevent "Tierra_Boss::OnMatchEnd";
+	else
+	{
+		donpcevent "Guillaume_Boss::OnSummon";
+		donpcevent "Tierra_Boss::OnNeutralReset";
+	}
+	end;
+}
+
+-	script	Croix_Boss	-1,{
+	end;
+
+OnSummon:
+	set .@Boss, 21406 + getvariableofnpc(.croix_boss, "Tierra_Boss");
+	mapannounce "bat_cc2","-- Croix Guardian [" + strmobinfo(2,.@Boss) + "] entering the battle --",1,0xFF0000;
+	set .Boss, bg_monster($@BG_Team2,"bat_cc2",146,55,"Croix Guardian",.@Boss,"Croix_Boss::OnBoss");
+	setunitdata(.Boss,UMOB_DMGIMMUNE,1);
+	setunitdata(.Boss, UMOB_GROUP_ID, 101);
+	switch(.@Boss) {
+		case 21406: setunittitle(.Boss,"[First Guardian]"); break;
+		case 21407: setunittitle(.Boss,"[Second Guardian]"); break;
+		case 21408: setunittitle(.Boss,"[Last Guardian]"); break;
+	}
+	initnpctimer;
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if (.Boss) {
+		bg_monster_reveal .Boss,1,0xFF0000;
+		getunitdata(.Boss, .@mobdata);
+		.btick++;
+		if (.btick > 4 && distance(146,55,.@mobdata[UMOB_X],.@mobdata[UMOB_Y]) > 15) {
+			unitwarp(.Boss, "this", 146, 55);
+			.btick = 0;
+		} else if (.btick > 4)
+			.btick = 0;
+		initnpctimer;
+	}
+	end;
+
+OnBoss:
+	stopnpctimer;
+	bg_monster_reveal .Boss,2,0xFF0000; // Hide Spot
+	set getvariableofnpc(.croix_boss, "Tierra_Boss"), getvariableofnpc(.croix_boss, "Tierra_Boss") + 1;
+	bg_updatescore "bat_cc2",getvariableofnpc(.croix_boss,"Tierra_Boss"),getvariableofnpc(.guillaume_boss,"Tierra_Boss");
+	set .Boss, 0;
+	if (playerattached())
+		bg_rankpoints(BGR_BOSS_KILLED,1,$@boss_killed);
+	if (getvariableofnpc(.croix_boss, "Tierra_Boss") >= getvariableofnpc(.condition,"Tierra_Boss"))
+		donpcevent "Tierra_Boss::OnMatchEnd";
+	else
+	{
+		donpcevent "Croix_Boss::OnSummon";
+		donpcevent "Tierra_Boss::OnNeutralReset";
+	}
+	end;
+}
+
+-	script	Balance_Flag	-1,{
+	end;
+
+OnBGStart:
+	viewpointmap "bat_cc2",1,100,92,1,0xFFFFFF;
+	bg_monster 0,"bat_cc2",100,92,"Balance Flag",20403,"Tierra_Boss::OnNeutralBreak";
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	viewpointmap "bat_cc2",2,100,92,1,0xFFFFFF;
+	killmonster "bat_cc2","Tierra_Boss::OnNeutralBreak";
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	set .@NB, getvariableofnpc(.Neutral_Base,"Tierra_Boss");
+	if (.@NB == $@BG_Team1)
+		viewpointmap "bat_cc2",1,100,92,1,0x0000FF;
+	else if (.@NB == $@BG_Team2)
+		viewpointmap "bat_cc2",1,100,92,1,0xFF0000;
+	else
+		viewpointmap "bat_cc2",1,100,92,1,0xFFFFFF;
+	end;
+}
+
+// MapFlags
+// *********************************************************************
+
+bat_cc2	mapflag	battleground	2
+bat_cc2	mapflag	nomemo
+bat_cc2	mapflag	nosave	SavePoint
+bat_cc2	mapflag	noteleport
+bat_cc2	mapflag	nowarp
+bat_cc2	mapflag	nowarpto
+bat_cc2	mapflag	noreturn
+bat_cc2	mapflag	nobranch
+bat_cc2	mapflag	nopenalty
+bat_cc2	mapflag	noloot
+bat_cc2	mapflag	bg_nomobmove
+
+// Other Flags
+// *********************************************************************
+bat_cc2,88,146,4	script	Flag#BOSS_Blue	GUILD_FLAG,{
+	end;
+OnEmblemBOSS:
+	bg_flagemblem($@BG_Team1);
+	end;
+}
+bat_cc2,97,146,4	script	Flag#BOSS_Red	GUILD_FLAG,{
+	end;
+OnEmblemBOSS:
+	bg_flagemblem($@BG_Team2);
+	end;
+}
+
+bat_cc2,139,53,1	duplicate(Base Flag#bg)	Croix Base#tb_1	974
+bat_cc2,149,62,4	duplicate(Base Flag#bg)	Croix Base#tb_2	974
+bat_cc2,50,121,1	duplicate(Base Flag#bg)	Guillaume Base#tb_1	973
+bat_cc2,60,131,1	duplicate(Base Flag#bg)	Guillaume Base#tb_2	973
+
+// Battleground Respawn
+// *********************************************************************
+
+bat_cc2,88,143,5	script	Therapist in battle#boss1	4_F_SISTER,{
+	getmapxy(.@map$,.@x,.@y, BL_PC);
+	if (distance(.@x,.@y,88,143) > 6)
+		end;
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setcell("bat_cc2",85,134,92,146,CELL_BASILICA,1);
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+bat_cc2,97,143,3	script	Therapist in battle#boss2	4_F_SISTER,{
+	getmapxy(.@map$,.@x,.@y, BL_PC);
+	if (distance(.@x,.@y,97,143) > 6)
+		end;
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setcell("bat_cc2",93,134,100,146,CELL_BASILICA,1);
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+bat_cc2,88,139,0	script	#gtb_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#boss1"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_cc2",85,134,92,146,100,100;
+		areawarp "bat_cc2",85,134,92,146,"bat_cc2",54,127;
+	}
+	initnpctimer;
+	end;
+}
+
+bat_cc2,96,139,0	script	#ctb_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#boss2"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_cc2",93,134,100,146,100,100;
+		areawarp "bat_cc2",93,134,100,146,"bat_cc2",146,55;
+	}
+	initnpctimer;
+	end;
+}
\ No newline at end of file
diff --git a/npc/custom/eBG/bg_tierra_dom.txt b/npc/custom/eBG/bg_tierra_dom.txt
new file mode 100644
index 0000000..58ed2ee
--- /dev/null
+++ b/npc/custom/eBG/bg_tierra_dom.txt
@@ -0,0 +1,740 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  13-02-2023
+// By:
+//  Easycore         (Zephyrus, original author)
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Tierra Domination
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Tierra_DOM	FAKE_NPC,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	.qty_tie = 10;					// Reward amount for draw
+	.condition = 99;				// How much score to win
+	.tick = 5;						// How many seconds to get 1pt when a base is captured
+	// ===========
+	end;
+
+OnTeam1Active:
+	warp "bat_a04",353,344;
+	end;
+OnTeam2Active:
+	warp "bat_a04",353,52;
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert;
+	end;
+
+OnTeamDie:
+	// Check for Offensive or Defensive Kills
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_DOM" || killerid == 0)
+		end;
+
+	set .@Base, 0;
+	getmapxy .@m$, .@x, .@y, BL_PC;
+
+	if (.@x >= 136 && .@y >= 329 && .@x <= 186 && .@y <= 361)
+		set .@Base, getvariableofnpc(.Owner,"Dom_N_Base"); // North
+	else if (.@x >= 260 && .@y >= 194 && .@x <= 287 && .@y <= 213)
+		set .@Base, getvariableofnpc(.Owner,"Dom_C_Base"); // Center
+	else if (.@x >= 129 && .@y >= 34 && .@x <= 175 && .@y <= 65)
+		set .@Base, getvariableofnpc(.Owner,"Dom_S_Base"); // South
+	else end; // Not Killed on Base territory
+
+	if (.@Base == 1) { // Team 1
+		if (getcharid(4) == $@BG_Team1)
+			bg_rankpoints(BGR_DOM_OFF_KILLS,$@dom_off_kill,killerid);
+		else
+			bg_rankpoints(BGR_DOM_DEF_KILLS,$@dom_def_kill,killerid);
+	}
+	else if (.@Base == 2) { // Team 2
+		if (getcharid(4) == $@BG_Team2)
+			bg_rankpoints(BGR_DOM_OFF_KILLS,1,killerid);
+		else
+			bg_rankpoints(BGR_DOM_DEF_KILLS,1,killerid);
+	}
+	end;
+
+OnStart:
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+	initnpctimer;
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	bg_updatescore "bat_a04",.Team1_Score,.Team2_Score;
+	donpcevent "Dom_N_Base::OnBase";
+	donpcevent "Dom_S_Base::OnBase";
+	donpcevent "Dom_C_Base::OnBase";
+	sleep 2100;
+	bg_warp $@BG_Team1,"bat_a04",353,344;
+	bg_warp $@BG_Team2,"bat_a04",353,52;
+	sleep 2100;
+	donpcevent "#guiDOM_respawn::OnBGStart";
+	donpcevent "#croDOM_respawn::OnBGStart";
+	mapannounce "bat_a04","Capture the bases to achieve victory!",1,$@BG_Color$[$@BG_Index];
+	end;
+
+OnNScore:
+	if (set(.@North, getvariableofnpc(.Owner,"Dom_N_Base")) == 0)
+		end; // No Owner
+
+	if (.@North == 1)
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_DOM::OnValidateScore";
+	end;
+
+OnSScore:
+	if (set(.@South, getvariableofnpc(.Owner,"Dom_S_Base")) == 0)
+		end; // No Owner
+
+	if (.@South == 1)
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_DOM::OnValidateScore";
+	end;
+
+OnCScore:
+	if (set(.@Center, getvariableofnpc(.Owner,"Dom_C_Base")) == 0)
+		end; // No Owner
+
+	if (.@Center == 1)
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_DOM::OnValidateScore";
+	end;
+
+OnTimer600000:
+	mapannounce "bat_a04","The Battle will end in 5 minutes!!",1,0x9ACD32;
+	end;
+
+OnTimer840000:
+	mapannounce "bat_a04","The Battle will end in 1 minute!!",1,0x9ACD32;
+	end;
+
+OnValidateScore:
+	if (.Team1_Score >= .condition)
+		set .Team1_Score, .condition;
+	if (.Team2_Score >= .condition)
+		set .Team2_Score, .condition;
+
+	bg_updatescore "bat_a04",.Team1_Score,.Team2_Score; // Update Visual Score
+
+	if (.Team1_Score < .condition && .Team2_Score < .condition)
+		end; // No winners
+
+OnTimer900000:
+OnMatchEnd:
+	stopnpctimer "Dom_N_Base";
+	stopnpctimer "Dom_S_Base";
+	stopnpctimer "Dom_C_Base";
+	donpcevent "#guiDOM_respawn::OnBGStop";
+	donpcevent "#croDOM_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	.@reward_win = 5;
+	.@reward_lose = 3;
+
+	// Tie
+	if (.Team1_Score == .Team2_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_tie,0,0,"BG_DOM",1,8,1,$@dom_tie);
+		bg_reward($@BG_Team2,.reward_id,.qty_tie,0,0,"BG_DOM",1,8,1,$@dom_tie);
+		mapannounce "bat_a04","The battle is over. This is a Tie...!",1,$@BG_Color$[$@BG_Index];
+	}
+	// Team 1 Won
+	else if (.Team1_Score >= .Team2_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"BG_DOM",1,8,0,$@dom_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los,0,0,"BG_DOM",1,8,2,$@dom_los);
+		mapannounce "bat_a04","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Tierra Domination!",1,bg_get_data($@BG_Team1,4);
+	}
+	// Team 2 Won
+	else if (.Team2_Score >= .Team1_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_los,0,0,"BG_DOM",1,8,2,$@dom_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"BG_DOM",1,8,0,$@dom_win);
+		mapannounce "bat_a04","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Tierra Domination!",1,bg_get_data($@BG_Team2,4);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	donpcevent "Tierra_DOM::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	donpcevent "GDomNBW::OnDisable";
+	donpcevent "GDomCBW::OnDisable";
+	donpcevent "GDomSBW::OnDisable";
+	donpcevent "CDomNBW::OnDisable";
+	donpcevent "CDomCBW::OnDisable";
+	donpcevent "CDomSBW::OnDisable";
+	end;
+OnEnd:
+	sleep 1000;
+	mapwarp "bat_a04","bat_room",154,150;
+	bg_updatescore "bat_a04",0,0;
+	end;
+}
+
+// Battleground Bases
+// *********************************************************************
+
+bat_a04,173,345,0	script	North Base::Dom_N_Base	1911,{
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	set .ScoreTick, getvariableofnpc(.tick,"Tierra_DOM");
+	setnpcdisplay "Dom_N_Base","North Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_DOM")
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bat_a04",136,329,186,361);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bat_a04",136,329,186,361);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if (.Balance < -50)
+		set .Balance, -50;
+	else if (.Balance > 50)
+		set .Balance, 50;
+
+	switch(.Owner) {
+		case 0:
+			if (.Balance == 50) {
+				set .Balance, 50;
+				set .Owner, 1; // Team 1
+				setnpcdisplay "Dom_N_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+				mapannounce "bat_a04","North Base captured by " + bg_get_data($@BG_Team1,2),1,bg_get_data($@BG_Team1,4);
+				bg_rankpoints_area($@BG_Team1,"bat_a04",136,329,186,361,BGR_DOM_BASES,1,5);
+				donpcevent "GDomNBW::OnEnable";
+			}
+			else if (.Balance == -50) {
+				set .Balance, -50;
+				set .Owner, 2; // Team 2
+				setnpcdisplay "Dom_N_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+				mapannounce "bat_a04","North Base captured by " + bg_get_data($@BG_Team2,2),1,bg_get_data($@BG_Team2,4);
+				bg_rankpoints_area($@BG_Team2,"bat_a04",136,329,186,361,BGR_DOM_BASES,1,5);
+				donpcevent "CDomNBW::OnEnable";
+			}
+			break;
+		case 1:
+			if (.Balance <= 0) { // Team 1 lost Control
+				set .Owner, 0;
+				setnpcdisplay "Dom_N_Base","North Base",1911;
+				mapannounce "bat_a04",bg_get_data($@BG_Team1,2) + " lost control of the North Base",1,bg_get_data($@BG_Team1,4);
+				donpcevent "GDomNBW::OnDisable";
+			}
+			break;
+		case 2:
+			if (.Balance >= 0) { // Team 2 lost Control
+				set .Owner, 0;
+				setnpcdisplay "Dom_N_Base","North Base",1911;
+				mapannounce "bat_a04",bg_get_data($@BG_Team2,2) + " lost control of the North Base",1,bg_get_data($@BG_Team2,4);
+				donpcevent "CDomNBW::OnDisable";
+			}
+			break;
+	}
+
+	if (.@Balance > 0)
+		specialeffect 236;
+	else if (.@Balance < 0)
+		specialeffect 225;
+	else if (.Owner == 1)
+		specialeffect 236;
+	else if (.Owner == 2)
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	if (.Balance > 0) {
+		.@team$ = "Blue Team";
+		.@percent = .Balance;
+	}
+	else if (.Balance < 0) {
+		.@team$ = "Red Team";
+		.@percent = .Balance * -1;
+	}
+	else if (.Balance == 0) {
+		.@team$ = "Neutral";
+		.@percent = 0;
+	}
+
+	if (.@Balance == 0 && .@Team1Count && .@Team2Count)
+		showscript(.@team$+" : "+(.@percent*2)+"% (Contest!)",getnpcid(0));
+	else if ((.Balance > 0 && .Balance != 50) || (.Balance < 0 && .Balance != -50))
+		showscript(.@team$+" : "+(.@percent*2)+"%",getnpcid(0));
+
+	switch(.Owner) {
+		case 0: viewpointmap2 "bat_a04",1,173,345,1,0xFFFFFF; break;
+		case 1: viewpointmap2 "bat_a04",1,173,345,1,bg_get_data($@BG_Team1,4); break;
+		case 2: viewpointmap2 "bat_a04",1,173,345,1,bg_get_data($@BG_Team2,4); break;
+	}
+
+	if (.Owner == 0)
+		set .Tick, 0;
+	else if (set(.Tick, .Tick + 1) == .ScoreTick) {
+		donpcevent "Tierra_DOM::OnNScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+bat_a04,273,204,0	script	Center Base::Dom_C_Base	1911,{
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	set .ScoreTick, getvariableofnpc(.tick,"Tierra_DOM");
+	setnpcdisplay "Dom_C_Base","Center Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_DOM")
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bat_a04",260,194,287,213);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bat_a04",260,194,287,213);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if (.Balance < -50)
+		set .Balance, -50;
+	else if (.Balance > 50)
+		set .Balance, 50;
+
+	switch(.Owner) {
+		case 0:
+			if (.Balance == 50) {
+				set .Balance, 50;
+				set .Owner, 1; // Team 1
+				setnpcdisplay "Dom_C_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+				mapannounce "bat_a04","Center Base captured by " + bg_get_data($@BG_Team1,2),1,bg_get_data($@BG_Team1,4);
+				bg_rankpoints_area($@BG_Team1,"bat_a04",260,194,287,213,BGR_DOM_BASES,1,5);
+				donpcevent "GDomCBW::OnEnable";
+			}
+			else if (.Balance == -50) {
+				set .Balance, -50;
+				set .Owner, 2; // Team 2
+				setnpcdisplay "Dom_C_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+				mapannounce "bat_a04","Center Base captured by " + bg_get_data($@BG_Team2,2),1,bg_get_data($@BG_Team2,4);
+				bg_rankpoints_area($@BG_Team2,"bat_a04",260,194,287,213,BGR_DOM_BASES,1,5);
+				donpcevent "CDomCBW::OnEnable";
+			}
+			break;
+		case 1:
+			if (.Balance <= 0) { // Team 1 lost Control
+				set .Owner, 0;
+				setnpcdisplay "Dom_C_Base","Center Base",1911;
+				mapannounce "bat_a04",bg_get_data($@BG_Team1,2) + " lost control of the Center Base",1,bg_get_data($@BG_Team1,4);
+				donpcevent "GDomCBW::OnDisable";
+			}
+			break;
+		case 2:
+			if (.Balance >= 0) { // Team 2 lost Control
+				set .Owner, 0;
+				setnpcdisplay "Dom_C_Base","Center Base",1911;
+				mapannounce "bat_a04",bg_get_data($@BG_Team2,2) + " lost control of the Center Base",1,bg_get_data($@BG_Team2,4);
+				donpcevent "CDomCBW::OnDisable";
+			}
+			break;
+	}
+
+	if (.@Balance > 0)
+		specialeffect 236;
+	else if (.@Balance < 0)
+		specialeffect 225;
+	else if (.Owner == 1)
+		specialeffect 236;
+	else if (.Owner == 2)
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	if (.Balance > 0) {
+		.@team$ = "Blue Team";
+		.@percent = .Balance;
+	}
+	else if (.Balance < 0) {
+		.@team$ = "Red Team";
+		.@percent = .Balance * -1;
+	}
+	else if (.Balance == 0) {
+		.@team$ = "Neutral";
+		.@percent = 0;
+	}
+
+	if (.@Balance == 0 && .@Team1Count && .@Team2Count)
+		showscript(.@team$+" : "+(.@percent*2)+"% (Contest!)",getnpcid(0));
+	else if ((.Balance > 0 && .Balance != 50) || (.Balance < 0 && .Balance != -50))
+		showscript(.@team$+" : "+(.@percent*2)+"%",getnpcid(0));
+
+	switch(.Owner) {
+		case 0: viewpointmap2 "bat_a04",1,273,204,3,0xFFFFFF; break;
+		case 1: viewpointmap2 "bat_a04",1,273,204,3,bg_get_data($@BG_Team1,4); break;
+		case 2: viewpointmap2 "bat_a04",1,273,204,3,bg_get_data($@BG_Team2,4); break;
+	}
+
+	if (.Owner == 0)
+		set .Tick, 0;
+	else if (set(.Tick, .Tick + 1) == .ScoreTick) {
+		donpcevent "Tierra_DOM::OnCScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+bat_a04,164,50,0	script	South Base::Dom_S_Base	1911,{
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	set .ScoreTick, getvariableofnpc(.tick,"Tierra_DOM");
+	setnpcdisplay "Dom_S_Base","South Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_DOM")
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bat_a04",129,34,175,65);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bat_a04",129,34,175,65);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if (.Balance < -50)
+		set .Balance, -50;
+	else if (.Balance > 50)
+		set .Balance, 50;
+
+	switch(.Owner) {
+		case 0:
+			if (.Balance == 50) {
+				set .Balance, 50;
+				set .Owner, 1; // Team 1
+				setnpcdisplay "Dom_S_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+				mapannounce "bat_a04","South Base captured by " + bg_get_data($@BG_Team1,2),1,bg_get_data($@BG_Team1,4);
+				bg_rankpoints_area($@BG_Team1,"bat_a04",129,34,175,65,BGR_DOM_BASES,1,5);
+				donpcevent "GDomSBW::OnEnable";
+			}
+			else if (.Balance == -50) {
+				set .Balance, -50;
+				set .Owner, 2; // Team 2
+				setnpcdisplay "Dom_S_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+				mapannounce "bat_a04","South Base captured by " + bg_get_data($@BG_Team2,2),1,bg_get_data($@BG_Team2,4);
+				bg_rankpoints_area($@BG_Team2,"bat_a04",129,34,175,65,BGR_DOM_BASES,1,5);
+				donpcevent "CDomSBW::OnEnable";
+			}
+			break;
+		case 1:
+			if (.Balance <= 0) { // Team 1 lost Control
+				set .Owner, 0;
+				setnpcdisplay "Dom_S_Base","North Base",1911;
+				mapannounce "bat_a04",bg_get_data($@BG_Team1,2) + " lost control of the South Base",1,bg_get_data($@BG_Team1,4);
+				donpcevent "GDomSBW::OnDisable";
+			}
+			break;
+		case 2:
+			if (.Balance >= 0) { // Team 2 lost Control
+				set .Owner, 0;
+				setnpcdisplay "Dom_S_Base","North Base",1911;
+				mapannounce "bat_a04",bg_get_data($@BG_Team2,2) + " lost control of the South Base",1,bg_get_data($@BG_Team2,4);
+				donpcevent "CDomSBW::OnDisable";
+			}
+			break;
+	}
+
+	if (.@Balance > 0)
+		specialeffect 236;
+	else if (.@Balance < 0)
+		specialeffect 225;
+	else if (.Owner == 1)
+		specialeffect 236;
+	else if (.Owner == 2)
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	if (.Balance > 0) {
+		.@team$ = "Blue Team";
+		.@percent = .Balance;
+	}
+	else if (.Balance < 0) {
+		.@team$ = "Red Team";
+		.@percent = .Balance * -1;
+	}
+	else if (.Balance == 0) {
+		.@team$ = "Neutral";
+		.@percent = 0;
+	}
+
+	if (.@Balance == 0 && .@Team1Count && .@Team2Count)
+		showscript(.@team$+" : "+(.@percent*2)+"% (Contest!)",getnpcid(0));
+	else if ((.Balance > 0 && .Balance != 50) || (.Balance < 0 && .Balance != -50))
+		showscript(.@team$+" : "+(.@percent*2)+"%",getnpcid(0));
+
+	switch(.Owner) {
+		case 0: viewpointmap2 "bat_a04",1,164,50,2,0xFFFFFF; break;
+		case 1: viewpointmap2 "bat_a04",1,164,50,2,bg_get_data($@BG_Team1,4); break;
+		case 2: viewpointmap2 "bat_a04",1,164,50,2,bg_get_data($@BG_Team2,4); break;
+	}
+
+	if (.Owner == 0)
+		set .Tick, 0;
+	else if (set(.Tick, .Tick + 1) == .ScoreTick) {
+		donpcevent "Tierra_DOM::OnSScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+bat_a04,53,377,3	script	Therapist in battle#DOM2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+bat_a04,45,18,3	script	Therapist in battle#DOM1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+bat_a04,46,377,0	script	North Base Warp::GDomNBW	1_SHADOW_NPC,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bat_a04",115,346,20;
+	end;
+}
+
+bat_a04,46,370,0	script	Center Base Warp::GDomCBW	1_SHADOW_NPC,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bat_a04",285,226,20;
+	end;
+}
+
+bat_a04,53,370,0	script	South Base Warp::GDomSBW	1_SHADOW_NPC,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bat_a04",106,48,20;
+	end;
+}
+
+// *********************************************************************
+
+bat_a04,38,19,0	script	North Base Warp::CDomNBW	1_SHADOW_NPC,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bat_a04",115,346,20;
+	end;
+}
+
+bat_a04,38,12,0	script	Center Base Warp::CDomCBW	1_SHADOW_NPC,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+OnWarp:
+	warpwaitingpc "bat_a04",260,183,20;
+	end;
+}
+
+bat_a04,45,12,0	script	South Base Warp::CDomSBW	1_SHADOW_NPC,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bat_a04",106,48,20;
+	end;
+}
+
+// *********************************************************************
+
+bat_a04,50,374,0	script	#guiDOM_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#DOM1"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_a04",46,370,54,378,100,100;
+		donpcevent "GDomNBW::OnWarp";
+		donpcevent "GDomCBW::OnWarp";
+		donpcevent "GDomSBW::OnWarp";
+		areawarp "bat_a04",46,370,54,378,"bat_a04",353,344;
+	}
+	initnpctimer;
+	end;
+}
+
+bat_a04,42,16,0	script	#croDOM_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 25) .tick = 0;
+	showscript("Respawn in : "+(25-.tick)+" seconds",getnpcid(0,"Therapist in battle#DOM2"));
+	if (.tick == 24)
+		specialeffect 83;
+	else if (.tick == 25) {
+		areapercentheal "bat_a04",38,12,47,21,100,100;
+		donpcevent "GDomNBW::OnWarp";
+		donpcevent "GDomCBW::OnWarp";
+		donpcevent "GDomSBW::OnWarp";
+		areawarp "bat_a04",38,12,47,21,"bat_a04",353,52;
+	}
+	initnpctimer;
+	end;
+}
+
+// MapFlags
+// *********************************************************************
+
+bat_a04	mapflag	battleground	2
+bat_a04	mapflag	nomemo
+bat_a04	mapflag	nosave	SavePoint
+bat_a04	mapflag	noteleport
+bat_a04	mapflag	nowarp
+bat_a04	mapflag	nowarpto
+bat_a04	mapflag	noreturn
+bat_a04	mapflag	nobranch
+bat_a04	mapflag	nopenalty
+bat_a04	mapflag	noecall
+bat_a04	mapflag	bg_consume
+bat_a04	mapflag	novending
diff --git a/npc/custom/eBG/bg_tierra_ti.txt b/npc/custom/eBG/bg_tierra_ti.txt
new file mode 100644
index 0000000..bfb5ffd
--- /dev/null
+++ b/npc/custom/eBG/bg_tierra_ti.txt
@@ -0,0 +1,389 @@
+//===== rAthena Script =======================================
+//    Extended Battleground
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+// Date:
+//  11-02-2023
+// By:
+//  Easycore
+//
+// Contact:
+//    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+//    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+//    - Discord:  Easycore#9709
+//= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+
+// ==============================================================================
+// BattleGround System - Tierra Double Infierno
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Tierra_TI	-1,{
+	end;
+
+OnInit:
+	// Configuration
+	.reward_id = 7773;				// Item ID for reward (default War Badge)
+	.qty_win = 20;					// Reward amount for winners
+	.qty_los = 10;					// Reward amount for losers
+	.qty_tie = 10;					// Reward amount for draw
+	.condition = 50;				// How much score for win condition
+	// ===========
+	setwall "region_8",46,85,8,6,0,"ti_wall_a";
+	setwall "region_8",46,74,8,6,0,"ti_wall_a2";
+	setwall "region_8",14,46,8,0,0,"ti_wall_b";
+	setwall "region_8",25,46,8,0,0,"ti_wall_b2";
+	setwall "region_8",85,46,8,0,0,"ti_wall_c";
+	setwall "region_8",74,46,8,0,0,"ti_wall_c2";
+	end;
+
+OnTeam1Active:
+	warp "region_8",10,49;
+	end;
+OnTeam2Active:
+	warp "region_8",89,49;
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert;
+	end;
+
+OnTeamDie:
+	if ($@BG_Status == 1 && $@BG_Current$ == "Tierra_TI") {
+		// Killed Position
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		.@bg_id = getcharid(4);
+		// Current Skulls
+		.@id8965 = countitem(8965);
+		.@id8966 = countitem(8966);
+		// Remove Skulls
+		if (.@id8965) delitem 8965,.@id8965;
+		if (.@id8966) delitem 8966,.@id8966;
+		// Drop Skulls
+		if (.@id8965) {
+			for(.@i = 0; .@i < .@id8965; .@i++)
+				makeitem 8965,1,"region_8",.@x,.@y;
+		}
+		if (.@id8966) {
+			for(.@i = 0; .@i < .@id8966; .@i++)
+				makeitem 8966,1,"region_8",.@x,.@y;
+		}
+		// Drop a New Skull
+		if (!killerid) {
+			if (.@bg_id == $@BG_Team1)
+				makeitem 8965,1,"region_8",.@x,.@y;
+			else if (.@bg_id == $@BG_Team2)
+				makeitem 8966,1,"region_8",.@x,.@y;
+		}
+	}
+	end;
+
+OnStart:
+	announce "Battleground -- " + $@BG_C_Name$ + " has started!.",bc_all,$@BG_Color$[$@BG_Index];
+	$@BG_Status = 1;
+	$@BG_Current$ = $@BG_Names$[($@BG_Index*2)];
+
+	initnpctimer;
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	donpceventall "OnEmblemTI";
+	sleep 2100;
+	bg_warp $@BG_Team1,"region_8",29,49;
+	bg_warp $@BG_Team2,"region_8",70,50;
+	sleep 2100;
+	mapannounce "region_8","Defeat enemies, collect their skulls and sacrifice them!",bc_map,$@BG_Color$[$@BG_Index];
+	donpcevent "#gti_respawn::OnBGStart";
+	donpcevent "#cti_respawn::OnBGStart";
+	donpcevent "BlueTotem::OnStart";
+	donpcevent "RedTotem::OnStart";
+	sleep 1000;
+	bg_team_reveal $@BG_Team1,true;
+	bg_team_reveal $@BG_Team2,true;
+	bg_updatescore "region_8",.Team1_Score,.Team2_Score;
+	end;
+
+OnValidateScore:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_TI")
+		end;
+	bg_updatescore "region_8",.Team1_Score,.Team2_Score;
+	if (.Team1_Score >= .condition || .Team2_Score >= .condition)
+		donpcevent "Tierra_TI::OnMatchEnd";
+	end;
+
+OnTimer600000:
+	mapannounce "region_8","The Battle will ends in 5 minutes!!",1,0x696969;
+	end;
+
+OnTimer840000:
+	mapannounce "region_8","The Battle will ends in 1 minute!!",1,0x696969;
+	end;
+
+OnTimer900000:
+OnMatchEnd:
+	stopnpctimer;
+	cleanmap "region_8"; // Removes all ground items
+	donpcevent "#gti_respawn::OnBGStop";
+	donpcevent "#cti_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if (.Team1_Score > .Team2_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_win,0,0,"BG_TI",1,2,0,$@ti_win);
+		bg_reward($@BG_Team2,.reward_id,.qty_los,0,0,"BG_TI",1,2,2,$@ti_los);
+		mapannounce "region_8","The " + bg_get_data($@BG_Team1,2) + " has won the Battle of Tierra Inferno!",1,bg_get_data($@BG_Team1,4);
+	}
+	else if (.Team2_Score > .Team1_Score) {
+		bg_reward($@BG_Team1,.reward_id,.qty_los,0,0,"BG_TI",1,2,2,$@ti_los);
+		bg_reward($@BG_Team2,.reward_id,.qty_win,0,0,"BG_TI",1,2,0,$@ti_win);
+		mapannounce "region_8","The " + bg_get_data($@BG_Team1,2) + " has won the Battle of Tierra Inferno!",1,bg_get_data($@BG_Team2,4);
+	}
+	else {
+		bg_reward($@BG_Team1,.reward_id,.qty_tie,0,0,"BG_TI",1,2,1,$@tie_tie);
+		bg_reward($@BG_Team2,.reward_id,.qty_tie,0,0,"BG_TI",1,2,1,$@tie_tie);
+		mapannounce "region_8","The battle is over. There are no Winners!",1,0x696969;
+	}
+	// =======================================================
+	.Team1_Score = 0;
+	.Team2_Score = 0;
+	sleep 5000;
+	donpcevent "Tierra_TI::OnEnd";
+	donpcevent "BG_Core::OnEnd";
+	donpcevent "BlueTotem::OnStop";
+	donpcevent "RedTotem::OnStop";
+	end;
+OnEnd:
+	sleep 1000;
+	mapwarp "region_8","bat_room",154,150;
+	bg_updatescore "region_8",0,0;
+	end;
+}
+
+region_8,28,42,0	script	Sacrifice Totem::BlueTotem	HIDDEN_NPC,2,2,{
+	if (getcharid(4) == $@BG_Team1)
+		message(strcharinfo(0),"Approach the totem to sacrifice your skulls!");
+	end;
+
+OnStart:
+	initnpctimer;
+	end;
+OnStop:
+	stopnpctimer;
+	end;
+OnTimer1000:
+	specialeffect 236,AREA,"BlueTotem";
+	specialeffect 236,AREA,"Sacrifice Totem#1";
+	initnpctimer;
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_TI")
+		end;
+	if (getcharid(4) != $@BG_Team1)
+		end;
+	.@condition = getvariableofnpc(.condition,"Tierra_TI");
+
+	.@Points = 0;
+	delitem 8965,countitem(8965);
+
+	if ((.@n = countitem(8966)) > 0) { // Team 2 Skulls
+		delitem 8966,.@n;
+		.@Points = .@n;
+	}
+
+	if (.@Points > 0) {
+		emotion ET_BEST;
+		specialeffect 622;
+		bg_rankpoints(BGR_SKULLS,1,$@skulls*.@Points);
+		.@Score = getvariableofnpc(.Team1_Score,"Tierra_TI") + .@Points;
+		.@Score2 = getvariableofnpc(.Team2_Score,"Tierra_TI");
+		if (.@Score > .@condition) set .@Score, .@condition;
+		set getvariableofnpc(.Team1_Score,"Tierra_TI"),.@Score;
+		mapannounce "region_8",bg_get_data($@BG_Team1,2) + " : " + .@Points + " slaughtered skulls by " + strcharinfo(0) + " [" + .@Score + "/"+.@condition+"]",1,bg_get_data($@BG_Team1,4);
+		donpcevent "Tierra_TI::OnValidateScore";
+	}
+	end;
+}
+
+region_8,28,57,0	duplicate(BlueTotem)	Sacrifice Totem#1	HIDDEN_NPC,2,2
+
+region_8,71,57,0	script	Sacrifice Totem::RedTotem	HIDDEN_NPC,2,2,{
+	if (getcharid(4) == $@BG_Team2)
+		message(strcharinfo(0),"Approach the totem to sacrifice your skulls!");
+	end;
+
+OnStart:
+	initnpctimer;
+	end;
+OnStop:
+	stopnpctimer;
+	end;
+OnTimer1000:
+	specialeffect 225,AREA,"RedTotem";
+	specialeffect 225,AREA,"Sacrifice Totem#2";
+	initnpctimer;
+	end;
+
+OnTouch:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_TI")
+		end;
+	if (getcharid(4) != $@BG_Team2)
+		end;
+	.@condition = getvariableofnpc(.condition,"Tierra_TI");
+
+	.@Points = 0;
+	delitem 8966,countitem(8966);
+
+	if ((.@n = countitem(8965)) > 0) { // Team 1 Skulls
+		delitem 8965,.@n;
+		.@Points = .@n;
+	}
+
+	if (.@Points > 0) {
+		emotion ET_BEST;
+		specialeffect 622;
+		bg_rankpoints(BGR_SKULLS,1,$@skulls*.@Points);
+		.@Score = getvariableofnpc(.Team2_Score,"Tierra_TI") + .@Points;
+		.@Score2 = getvariableofnpc(.Team1_Score,"Tierra_TI");
+		if (.@Score > .@condition) .@Score = .@condition;
+		set getvariableofnpc(.Team2_Score,"Tierra_TI"),.@Score;
+		mapannounce "region_8",bg_get_data($@BG_Team2,2) + " : " + .@Points + " slaughtered skulls by " + strcharinfo(0) + " [" + .@Score + "/"+.@condition+"]",1,bg_get_data($@BG_Team2,4);
+		donpcevent "Tierra_TI::OnValidateScore";
+	}
+	end;
+}
+
+region_8,71,42,0	duplicate(RedTotem)	Sacrifice Totem#2	HIDDEN_NPC,2,2
+
+// MapFlags
+// *********************************************************************
+
+region_8	mapflag	bg_topscore	80
+region_8	mapflag	battleground	2
+region_8	mapflag	nomemo
+region_8	mapflag	nosave	SavePoint
+region_8	mapflag	noteleport
+region_8	mapflag	nowarp
+region_8	mapflag	nowarpto
+region_8	mapflag	noreturn
+region_8	mapflag	nobranch
+region_8	mapflag	nopenalty
+region_8	mapflag	bg_consume
+region_8	mapflag	novending
+
+// Other Flags
+// *********************************************************************
+
+region_8,75,47,2	script	Bravo Base::TIF_Croix	GUILD_FLAG,{
+	end;
+OnEmblemTI:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_TI")
+		end;
+	bg_flagemblem($@BG_Team2);
+	end;
+}
+
+region_8,75,52,2	duplicate(TIF_Croix)	Bravo Base#ti_2	GUILD_FLAG
+
+region_8,24,47,6	script	Alpha Base::TIF_Guillaume	GUILD_FLAG,{
+	end;
+OnEmblemTI:
+	if ($@BG_Status != 1 || $@BG_Current$ != "Tierra_TI")
+		end;
+	bg_flagemblem($@BG_Team1);
+	end;
+}
+
+region_8,24,52,6	duplicate(TIF_Guillaume)	Alpha Base#ti_2	GUILD_FLAG
+
+// Battleground Therapist
+// *********************************************************************
+
+region_8,7,52,5	script	Therapist in battle#ti_1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+
+OnInit:
+	setunittitle(getnpcid(0), "[Blue Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 100);
+	end;
+}
+
+region_8,92,52,3	script	Therapist in battle#ti_2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+
+OnInit:
+	setunittitle(getnpcid(0), "[Red Team]");
+	setunitdata(getnpcid(0), UNPC_GROUP_ID, 101);
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+region_8,89,49,0	script	#cti_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 20) .tick = 0;
+	showscript("Respawn in : "+(20-.tick)+" seconds",getnpcid(0,"Therapist in battle#ti_1"));
+	if (.tick == 19)
+		specialeffect 83;
+	else if (.tick == 20) {
+		areapercentheal "region_8",6,46,13,53,100,100;
+		areawarp "region_8",6,46,13,53,"region_8",27,46,29,53;
+	}
+	initnpctimer;
+	end;
+}
+
+region_8,10,49,0	script	#gti_respawn	HIDDEN_WARP_NPC,{
+	end;
+
+OnBGStart:
+	.tick = 0;
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer1000:
+	if ((.tick++) > 20) .tick = 0;
+	showscript("Respawn in : "+(20-.tick)+" seconds",getnpcid(0,"Therapist in battle#ti_2"));
+	if (.tick == 19)
+		specialeffect 83;
+	else if (.tick == 20) {
+		areapercentheal "region_8",86,46,93,53,100,100;
+		areawarp "region_8",86,46,93,53,"region_8",70,46,72,53;
+	}
+	initnpctimer;
+	end;
+}
diff --git a/npc/re/battleground/bg_common.txt b/npc/re/battleground/bg_common.txt
index 4fe0b76..ac74a96 100644
--- a/npc/re/battleground/bg_common.txt
+++ b/npc/re/battleground/bg_common.txt
@@ -26,4 +26,4 @@
 // BattleGround Warper
 //============================================================
 
-morocc,145,82,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit8	728
+//morocc,145,82,3	duplicate(BatRecruit)	Maroll Battle Recruiter::BatRecruit8	728
diff --git a/npc/scripts_athena.conf b/npc/scripts_athena.conf
index ff8f2e7..630b05e 100644
--- a/npc/scripts_athena.conf
+++ b/npc/scripts_athena.conf
@@ -13,21 +13,21 @@ npc: npc/airports/yuno.txt
 
 // --------------------- Battle Grounds -------------------------
 // - Flavius ----------------------------------------------------
-npc: npc/battleground/flavius/flavius_enter.txt
-npc: npc/battleground/flavius/flavius01.txt
-npc: npc/battleground/flavius/flavius02.txt
+//npc: npc/battleground/flavius/flavius_enter.txt
+//npc: npc/battleground/flavius/flavius01.txt
+//npc: npc/battleground/flavius/flavius02.txt
 // - Kreiger Von Midgard ----------------------------------------
-npc: npc/battleground/kvm/kvm_enter.txt
-npc: npc/battleground/kvm/kvm_item_pay.txt
-npc: npc/battleground/kvm/kvm01.txt
-npc: npc/battleground/kvm/kvm02.txt
-npc: npc/battleground/kvm/kvm03.txt
+//npc: npc/battleground/kvm/kvm_enter.txt
+//npc: npc/battleground/kvm/kvm_item_pay.txt
+//npc: npc/battleground/kvm/kvm01.txt
+//npc: npc/battleground/kvm/kvm02.txt
+//npc: npc/battleground/kvm/kvm03.txt
 // - Tierra Gorge -----------------------------------------------
-npc: npc/battleground/tierra/tierra_enter.txt
-npc: npc/battleground/tierra/tierra01.txt
-npc: npc/battleground/tierra/tierra02.txt
+//npc: npc/battleground/tierra/tierra_enter.txt
+//npc: npc/battleground/tierra/tierra01.txt
+//npc: npc/battleground/tierra/tierra02.txt
 // --------------------------------------------------------------
-npc: npc/battleground/bg_common.txt
+//npc: npc/battleground/bg_common.txt
 
 // --------------------------- Cities ---------------------------
 npc: npc/cities/alberta.txt
diff --git a/npc/scripts_custom.conf b/npc/scripts_custom.conf
index fb46627..bb7efa9 100644
--- a/npc/scripts_custom.conf
+++ b/npc/scripts_custom.conf
@@ -115,3 +115,15 @@
 // -- Custom quests from official Umbalian Quests
 //npc: npc/custom/quests/sphinx_mask.txt
 //npc: npc/custom/quests/umbalian_language.txt
+
+// ---------- Extended Battleground System [Easycore] ----------
+npc: npc/custom/eBG/bg_core.txt
+npc: npc/custom/eBG/bg_common.txt
+npc: npc/custom/eBG/bg_conquest.txt
+npc: npc/custom/eBG/bg_flavius_ctf.txt
+npc: npc/custom/eBG/bg_flavius_td.txt
+npc: npc/custom/eBG/bg_flavius_sc.txt
+npc: npc/custom/eBG/bg_tierra_boss.txt
+npc: npc/custom/eBG/bg_tierra_dom.txt
+npc: npc/custom/eBG/bg_tierra_ti.txt
+npc: npc/custom/eBG/bg_rush.txt
diff --git a/sql-files/extended_bg.sql b/sql-files/extended_bg.sql
new file mode 100644
index 0000000..7fe193e
--- /dev/null
+++ b/sql-files/extended_bg.sql
@@ -0,0 +1,158 @@
+/*
+===== rAthena SQL File =======================================
+    Extended Battleground
+= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+ Date:
+  30-01-2023
+ By:
+  Easycore
+
+ Contact:
+    - Web:  https://www.easycore-services.com/index.php?/profile/1-easycore/
+    - rAthena:  https://rathena.org/board/profile/16425-easycore/
+    - Discord:  Easycore#9709
+= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
+*/
+
+SET NAMES utf8mb4;
+SET FOREIGN_KEY_CHECKS = 0;
+
+-- ----------------------------
+-- Table structure for char_bg
+-- ----------------------------
+DROP TABLE IF EXISTS `char_bg`;
+CREATE TABLE `char_bg`  (
+  `char_id` int(11) NOT NULL,
+  `top_damage` int(11) NOT NULL DEFAULT 0,
+  `damage_done` int(11) NOT NULL DEFAULT 0,
+  `damage_received` int(11) NOT NULL DEFAULT 0,
+  `skulls` int(11) NOT NULL DEFAULT 0,
+  `ti_wins` int(11) NOT NULL DEFAULT 0,
+  `ti_lost` int(11) NOT NULL DEFAULT 0,
+  `ti_tie` int(11) NOT NULL DEFAULT 0,
+  `eos_flags` int(11) NOT NULL DEFAULT 0,
+  `eos_bases` int(11) NOT NULL DEFAULT 0,
+  `eos_wins` int(11) NOT NULL DEFAULT 0,
+  `eos_lost` int(11) NOT NULL DEFAULT 0,
+  `eos_tie` int(11) NOT NULL DEFAULT 0,
+  `boss_killed` int(11) NOT NULL DEFAULT 0,
+  `boss_damage` int(11) NOT NULL DEFAULT 0,
+  `boss_flags` int(11) NOT NULL DEFAULT 0,
+  `boss_wins` int(11) NOT NULL DEFAULT 0,
+  `boss_lost` int(11) NOT NULL DEFAULT 0,
+  `boss_tie` int(11) NOT NULL DEFAULT 0,
+  `dom_bases` int(11) NOT NULL DEFAULT 0,
+  `dom_off_kills` int(11) NOT NULL DEFAULT 0,
+  `dom_def_kills` int(11) NOT NULL DEFAULT 0,
+  `dom_wins` int(11) NOT NULL DEFAULT 0,
+  `dom_lost` int(11) NOT NULL DEFAULT 0,
+  `dom_tie` int(11) NOT NULL DEFAULT 0,
+  `td_kills` int(11) NOT NULL DEFAULT 0,
+  `td_deaths` int(11) NOT NULL DEFAULT 0,
+  `td_wins` int(11) NOT NULL DEFAULT 0,
+  `td_lost` int(11) NOT NULL DEFAULT 0,
+  `td_tie` int(11) NOT NULL DEFAULT 0,
+  `sc_stole` int(11) NOT NULL DEFAULT 0,
+  `sc_captured` int(11) NOT NULL DEFAULT 0,
+  `sc_droped` int(11) NOT NULL DEFAULT 0,
+  `sc_wins` int(11) NOT NULL DEFAULT 0,
+  `sc_lost` int(11) NOT NULL DEFAULT 0,
+  `sc_tie` int(11) NOT NULL DEFAULT 0,
+  `ctf_taken` int(11) NOT NULL DEFAULT 0,
+  `ctf_captured` int(11) NOT NULL DEFAULT 0,
+  `ctf_droped` int(11) NOT NULL DEFAULT 0,
+  `ctf_wins` int(11) NOT NULL DEFAULT 0,
+  `ctf_lost` int(11) NOT NULL DEFAULT 0,
+  `ctf_tie` int(11) NOT NULL DEFAULT 0,
+  `emperium_kill` int(11) NOT NULL DEFAULT 0,
+  `barricade_kill` int(11) NOT NULL DEFAULT 0,
+  `gstone_kill` int(11) NOT NULL DEFAULT 0,
+  `cq_wins` int(11) NOT NULL DEFAULT 0,
+  `cq_lost` int(11) NOT NULL DEFAULT 0,
+  `ru_captures` int(11) NOT NULL DEFAULT 0,
+  `ru_wins` int(11) NOT NULL DEFAULT 0,
+  `ru_lost` int(11) NOT NULL DEFAULT 0,
+  `kill_count` int(11) NOT NULL DEFAULT 0,
+  `death_count` int(11) NOT NULL DEFAULT 0,
+  `win` int(11) NOT NULL DEFAULT 0,
+  `lost` int(11) NOT NULL DEFAULT 0,
+  `tie` int(11) NOT NULL DEFAULT 0,
+  `leader_win` int(11) NOT NULL DEFAULT 0,
+  `leader_lost` int(11) NOT NULL DEFAULT 0,
+  `leader_tie` int(11) NOT NULL DEFAULT 0,
+  `deserter` int(11) NOT NULL DEFAULT 0,
+  `score` int(11) NOT NULL DEFAULT 0,
+  `points` int(11) NOT NULL DEFAULT 0,
+  `rank_points` int(11) NOT NULL DEFAULT 0,
+  `rank_games` int(11) NOT NULL DEFAULT 0,
+  `sp_heal_potions` int(11) NOT NULL DEFAULT 0,
+  `hp_heal_potions` int(11) NOT NULL DEFAULT 0,
+  `yellow_gemstones` int(11) NOT NULL DEFAULT 0,
+  `red_gemstones` int(11) NOT NULL DEFAULT 0,
+  `blue_gemstones` int(11) NOT NULL DEFAULT 0,
+  `poison_bottles` int(11) NOT NULL DEFAULT 0,
+  `acid_demostration` int(11) NOT NULL DEFAULT 0,
+  `acid_demostration_fail` int(11) NOT NULL DEFAULT 0,
+  `support_skills_used` int(11) NOT NULL DEFAULT 0,
+  `healing_done` int(11) NOT NULL DEFAULT 0,
+  `wrong_support_skills_used` int(11) NOT NULL DEFAULT 0,
+  `wrong_healing_done` int(11) NOT NULL DEFAULT 0,
+  `sp_used` int(11) NOT NULL DEFAULT 0,
+  `zeny_used` int(11) NOT NULL DEFAULT 0,
+  `spiritb_used` int(11) NOT NULL DEFAULT 0,
+  `ammo_used` int(11) NOT NULL DEFAULT 0,
+  `showstats` int(11) NOT NULL DEFAULT 0,
+  PRIMARY KEY (`char_id`) USING BTREE
+) ENGINE = MyISAM CHARACTER SET = latin1 COLLATE = latin1_swedish_ci ROW_FORMAT = Fixed;
+
+-- ----------------------------
+-- Table structure for char_wstats
+-- ----------------------------
+DROP TABLE IF EXISTS `char_wstats`;
+CREATE TABLE `char_wstats`  (
+  `char_id` int(11) NOT NULL,
+  `top_damage` int(11) NOT NULL DEFAULT 0,
+  `damage_done` int(11) NOT NULL DEFAULT 0,
+  `damage_received` int(11) NOT NULL DEFAULT 0,
+  `emperium_damage` int(11) NOT NULL DEFAULT 0,
+  `guardian_damage` int(11) NOT NULL DEFAULT 0,
+  `barricade_damage` int(11) NOT NULL DEFAULT 0,
+  `gstone_damage` int(11) NOT NULL DEFAULT 0,
+  `emperium_kill` int(11) NOT NULL DEFAULT 0,
+  `guardian_kill` int(11) NOT NULL DEFAULT 0,
+  `barricade_kill` int(11) NOT NULL DEFAULT 0,
+  `gstone_kill` int(11) NOT NULL DEFAULT 0,
+  `sp_heal_potions` int(11) NOT NULL DEFAULT 0,
+  `hp_heal_potions` int(11) NOT NULL DEFAULT 0,
+  `yellow_gemstones` int(11) NOT NULL DEFAULT 0,
+  `red_gemstones` int(11) NOT NULL DEFAULT 0,
+  `blue_gemstones` int(11) NOT NULL DEFAULT 0,
+  `poison_bottles` int(11) NOT NULL DEFAULT 0,
+  `acid_demostration` int(11) NOT NULL DEFAULT 0,
+  `acid_demostration_fail` int(11) NOT NULL DEFAULT 0,
+  `support_skills_used` int(11) NOT NULL DEFAULT 0,
+  `healing_done` int(11) NOT NULL DEFAULT 0,
+  `wrong_support_skills_used` int(11) NOT NULL DEFAULT 0,
+  `wrong_healing_done` int(11) NOT NULL DEFAULT 0,
+  `sp_used` int(11) NOT NULL DEFAULT 0,
+  `zeny_used` int(11) NOT NULL DEFAULT 0,
+  `spiritb_used` int(11) NOT NULL DEFAULT 0,
+  `ammo_used` int(11) NOT NULL DEFAULT 0,
+  `kill_count` int(11) NOT NULL DEFAULT 0,
+  `death_count` int(11) NOT NULL DEFAULT 0,
+  `score` int(11) NOT NULL DEFAULT 0,
+  `points` int(11) NOT NULL DEFAULT 0,
+  `showstats` int(11) NOT NULL DEFAULT 0,
+  PRIMARY KEY (`char_id`) USING BTREE
+) ENGINE = MyISAM CHARACTER SET = latin1 COLLATE = latin1_swedish_ci ROW_FORMAT = Fixed;
+
+SET FOREIGN_KEY_CHECKS = 1;
+
+-- ----------------------------
+-- Records of guild_emblems
+-- ----------------------------
+INSERT INTO `guild_emblems` VALUES ('rAthena', 2147483647, 'BMP', 0x424D760600000000000036040000280000001800000018000000010008000000000000000000120B0000120B00000001000000010000000000FFFF00FFFFA70022FFFFFFFFFF36010BFFDE2452FF460312FFF00032FF8B001CFF150004FFDC002DFFF52154FFB0183CFFCA3D68FF4C1726FF100003FFA03052FFC30028FF8D2340FF2B0008FF640014FF7C0D26FF36101BFFF53669FFC5153EFFDA1744FFF60538FFE13260FFB10025FF292929FFE83A6AFF090002FF4C1222FFAC3458FF6C1228FF0F0306FFA82548FF8E1A38FFED2051FFDD4371FF260C15FF170509FFBE0E35FFA21132FF5B0013FFC3355EFFDC0B38FF38040FFF090305FFF52E61FF8B2A47FFD5002CFFF51245FF270A12FF7C223BFF65071CFFA00C2DFF210006FFF60033FF890723FFAA2043FF5A1E31FFF53D70FFBF1F47FF110508FFAB2649FF6F1E35FFC8436DFFCC2650FF470513FFC70A33FF401320FFE70030FF20070DFFC03058FF560B1DFF380713FFF51A4DFFF5285BFF690015FF711C33FF943152FFBF0027FFB9193FFFE14C7BFF350B0AFF2F0E18FFEE2D5EFFE01E4DFF31050FFFAB0327FF960322FF9E2B4CFFF54376FF370B0AFF0B0B0BFF1A0208FFEB0535FFED3B6DFFCD002AFFC42049FFA6082AFFF70842FFDE002EFF630821FF5B0417FF640217FF4F1829FF530011FFB5193AFFD83B68FF982141FF35000AFF6A172DFF310819FF210808FFBC143BFFAB1235FFCA325CFFDA103DFF45000EFFD50430FF880A26FFB71E44FF490716FF511222FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0101015E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E0101010101015E030303030303030303030303030303035E0101010101015E030000000000005E5E1F000000000F035E0101010101015E03000303030300001F000303030300035E0101010101015E030003000000030000030000000300035E0101010101015E030003030303000000030003030300035E0101015E5E5E5E030003000000030000030000000000035E5E5E5E5E030303030003030303005F1D000303030300030303035E5E034328232300000000303D30000000000030545140035E5E032123562710404016320E2323232349476B270D16035E5E035C426E2D3523474740232323232323236B5D5D36035E5E031E3E4A5623506276353023232323232320623E12035E5E03176F40407D1B1717712923232323232349411724035E5E03642323603C313131572560232323232323205744035E5E03221F1F357B4E4E4E4E3F49232323232323606405035E5E03594C0949530B2658584B1F0F0F0F0F0F0F0F0C0C035E5E032B185960184D154C7475391F0F0F0F0F0F7C1968035E5E033477390F3834451F2A342F1F0F0F0F0F0F37347A035E5E0366690F0F062E466A653B09090F0F0F0F0F396566035E5E036A0F0F0F0F5A1A61796A0F0F1F1F1F1F040F0F5B035E5E03786C130F2C483A3A3A671C14390F390867020F70035E5E030A334F2C483A3A3A3A3A3A486352630707075252035E5E030303030303030303030303030303030303030303035E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E5E, 1);
+INSERT INTO `guild_emblems` VALUES ('rAthena', 2147483646, 'BMP', 0x424D760600000000000036040000280000001800000018000000010008000000000000000000120B0000120B00000001000000010000000000FFFF00FFFF000099FFFFFFFFFF09094FFF38389FFF000023FF191956FF2121AEFF000019FF5151E5FF070857FF141788FF030369FF01013EFF0D0DD4FF1C1CDBFF0000CCFF17177AFF1515D8FF4141B9FF080818FF0D0D2BFF090990FF151564FF0000C5FF00008EFF171742FF1F1FC5FF000087FF0505ADFF010106FF2C2C92FF10103EFF4B4BD5FF292929FF3737C9FF00002BFF3131A4FF26266CFF5858ECFF2323DFFF3939B1FF0606D1FF28287CFF0F0F60FF101081FF14149BFF08083AFF0B0B0BFF3E3ED0FF1F1F69FF111151FF5E5EFBFF212152FF0B0BBAFF000060FF0A0A6BFF080820FF080829FF2727CBFF3F3FC4FF181897FF2B2BE2FF1C1CB4FF0000B7FF02020EFF0606C6FF101031FF0E0E93FF222262FF09098DFF080884FF313196FF16165BFF101044FF5757F7FF292976FF080833FF00004AFF3939A2FF000821FF15188EFF030372FF1C1C80FF4747DCFF080842FF060613FF212173FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0101010B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0101010101010B030303030303030303030303030303030B0101010101010B031F0000000042520C3A000000003A030B0101010101010B03000303030300423A000303030300030B0101010101010B030003000000030000030000000300030B0101010101010B030003030303000000030003030300030B0101010B0B0B0B030003000000030000030000000000030B0B0B0B0B030303030003030303003123000303030300030303030B0B033535284200000000001515000000000042353535030B0B0327504D074C4C0544151515151B0A461607222714030B0B03581649213D2A3A1515151515152C1B57441B1B55030B0B032A0726203A3A1515151515151515151515163233030B0B03342434215715151515151515151515151544073A030B0B034B4A3A5715151515151515151515151515151534030B0B031857575757574E3A575757573454305757151515030B0B03424242423A123C3E0909093A083F3C4B57575757030B0B03575757573E2929292D09093A4029291C4E090909030B0B0309090904101010102F0909092F1010102E090909030B0B0309090939131313132E0909092E13131345090909030B0B03090909390F0F0F374F090909170F0F0F47090909030B0B030909090D2B2B43530909090E432B2B2B1E060909030B0B030909091A11111111024F384111111111111D2509030B0B030303030303030303030303030303030303030303030B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B, 1);
+INSERT INTO `guild_emblems` VALUES ('rAthena', 2147483645, 'BMP', 0x424D760600000000000036040000280000001800000018000000010008000000000040020000120B0000120B0000000000000000000000000000000080000080000000808000800000008000800080800000C0C0C000C0DCC000F0CAA6000020400000206000002080000020A0000020C0000020E00000400000004020000040400000406000004080000040A0000040C0000040E00000600000006020000060400000606000006080000060A0000060C0000060E00000800000008020000080400000806000008080000080A0000080C0000080E00000A0000000A0200000A0400000A0600000A0800000A0A00000A0C00000A0E00000C0000000C0200000C0400000C0600000C0800000C0A00000C0C00000C0E00000E0000000E0200000E0400000E0600000E0800000E0A00000E0C00000E0E00040000000400020004000400040006000400080004000A0004000C0004000E00040200000402020004020400040206000402080004020A0004020C0004020E00040400000404020004040400040406000404080004040A0004040C0004040E00040600000406020004060400040606000406080004060A0004060C0004060E00040800000408020004080400040806000408080004080A0004080C0004080E00040A0000040A0200040A0400040A0600040A0800040A0A00040A0C00040A0E00040C0000040C0200040C0400040C0600040C0800040C0A00040C0C00040C0E00040E0000040E0200040E0400040E0600040E0800040E0A00040E0C00040E0E00080000000800020008000400080006000800080008000A0008000C0008000E00080200000802020008020400080206000802080008020A0008020C0008020E00080400000804020008040400080406000804080008040A0008040C0008040E00080600000806020008060400080606000806080008060A0008060C0008060E00080800000808020008080400080806000808080008080A0008080C0008080E00080A0000080A0200080A0400080A0600080A0800080A0A00080A0C00080A0E00080C0000080C0200080C0400080C0600080C0800080C0A00080C0C00080C0E00080E0000080E0200080E0400080E0600080E0800080E0A00080E0C00080E0E000C0000000C0002000C0004000C0006000C0008000C000A000C000C000C000E000C0200000C0202000C0204000C0206000C0208000C020A000C020C000C020E000C0400000C0402000C0404000C0406000C0408000C040A000C040C000C040E000C0600000C0602000C0604000C0606000C0608000C060A000C060C000C060E000C0800000C0802000C0804000C0806000C0808000C080A000C080C000C080E000C0A00000C0A02000C0A04000C0A06000C0A08000C0A0A000C0A0C000C0A0E000C0C00000C0C02000C0C04000C0C06000C0C08000C0C0A000F0FBFF00A4A0A000808080000000FF0000FF000000FFFF00FF000000FF00FF00FFFF0000FFFFFF00FDFDFD0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0BFDFDFDFDFDFD0BFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0BFDFDFDFDFDFD0BFF00000000000031310A0000000000FF0BFDFDFDFDFDFD0BFF00FFFFFFFF00000A00FFFFFFFF00FF0BFDFDFDFDFDFD0BFF00FF000000FF0000FF000000FF00FF0BFDFDFDFDFDFD0BFF00FFFFFFFF000000FF00FFFFF600FF0BFDFDFD0B0B0B0BFF00FF000000FF0000F60000000000FF0B0B0B0B0BFFFFFFFF00FFFFFFFF00000000F6FFFFF600FFFFFFFF0B0BFF3131310000000000001000000000000000292921FF0B0BFF3131291100000000000000000000112129292921FF0B0BFF3129100000000000000000000000001021292921FF0B0BFF3121000000001010101010100000000011292921FF0B0BFF2919000000001010212921110000000019292929FF0B0BFF2929100000000000111910000000001929292929FF0B0BFF2929211910000000000000000010191929292929FF0B0BFF2929312929191000000000001021111019212929FF0B0BFF2929313129190000000000192921100000102129FF0B0BFF2929313121000000001021292110000000001929FF0B0BFF2929313119000000001010101000003100001931FF0B0BFF2929313119000000000000000000000000102931FF0B0BFF2929313121100000000000000000000010213131FF0B0BFF2929313129211110000000000000001929313131FF0B0BFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B, 1);
+
+SET FOREIGN_KEY_CHECKS = 1;
\ No newline at end of file
diff --git a/src/char/char.cpp b/src/char/char.cpp
index 6c84149..97e63b7 100644
--- a/src/char/char.cpp
+++ b/src/char/char.cpp
@@ -54,10 +54,14 @@ struct mmo_map_server map_server[MAX_MAP_SERVERS];
 int fame_list_size_chemist = MAX_FAME_LIST;
 int fame_list_size_smith = MAX_FAME_LIST;
 int fame_list_size_taekwon = MAX_FAME_LIST;
+int fame_list_size_bg = MAX_FAME_LIST;
+int fame_list_size_woe = MAX_FAME_LIST;
 // Char-server-side stored fame lists [DracoRPG]
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 #define CHAR_MAX_MSG 300	//max number of msg_conf
 static char* msg_table[CHAR_MAX_MSG]; // Login Server messages_conf
@@ -378,6 +382,84 @@ int char_mmo_char_tosql(uint32 char_id, struct mmo_charstatus* p){
 			errors++;
 	}
 
+	/* Player Battleground Stadistics */
+	if( memcmp(&p->bgstats, &cp->bgstats, sizeof(struct s_battleground_stats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`skulls`, `ti_wins`, `ti_lost`, `ti_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`boss_killed`, `boss_damage`, `boss_flags`, `boss_wins`, `boss_lost`, `boss_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`td_kills`, `td_deaths`, `td_wins`, `td_lost`, `td_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`, `rank_points`, `rank_games`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'%u','%u','%u',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%u','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d')",
+			p->char_id,
+			p->bgstats.top_damage, p->bgstats.damage_done, p->bgstats.damage_received,
+			p->bgstats.skulls,p->bgstats.ti_wins,p->bgstats.ti_lost,p->bgstats.ti_tie,
+			p->bgstats.eos_flags,p->bgstats.eos_bases,p->bgstats.eos_wins,p->bgstats.eos_lost,p->bgstats.eos_tie,
+			p->bgstats.boss_killed,p->bgstats.boss_damage,p->bgstats.boss_flags,p->bgstats.boss_wins,p->bgstats.boss_lost,p->bgstats.boss_tie,
+			p->bgstats.dom_bases,p->bgstats.dom_off_kills,p->bgstats.dom_def_kills,p->bgstats.dom_wins,p->bgstats.dom_lost,p->bgstats.dom_tie,
+			p->bgstats.td_kills,p->bgstats.td_deaths,p->bgstats.td_wins,p->bgstats.td_lost,p->bgstats.td_tie,
+			p->bgstats.sc_stole,p->bgstats.sc_captured,p->bgstats.sc_droped,p->bgstats.sc_wins,p->bgstats.sc_lost,p->bgstats.sc_tie,
+			p->bgstats.ctf_taken,p->bgstats.ctf_captured,p->bgstats.ctf_droped,p->bgstats.ctf_wins,p->bgstats.ctf_lost,p->bgstats.ctf_tie,
+			p->bgstats.emperium_kill,p->bgstats.barricade_kill,p->bgstats.gstone_kill,p->bgstats.cq_wins,p->bgstats.cq_lost,
+			p->bgstats.ru_captures,p->bgstats.ru_wins,p->bgstats.ru_lost,
+			p->bgstats.kill_count,p->bgstats.death_count,p->bgstats.win,p->bgstats.lost,p->bgstats.tie,p->bgstats.leader_win,p->bgstats.leader_lost,p->bgstats.leader_tie,p->bgstats.deserter,p->bgstats.score,p->bgstats.points,p->bgstats.rank_points,p->bgstats.rank_games,
+			p->bgstats.sp_heal_potions, p->bgstats.hp_heal_potions, p->bgstats.yellow_gemstones, p->bgstats.red_gemstones, p->bgstats.blue_gemstones, p->bgstats.poison_bottles, p->bgstats.acid_demostration, p->bgstats.acid_demostration_fail,
+			p->bgstats.support_skills_used, p->bgstats.healing_done, p->bgstats.wrong_support_skills_used, p->bgstats.wrong_healing_done,
+			p->bgstats.sp_used, p->bgstats.zeny_used, p->bgstats.spiritb_used, p->bgstats.ammo_used, p->bgstats.showstats) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " bgstats");
+	}
+
+	/* WoE Stadistics */
+	if( memcmp(&p->wstats, &cp->wstats, sizeof(struct s_woestats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_wstats` (`char_id`, `kill_count`, `death_count`, `score`, `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `points`, `showstats`) "
+			"VALUES ('%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%d', '%d')",
+			p->char_id, p->wstats.kill_count, p->wstats.death_count, p->wstats.score, p->wstats.top_damage, p->wstats.damage_done, p->wstats.damage_received, p->wstats.emperium_damage, p->wstats.guardian_damage, p->wstats.barricade_damage, p->wstats.gstone_damage,
+			p->wstats.emperium_kill, p->wstats.guardian_kill, p->wstats.barricade_kill, p->wstats.gstone_kill,
+			p->wstats.sp_heal_potions, p->wstats.hp_heal_potions, p->wstats.yellow_gemstones, p->wstats.red_gemstones, p->wstats.blue_gemstones, p->wstats.poison_bottles, p->wstats.acid_demostration, p->wstats.acid_demostration_fail,
+			p->wstats.support_skills_used, p->wstats.healing_done, p->wstats.wrong_support_skills_used, p->wstats.wrong_healing_done,
+			p->wstats.sp_used, p->wstats.zeny_used, p->wstats.spiritb_used, p->wstats.ammo_used, p->wstats.points, p->wstats.showstats) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " woestats");
+	}
+
 	//memo points
 	if( memcmp(p->memo_point, cp->memo_point, sizeof(p->memo_point)) )
 	{
@@ -1241,6 +1323,189 @@ int char_mmo_char_fromsql(uint32 char_id, struct mmo_charstatus* p, bool load_ev
 	StringBuf_AppendStr(&msg_buf, " hotkeys");
 #endif
 
+	/* Character Battleground Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`,`damage_done`,`damage_received`,`skulls`,`ti_wins`,`ti_lost`,`ti_tie`,`eos_flags`,`eos_bases`,`eos_wins`,`eos_lost`,`eos_tie`,`boss_killed`,`boss_damage`,`boss_flags`,`boss_wins`,`boss_lost`,`boss_tie`,`td_kills`,`td_deaths`,`td_wins`,`td_lost`,`td_tie`,`dom_bases`,`dom_off_kills`,`dom_def_kills`,`dom_wins`,`dom_lost`,`dom_tie`,`sc_stole`,`sc_captured`,`sc_droped`,`sc_wins`,`sc_lost`,`sc_tie`,`ctf_taken`,`ctf_captured`,`ctf_droped`,`ctf_wins`,`ctf_lost`,`ctf_tie`,`emperium_kill`,`barricade_kill`,`gstone_kill`,`cq_wins`,`cq_lost`,`ru_wins`,`ru_lost`,`ru_captures`,`kill_count`,`death_count`,`win`,`lost`,`tie`,`leader_win`,`leader_lost`,`leader_tie`,`deserter`,`score`,`points`,`rank_points`,`rank_games`,`sp_heal_potions`,`hp_heal_potions`,`yellow_gemstones`,`red_gemstones`,`blue_gemstones`,`poison_bottles`,`acid_demostration`,`acid_demostration_fail`,`support_skills_used`,`healing_done`,`wrong_support_skills_used`,`wrong_healing_done`,`sp_used`,`zeny_used`,`spiritb_used`,`ammo_used`,`showstats` FROM `char_bg` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT,   &p->bgstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT,   &p->bgstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT,   &p->bgstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_USHORT, &p->bgstats.skulls, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_USHORT, &p->bgstats.ti_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_USHORT, &p->bgstats.ti_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_USHORT, &p->bgstats.ti_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->bgstats.eos_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->bgstats.eos_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->bgstats.eos_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->bgstats.eos_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_USHORT, &p->bgstats.eos_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_USHORT, &p->bgstats.boss_killed, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT,   &p->bgstats.boss_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_USHORT, &p->bgstats.boss_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_USHORT, &p->bgstats.boss_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_USHORT, &p->bgstats.boss_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_USHORT, &p->bgstats.boss_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_USHORT, &p->bgstats.td_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_USHORT, &p->bgstats.td_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_USHORT, &p->bgstats.td_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_USHORT, &p->bgstats.td_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_USHORT, &p->bgstats.td_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_USHORT, &p->bgstats.dom_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_USHORT, &p->bgstats.dom_off_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_USHORT, &p->bgstats.dom_def_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_USHORT, &p->bgstats.dom_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->bgstats.dom_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->bgstats.dom_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->bgstats.sc_stole, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 30, SQLDT_USHORT, &p->bgstats.sc_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 31, SQLDT_USHORT, &p->bgstats.sc_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 32, SQLDT_USHORT, &p->bgstats.sc_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 33, SQLDT_USHORT, &p->bgstats.sc_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 34, SQLDT_USHORT, &p->bgstats.sc_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 35, SQLDT_USHORT, &p->bgstats.ctf_taken, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 36, SQLDT_USHORT, &p->bgstats.ctf_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 37, SQLDT_USHORT, &p->bgstats.ctf_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 38, SQLDT_USHORT, &p->bgstats.ctf_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 39, SQLDT_USHORT, &p->bgstats.ctf_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 40, SQLDT_USHORT, &p->bgstats.ctf_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 41, SQLDT_USHORT, &p->bgstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 42, SQLDT_USHORT, &p->bgstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 43, SQLDT_USHORT, &p->bgstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 44, SQLDT_USHORT, &p->bgstats.cq_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 45, SQLDT_USHORT, &p->bgstats.cq_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 46, SQLDT_USHORT, &p->bgstats.ru_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 47, SQLDT_USHORT, &p->bgstats.ru_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 48, SQLDT_USHORT, &p->bgstats.ru_captures, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 49, SQLDT_USHORT, &p->bgstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 50, SQLDT_USHORT, &p->bgstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 51, SQLDT_USHORT, &p->bgstats.win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 52, SQLDT_USHORT, &p->bgstats.lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 53, SQLDT_USHORT, &p->bgstats.tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 54, SQLDT_USHORT, &p->bgstats.leader_win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 55, SQLDT_USHORT, &p->bgstats.leader_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 56, SQLDT_USHORT, &p->bgstats.leader_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 57, SQLDT_USHORT, &p->bgstats.deserter, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 58, SQLDT_USHORT, &p->bgstats.score, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 59, SQLDT_USHORT, &p->bgstats.points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 60, SQLDT_USHORT, &p->bgstats.rank_points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 61, SQLDT_USHORT, &p->bgstats.rank_games, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 62, SQLDT_UINT,   &p->bgstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 63, SQLDT_UINT,   &p->bgstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 64, SQLDT_UINT,   &p->bgstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 65, SQLDT_UINT,   &p->bgstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 66, SQLDT_UINT,   &p->bgstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 67, SQLDT_UINT,   &p->bgstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 68, SQLDT_UINT,   &p->bgstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 69, SQLDT_UINT,   &p->bgstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 70, SQLDT_UINT,   &p->bgstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 71, SQLDT_UINT,   &p->bgstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 72, SQLDT_UINT,   &p->bgstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 73, SQLDT_UINT,   &p->bgstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 74, SQLDT_UINT,   &p->bgstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 75, SQLDT_UINT,   &p->bgstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 76, SQLDT_UINT,   &p->bgstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 77, SQLDT_UINT,   &p->bgstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 78, SQLDT_USHORT, &p->bgstats.showstats, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "INSERT INTO `char_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`skulls`, `ti_wins`, `ti_lost`, `ti_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`boss_killed`, `boss_damage`, `boss_flags`, `boss_wins`, `boss_lost`, `boss_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`td_kills`, `td_deaths`, `td_wins`, `td_lost`, `td_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`, `rank_points`, `rank_games`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0',"
+			"'0','0','0','0','0','0','0','0','0','0','0','0','0',"
+			"'0','0','0','0','0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0')",
+			char_id) )
+			Sql_ShowDebug(sql_handle);
+		p->bgstats.score = 2000;
+	}
+	StringBuf_AppendStr(&msg_buf, " bgstats");
+
+	/* Character WoE Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, `emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, `sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, `support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, `sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score`, `points`, `showstats` FROM `char_wstats` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT, &p->wstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT, &p->wstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT, &p->wstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_UINT, &p->wstats.emperium_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_UINT, &p->wstats.guardian_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_UINT, &p->wstats.barricade_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_UINT, &p->wstats.gstone_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->wstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->wstats.guardian_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->wstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->wstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_UINT, &p->wstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_UINT, &p->wstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT, &p->wstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_UINT, &p->wstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_UINT, &p->wstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_UINT, &p->wstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_UINT, &p->wstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_UINT, &p->wstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_UINT, &p->wstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_UINT, &p->wstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_UINT, &p->wstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_UINT, &p->wstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_UINT, &p->wstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_UINT, &p->wstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_UINT, &p->wstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_UINT, &p->wstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->wstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->wstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->wstats.score, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 30, SQLDT_USHORT, &p->wstats.points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 31, SQLDT_USHORT, &p->wstats.showstats, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "INSERT INTO `char_wstats` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score`, `points`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0','0','0','0','0')",
+			char_id) )
+			Sql_ShowDebug(sql_handle);
+		p->wstats.score = 2000;
+	}
+	StringBuf_AppendStr(&msg_buf, " woestats");
+
 	/* Mercenary Owner DataBase */
 	mercenary_owner_fromsql(char_id, p);
 	StringBuf_AppendStr(&msg_buf, " mercenary");
@@ -1537,6 +1802,63 @@ int char_make_new_char( struct char_session_data* sd, char* name_, int str, int
 			Sql_ShowDebug(sql_handle);
 	}
 
+	// Extended Features BG [Easycore]
+	// Create a new entry in char_bg table
+	if( SQL_ERROR == Sql_Query(sql_handle, "INSERT INTO `char_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`skulls`, `ti_wins`, `ti_lost`, `ti_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`boss_killed`, `boss_damage`, `boss_flags`, `boss_wins`, `boss_lost`, `boss_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`td_kills`, `td_deaths`, `td_wins`, `td_lost`, `td_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`, `rank_points`, `rank_games`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0',"
+			"'0','0','0','0','0','0','0','0','0','0','0','0','0',"
+			"'0','0','0','0','0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0')",
+			char_id) )
+			Sql_ShowDebug(sql_handle);
+
+	// Create a new entry in char_wstats table
+	if( SQL_ERROR == Sql_Query(sql_handle, "INSERT INTO `char_wstats` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score`, `points`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0','0','0','0','0')",
+			char_id) )
+			Sql_ShowDebug(sql_handle);
+
 	ShowInfo("Created char: account: %d, char: %d, slot: %d, name: %s\n", sd->account_id, char_id, slot, name);
 	return char_id;
 }
@@ -1749,6 +2071,14 @@ enum e_char_del_response char_delete(struct char_session_data* sd, uint32 char_i
 			Sql_ShowDebug(sql_handle);
 	}
 
+	// Extended Features BG [Easycore]
+	// Delete records in char_bg table
+	if (SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_bg` WHERE `char_id` = '%d'", char_id))
+		Sql_ShowDebug(sql_handle);
+	// Delete records in char_wstats table
+	if (SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_wstats` WHERE `char_id` = '%d'", char_id))
+		Sql_ShowDebug(sql_handle);
+
 	/* delete character */
 	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id`='%d'", schema_config.char_db, char_id) )
 		Sql_ShowDebug(sql_handle);
@@ -2024,6 +2354,8 @@ void char_read_fame_list(void)
 	memset(smith_fame_list, 0, sizeof(smith_fame_list));
 	memset(chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset(taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset(bg_fame_list, 0, sizeof(bg_fame_list));
+	memset(woe_fame_list, 0, sizeof(woe_fame_list));
 	// Build Blacksmith ranking list
 	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_id`,`fame`,`name` FROM `%s` WHERE `fame`>0 AND (`class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d') ORDER BY `fame` DESC LIMIT 0,%d", schema_config.char_db, JOB_BLACKSMITH, JOB_WHITESMITH, JOB_BABY_BLACKSMITH, JOB_MECHANIC, JOB_MECHANIC_T, JOB_BABY_MECHANIC, JOB_MEISTER, fame_list_size_smith) )
 		Sql_ShowDebug(sql_handle);
@@ -2070,6 +2402,38 @@ void char_read_fame_list(void)
 		memcpy(taekwon_fame_list[i].name, data, zmin(len, NAME_LENGTH));
 	}
 	Sql_FreeResult(sql_handle);
+	// Build BG ranking list
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_bg`.`char_id`, `char_bg`.`points`, `%s`.`name` FROM `char_bg` LEFT JOIN `%s` ON `%s`.`char_id` = `char_bg`.`char_id` WHERE `char_bg`.`points` > '0' ORDER BY `char_bg`.`points` DESC LIMIT 0,%d", schema_config.char_db, schema_config.char_db, schema_config.char_db, fame_list_size_bg) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bg && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		// char_id
+		Sql_GetData(sql_handle, 0, &data, NULL);
+		bg_fame_list[i].id = atoi(data);
+		// fame
+		Sql_GetData(sql_handle, 1, &data, &len);
+		bg_fame_list[i].fame = atoi(data);
+		// name
+		Sql_GetData(sql_handle, 2, &data, &len);
+		memcpy(bg_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
+	Sql_FreeResult(sql_handle);
+	// Build WoE ranking list
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_wstats`.`char_id`, `char_wstats`.`points`, `%s`.`name` FROM `char_wstats` LEFT JOIN `%s` ON `%s`.`char_id` = `char_wstats`.`char_id` WHERE `char_wstats`.`points` > '0' ORDER BY `char_wstats`.`points` DESC LIMIT 0,%d", schema_config.char_db, schema_config.char_db, schema_config.char_db, fame_list_size_bg) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bg && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		// char_id
+		Sql_GetData(sql_handle, 0, &data, NULL);
+		woe_fame_list[i].id = atoi(data);
+		// fame
+		Sql_GetData(sql_handle, 1, &data, &len);
+		woe_fame_list[i].fame = atoi(data);
+		// name
+		Sql_GetData(sql_handle, 2, &data, &len);
+		memcpy(woe_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
+	Sql_FreeResult(sql_handle);
 }
 
 //Loads a character's name and stores it in the buffer given (must be NAME_LENGTH in size)
diff --git a/src/char/char.hpp b/src/char/char.hpp
index f03dd9b..58dac41 100644
--- a/src/char/char.hpp
+++ b/src/char/char.hpp
@@ -280,10 +280,14 @@ std::unordered_map<uint32, std::shared_ptr<struct mmo_charstatus>>& char_get_cha
 extern int fame_list_size_chemist;
 extern int fame_list_size_smith;
 extern int fame_list_size_taekwon;
+extern int fame_list_size_bg;
+extern int fame_list_size_woe;
 // Char-server-side stored fame lists [DracoRPG]
 extern struct fame_list smith_fame_list[MAX_FAME_LIST];
 extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
 extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
+extern struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 #define DEFAULT_AUTOSAVE_INTERVAL 300*1000
 #define MAX_CHAR_BUF sizeof( struct CHARACTER_INFO ) //Max size (for WFIFOHEAD calls)
diff --git a/src/char/char_mapif.cpp b/src/char/char_mapif.cpp
index 7fb3339..f889c87 100644
--- a/src/char/char_mapif.cpp
+++ b/src/char/char_mapif.cpp
@@ -101,11 +101,25 @@ int chmapif_send(int fd, unsigned char *buf, unsigned int len){
  * @return : 0 success
  */
 int chmapif_send_fame_list(int fd){
-	int i, len = 8;
+	int i, len = 12;
 	unsigned char buf[32000];
 
 	WBUFW(buf,0) = 0x2b1b;
 
+	for( i = 0; i < fame_list_size_woe && woe_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&woe_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	WBUFW(buf, 10) = len;
+
+	for( i = 0; i < fame_list_size_bg && bg_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&bg_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	WBUFW(buf, 8) = len;
+
 	for(i = 0; i < fame_list_size_smith && smith_fame_list[i].id; i++) {
 		memcpy(WBUFP(buf, len), &smith_fame_list[i], sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
@@ -1129,6 +1143,8 @@ int chmapif_parse_updfamelist(int fd){
 				case RANK_BLACKSMITH:	size = fame_list_size_smith;	list = smith_fame_list;		break;
 				case RANK_ALCHEMIST:	size = fame_list_size_chemist;	list = chemist_fame_list;	break;
 				case RANK_TAEKWON:		size = fame_list_size_taekwon;	list = taekwon_fame_list;	break;
+				case RANK_BG:			size = fame_list_size_bg;		list = bg_fame_list;		break;
+				case RANK_WOE:			size = fame_list_size_woe;		list = woe_fame_list;		break;
 				default:				size = 0;						list = NULL;				break;
             }
 
diff --git a/src/common/mmo.hpp b/src/common/mmo.hpp
index 311bf21..775670e 100644
--- a/src/common/mmo.hpp
+++ b/src/common/mmo.hpp
@@ -557,6 +557,119 @@ struct hotkey {
 };
 #endif
 
+// Extended Battleground [Easycore]
+struct s_battleground_stats {
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received,
+		boss_damage;
+	unsigned short
+		// Triple Inferno
+		skulls,
+		ti_wins, ti_lost, ti_tie,
+		// Tierra EoS
+		eos_flags,
+		eos_bases,
+		eos_wins, eos_lost, eos_tie,
+		// Tierra Bossnia
+		boss_killed,
+		boss_flags,
+		boss_wins, boss_lost, boss_tie,
+		// Tierra Domination
+		dom_bases,
+		dom_off_kills,
+		dom_def_kills,
+		dom_wins, dom_lost, dom_tie,
+		// Flavius TD
+		td_kills,
+		td_deaths,
+		td_wins, td_lost, td_tie,
+		// Flavius SC
+		sc_stole,
+		sc_captured,
+		sc_droped,
+		sc_wins, sc_lost, sc_tie,
+		// Flavius CTF
+		ctf_taken,
+		ctf_captured,
+		ctf_droped,
+		ctf_wins, ctf_lost, ctf_tie,
+		// Conquest
+		emperium_kill,
+		barricade_kill,
+		gstone_kill,
+		cq_wins, cq_lost,
+		// Rush
+		ru_captures,
+		ru_wins, ru_lost;
+
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+	unsigned short
+		kill_count,
+		death_count,
+		win, lost, tie,
+		leader_win, leader_lost, leader_tie,
+		deserter, rank_games;
+
+	int score, points, rank_points, showstats;
+};
+
+struct s_woestats {
+	int score;
+	unsigned short
+		kill_count,
+		death_count;
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received;
+	unsigned int
+		emperium_damage,
+		guardian_damage,
+		barricade_damage,
+		gstone_damage;
+	unsigned short
+		emperium_kill,
+		guardian_kill,
+		barricade_kill,
+		gstone_kill;
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+	int points, showstats;
+};
+
 struct mmo_charstatus {
 	uint32 char_id;
 	uint32 account_id;
@@ -598,6 +711,9 @@ struct mmo_charstatus {
 	uint32 mapip;
 	uint16 mapport;
 
+	struct s_battleground_stats bgstats; // Extended Feature [Easycore]
+	struct s_woestats wstats;
+
 	struct s_point_str last_point;
 	int32 last_point_instanceid;
 	struct s_point_str save_point;
@@ -1131,7 +1247,9 @@ enum e_rank {
 	RANK_BLACKSMITH = 0,
 	RANK_ALCHEMIST = 1,
 	RANK_TAEKWON = 2,
-	RANK_KILLER = 3
+	RANK_KILLER = 3,
+	RANK_BG = 4,
+	RANK_WOE = 5
 };
 
 struct clan_alliance {
diff --git a/src/common/utils.cpp b/src/common/utils.cpp
index 9ceff76..4fe1671 100644
--- a/src/common/utils.cpp
+++ b/src/common/utils.cpp
@@ -358,6 +358,16 @@ float GetFloat(const unsigned char* buf)
 	return *((float*)(void*)&val);
 }
 
+#define add2limit(a, b, max) \
+	do { \
+		if( (max - a) < b ) { \
+			a = max; \
+		} else { \
+			a += b; \
+		} \
+	} while(0)
+
+
 /// calculates the value of A / B, in percent (rounded down)
 unsigned int get_percentage(const unsigned int A, const unsigned int B)
 {
diff --git a/src/custom/atcommand.inc b/src/custom/atcommand.inc
index 9dd4a38..55832af 100644
--- a/src/custom/atcommand.inc
+++ b/src/custom/atcommand.inc
@@ -17,3 +17,260 @@
 //	clif_specialeffect(&sd->bl, EF_HEARTCASTING, AREA);
 //	return 0;
 //}
+
+
+/*==========================================
+ * Guild Skill Usage for Guild Masters
+ *------------------------------------------*/
+ACMD_FUNC(guildskill)
+{
+	int i, skillnum = 0, skill_lv = 0;
+	t_tick tick = gettick();
+
+	const struct { char skillstr[3]; int id; } skills[] = {
+		{ "BO",	10010 },
+		{ "RG",	10011 },
+		{ "RS",	10012 },
+		{ "EC",	10013 },
+	};
+
+	// Check for Skill ID
+	for(i = 0; i < ARRAYLENGTH(skills); i++) {
+		if( strncmpi(message, skills[i].skillstr, 3) == 0 )
+		{
+			skillnum = skills[i].id;
+			break;
+		}
+	}
+	if (!skillnum) {
+		clif_displaymessage(fd, msg_txt(sd, 2012)); // Unknown skill. Use @guildskill EC/RS/RG/BO
+		return -1;
+	}
+
+	if( !map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ) {
+		if( sd->state.gmaster_flag )
+			skill_lv = guild_checkskill(sd->guild->guild, skillnum);
+		else {
+			clif_displaymessage(fd, msg_txt(sd, 2013)); // This command is reserved for Guild Leaders.
+			return -1;
+		}
+	} else {
+		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+		if(bg && bg->leader_char_id == sd->status.char_id)
+			skill_lv = bg_checkskill(bg.get(), skillnum);
+		else {
+			clif_displaymessage(fd, msg_txt(sd, 2014)); // This command is reserved for Team Leaders.
+			return -1;
+		}
+	}
+
+	if (pc_cant_act(sd) || pc_issit(sd) || skill_isNotOk(skillnum, sd) || sd->ud.skilltimer != -1 || sd->sc.option&(OPTION_WEDDING|OPTION_XMAS|OPTION_SUMMER) || sd->sc.getSCE(SC_BASILICA))
+		return -1;
+
+	if (DIFF_TICK(tick, sd->ud.canact_tick) < 0)
+		return -1;
+
+	if (sd->menuskill_id) {
+		if (sd->menuskill_id == SA_TAMINGMONSTER)
+			sd->menuskill_id = sd->menuskill_val = 0; //Cancel pet capture.
+		else if (sd->menuskill_id != SA_AUTOSPELL)
+			return -1; //Can't use skills while a menu is open.
+	}
+
+	sd->skillitem = sd->skillitemlv = 0;
+	if (skill_lv != 0)
+		unit_skilluse_id(&sd->bl, sd->bl.id, skillnum, skill_lv);
+	return 0;
+}
+
+/*==========================================
+ * Guild Skill Info Usage
+ *------------------------------------------*/
+ACMD_FUNC(guildskillinfo)
+{
+	char output[CHAT_SIZE_MAX];
+	if (!(sd->bg_id || sd->guild)) {
+		clif_displaymessage(fd, msg_txt(sd, 2015)); // You need to be in a Guild or in a Battleground Arena.
+		return -1;
+	}
+
+	clif_displaymessage(fd, "=== Guild Skills Cooldown ===.");
+	if (guild_skills_timer(sd,10013) > 0) {
+		snprintf(output, sizeof(output), msg_txt(sd, 2016), guild_skills_timer(sd,10013)); // EC: %d seconds
+		clif_displaymessage(fd, output);
+	} else
+		clif_displaymessage(fd, msg_txt(sd, 2017)); // EC: Ready to use!
+
+	if (guild_skills_timer(sd,10010) > 0) {
+		snprintf(output, sizeof(output), msg_txt(sd, 2018), guild_skills_timer(sd,10010)); // BO: %d seconds
+		clif_displaymessage(fd, output);
+	} else
+		clif_displaymessage(fd, msg_txt(sd, 2019)); // BO: Ready to use!
+
+	if (guild_skills_timer(sd,10011) > 0) {
+		snprintf(output, sizeof(output), msg_txt(sd, 2020), guild_skills_timer(sd,10011)); // RG: %d seconds
+		clif_displaymessage(fd, output);
+	} else
+		clif_displaymessage(fd, msg_txt(sd, 2021)); // RG: Ready to use!
+
+	if (guild_skills_timer(sd,10012) > 0) {
+		snprintf(output, sizeof(output), msg_txt(sd, 2022), guild_skills_timer(sd,10012)); // RS: %d seconds
+		clif_displaymessage(fd, output);
+	} else
+		clif_displaymessage(fd, msg_txt(sd, 2023)); // RS: Ready to use!
+
+	return 0;
+}
+
+ACMD_FUNC(leader)
+{
+	map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !sd->state.bmaster_flag )
+		clif_displaymessage(fd, msg_txt(sd, 2014)); // This command is reserved for Team Leaders.
+	else if( sd->ud.skilltimer != INVALID_TIMER )
+		clif_displaymessage(fd, msg_txt(sd,2024)); // Command cannot be used while casting a skill.
+	else if( !message || !*message )
+		clif_displaymessage(fd, msg_txt(sd,2025)); // Please enter the name of the new Leader (usage: @leader <name>).
+	else if( (pl_sd = map_nick2sd((char *)message,false)) == NULL )
+		clif_displaymessage(fd, msg_txt(sd,3)); // Character not found.
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, msg_txt(sd,2026)); // The player is not part of your Team.
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, msg_txt(sd,2027)); // You are already the Team Leader.
+	else { // Everytest OK!
+		std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, sd->bg_id);
+		if (!bgteam)
+			return -1;
+
+		sprintf(atcmd_output, msg_txt(NULL,2028), pl_sd->status.name); // Team Leader transfered to [%s]
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, bgteam->color, 0x190, 20, 0, 0, BG);
+
+		bgteam->leader_char_id = pl_sd->status.char_id;
+		pl_sd->state.bmaster_flag = 1;
+		sd->state.bmaster_flag = 0;
+
+		clif_name_area(&sd->bl);
+		clif_name_area(&pl_sd->bl);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(reportafk)
+{
+	map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !sd->bg_id )
+		clif_displaymessage(fd, msg_txt(sd, 2029)); // This command is reserved for Battleground
+	else if( !sd->state.bmaster_flag && battle_config.bg_reportafk_leaderonly )
+		clif_displaymessage(fd, msg_txt(sd, 2014)); // This command is reserved for Team Leaders.
+	else if( !message || !*message )
+		clif_displaymessage(fd, msg_txt(sd, 2030)); // Please enter the AFK player's nick (usage: @reportafk <name>).
+	else if( (pl_sd = map_nick2sd((char *)message,false)) == NULL )
+		clif_displaymessage(fd, msg_txt(sd,3)); // Character not found.
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, msg_txt(sd,2026)); // The player is not part of your Team.
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, msg_txt(sd,2031)); // You cannot report yourself.
+	else if( pl_sd->state.bg_afk == 0 )
+		clif_displaymessage(fd, msg_txt(sd,2032)); // The player is not AFK in this Battleground
+	else { // Everytest OK!
+		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+		if(!bg)
+			return -1;
+
+		bg_team_leave(pl_sd, true, true);
+		clif_displaymessage(pl_sd->fd, msg_txt(sd,2001)); // You have been kicked from Battleground for your AFK status
+		pc_setpos(pl_sd,mapindex_name2id(pl_sd->status.save_point.map),pl_sd->status.save_point.x,pl_sd->status.save_point.y,CLR_OUTSIGHT);
+		clif_refresh(pl_sd);
+
+		sprintf(atcmd_output, msg_txt(sd, 2034), pl_sd->status.name); // - AFK [%s] Kicked -
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, bg->color, 0x190, 20, 0, 0, BG);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(listenbg)
+{
+	sd->state.bg_listen = (sd->state.bg_listen == 0);
+
+	if( sd->state.bg_listen )
+		clif_displaymessage(fd, msg_txt(sd,2035)); // You will receive announces from Battleground
+	else
+		clif_displaymessage(fd, msg_txt(sd,2036)); // You no longer will receive announces from Battleground
+
+	return 0;
+}
+
+ACMD_FUNC(order)
+{
+	nullpo_retr(-1,sd);
+	if (!message || !*message) {
+		clif_displaymessage(fd, msg_txt(sd,2037)); // Please write a message (usage: @order <message>).
+		return -1;
+	}
+
+	if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+		if( !sd->state.bmaster_flag )
+		{
+			clif_displaymessage(fd, msg_txt(sd,2014)); // This command is reserved for Team Leaders.
+			return -1;
+		}
+		std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, sd->bg_id);
+		if (!bgteam)
+			return -1;
+
+		clif_broadcast2(&sd->bl, message, (int)strlen(message)+1, bgteam->color, 0x190, 20, 0, 0, BG);
+	}
+	else {
+		if (!sd->state.gmaster_flag) {
+			clif_displaymessage(fd, msg_txt(sd, 2013)); // This command is reserved for Guild Leaders.
+			return -1;
+		}
+		clif_broadcast2(&sd->bl, message, (int)strlen(message)+1, 0xFF0000, 0x190, 20, 0, 0, GUILD);
+	}
+
+	return 0;
+}
+
+ACMD_FUNC(bgrank)
+{
+	int i;
+
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "============ BATTLEGROUND RANK ============", false, SELF);
+	for( i = 0; i < MAX_FAME_LIST; i++ )
+	{
+		if (!bg_fame_list[i].id)
+			sprintf(atcmd_output,"[ %d ] None        :    0 POINT",i+1);
+		else
+			sprintf(atcmd_output,"[ %d ] %s        :    %d POINT",i+1,bg_fame_list[i].name,bg_fame_list[i].fame);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], atcmd_output, false, SELF);
+	}
+	sprintf(atcmd_output,"MY POINT    :    %d POINT",sd->status.bgstats.points);
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "===========================================", false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], atcmd_output, false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "===========================================", false, SELF);
+	return 0;
+}
+
+ACMD_FUNC(woerank)
+{
+	int i;
+
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "============ WAR OF EMPERIUM RANK ============", false, SELF);
+	for( i = 0; i < MAX_FAME_LIST; i++ )
+	{
+		if (!woe_fame_list[i].id)
+			sprintf(atcmd_output,"[ %d ] None        :    0 POINT",i+1);
+		else
+			sprintf(atcmd_output,"[ %d ] %s        :    %d POINT",i+1,woe_fame_list[i].name,woe_fame_list[i].fame);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], atcmd_output, false, SELF);
+	}
+	sprintf(atcmd_output,"MY POINT    :    %d POINT",sd->status.wstats.points);
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "===========================================", false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], atcmd_output, false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "===========================================", false, SELF);
+	return 0;
+}
diff --git a/src/custom/atcommand_def.inc b/src/custom/atcommand_def.inc
index 2b018c7..8837853 100644
--- a/src/custom/atcommand_def.inc
+++ b/src/custom/atcommand_def.inc
@@ -12,3 +12,12 @@
 
 
 ACMD_DEF(atkmode),
+
+ACMD_DEF(guildskill),
+ACMD_DEF(guildskillinfo),
+ACMD_DEF(leader),
+ACMD_DEF(reportafk),
+ACMD_DEF(order),
+ACMD_DEF(listenbg),
+ACMD_DEF(bgrank),
+ACMD_DEF(woerank),
diff --git a/src/custom/script.inc b/src/custom/script.inc
index 124380d..fadafbf 100644
--- a/src/custom/script.inc
+++ b/src/custom/script.inc
@@ -25,3 +25,933 @@ BUILDIN_FUNC(zoneicon)
 
     return SCRIPT_CMD_SUCCESS;
 }
+
+
+BUILDIN_FUNC(bg_queue_join)
+{
+	int num;
+	const char *name;
+	TBL_PC *sd;
+
+	name = script_getstr(st,2);
+	num = script_getnum(st,3);
+
+	if( !script_nick2sd(4,sd) ){
+		script_pushint(st,0); //return 0, according docs
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	switch( num ) {
+		default:
+		case 0: bg_queue_join_solo(name, sd); break;
+		case 1: bg_queue_join_party(name, sd); break;
+		case 2: bg_queue_join_guild(name, sd); break;
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_queue_leave_all)
+{
+	bg_queue_leave_all();
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_queue_transfer_all)
+{
+	const char * queue_source = script_getstr(st,2);
+	const char * queue_dest = script_getstr(st,3);
+
+	if (!bg_queue_transfer_all(queue_source, queue_dest))
+		return SCRIPT_CMD_FAILURE;
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(getcharqueue)
+{
+	//int num;
+	TBL_PC *sd;
+
+	if( !script_nick2sd(2,sd) ){
+		script_pushint(st,-1);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	if (!sd->bg_queue_id) {
+		script_pushint(st,-1); //return 0, according docs
+		return SCRIPT_CMD_SUCCESS;
+	}
+	script_pushint(st,sd->bg_queue_id);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_queue_show)
+{
+	//int num;
+	TBL_PC *sd;
+
+	if( !script_nick2sd(2,sd) ){
+		script_pushint(st,0);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	if (!sd->bg_queue_id) {
+		script_pushint(st,0); //return 0, according docs
+		return SCRIPT_CMD_SUCCESS;
+	}
+	clif_bg_queue_apply_notify("test", sd);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+
+
+BUILDIN_FUNC(bg_afk_warning)
+{
+	int bg_id = script_getnum(st, 2);
+	bool flag = script_getnum(st, 3) != 0;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (!bg)
+		return SCRIPT_CMD_SUCCESS;
+
+	for (const auto &member : bg->members)
+		member.sd->idletime = last_tick;
+
+	bg->afk_warning = flag;
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_team_reveal)
+{
+	int bg_id = script_getnum(st, 2);
+	bool reveal = script_getnum(st, 3) != 0;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (!bg)
+		return 0;
+
+	bg->reveal_pos = reveal; // Reveal Position Mode
+	return 0;
+}
+
+int viewpointmap_sub(struct block_list *bl, va_list ap)
+{
+	map_session_data *sd;
+	int npc_id, type, x, y, id, color;
+	npc_id = va_arg(ap, int);
+	type = va_arg(ap, int);
+	x = va_arg(ap, int);
+	y = va_arg(ap, int);
+	id = va_arg(ap, int);
+	color = va_arg(ap, int);
+	sd = (map_session_data *)bl;
+	clif_viewpoint(sd, npc_id, type, x, y, id, color);
+	return 0;
+}
+
+BUILDIN_FUNC(viewpointmap2)
+{
+	int type, x, y, id, color, m;
+	const char *map_name;
+
+	map_name = script_getstr(st, 2);
+	if ((m = map_mapname2mapid(map_name)) < 0)
+		return SCRIPT_CMD_FAILURE; // Invalid Map
+
+	type = script_getnum(st, 3);
+	x = script_getnum(st, 4);
+	y = script_getnum(st, 5);
+	id = script_getnum(st, 6);
+	color = script_getnum(st, 7);
+
+	map_foreachinmap(viewpointmap_sub, m, BL_PC, st->oid, type, x, y, id, color);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_monster_reveal)
+{
+	struct mob_data *md;
+	struct block_list *mbl;
+	int id = script_getnum(st, 2),
+		flag = script_getnum(st, 3),
+		color = script_getnum(st, 4);
+
+	if (id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB)
+		return 0;
+	md = (TBL_MOB *)mbl;
+	map_foreachinmap(viewpointmap_sub, mbl->m, BL_PC, st->oid, flag, mbl->x, mbl->y, mbl->id, color);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_getitem)
+{
+	int bg_id, nameid, amount, flag;
+
+	bg_id = script_getnum(st, 2);
+	nameid = script_getnum(st, 3);
+	amount = script_getnum(st, 4);
+	flag = script_getnum(st, 5);
+
+	bg_team_getitem(bg_id, nameid, amount, flag);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_reward)
+{
+	int bg_id, nameid, amount, kafrapoints, quest_id, add_value, bg_arena, bg_result, fame;
+	const char *var;
+
+	bg_id = script_getnum(st, 2);
+	nameid = script_getnum(st, 3);
+	amount = script_getnum(st, 4);
+	kafrapoints = script_getnum(st, 5);
+	quest_id = script_getnum(st, 6);
+	var = script_getstr(st, 7);
+	add_value = script_getnum(st, 8);
+	bg_arena = script_getnum(st, 9);
+	bg_result = script_getnum(st, 10);
+	fame = script_getnum(st, 11);
+
+	bg_team_rewards(bg_id, nameid, amount, kafrapoints, quest_id, var, add_value, bg_arena, bg_result, fame);
+	return 0;
+}
+/// Sets the bg_id of this npc.
+///
+/// flagemblem <bg_id>;
+BUILDIN_FUNC(bg_flagemblem)
+{
+	TBL_NPC* nd;
+	int bg_id = script_getnum(st,2);
+
+	if(bg_id < 0)
+		return SCRIPT_CMD_SUCCESS;
+
+	nd = (TBL_NPC*)map_id2nd(st->oid);
+	if( nd == NULL ) {
+		ShowError("script:bg_flagemblem: npc %d not found\n", st->oid);
+	} else if( nd->subtype != NPCTYPE_SCRIPT ) {
+		ShowError("script:bg_flagemblem: unexpected subtype %d for npc %d '%s'\n", nd->subtype, st->oid, nd->exname);
+	} else {
+		bool changed = ( nd->u.scr.bg_id != bg_id )?true:false;
+		nd->u.scr.bg_id = bg_id;
+		clif_guild_emblem_area(&nd->bl);
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+
+// Extended Features BG [Easycore]
+// For now, only used to add statistics
+BUILDIN_FUNC(bg_rankpoints)
+{
+	TBL_PC *sd;
+	int add_value, fame, type;
+
+	if( !script_accid2sd(5,sd) )
+		return SCRIPT_CMD_FAILURE;
+
+	if(!sd)
+		return SCRIPT_CMD_FAILURE;
+
+	type = script_getnum(st,2);
+	add_value = script_getnum(st,3);
+	fame = script_getnum(st,4);
+
+	if (type < BGR_FAME || type > BGR_MAX) {
+		ShowError("buildin_bg_rankpoints: Unknown type \"%d\".\n", type);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	if (fame)
+		pc_addbgpoints(sd,fame);
+
+	switch(type) {
+		case BGR_FAME:
+			if (!fame)
+				pc_addbgpoints(sd,add_value);
+			break;
+		case BGR_SKULLS:
+			add2limit(sd->status.bgstats.skulls,add_value,USHRT_MAX);
+			break;
+		case BGR_EOS_FLAGS:
+			add2limit(sd->status.bgstats.eos_flags,add_value,USHRT_MAX);
+			break;
+		case BGR_SC_STOLE:
+			add2limit(sd->status.bgstats.sc_stole,add_value,USHRT_MAX);
+			break;
+		case BGR_SC_CAPTURED:
+			add2limit(sd->status.bgstats.sc_captured,add_value,USHRT_MAX);
+			break;
+		case BGR_SC_DROPPED:
+			add2limit(sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+			break;
+		case BGR_CTF_TAKEN:
+			add2limit(sd->status.bgstats.ctf_taken,add_value,USHRT_MAX);
+			break;
+		case BGR_CTF_CAPTURED:
+			add2limit(sd->status.bgstats.ctf_captured,add_value,USHRT_MAX);
+			break;
+		case BGR_CTF_DROPPED:
+			add2limit(sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+			break;
+		case BGR_DOM_BASES:
+			add2limit(sd->status.bgstats.dom_bases,add_value,USHRT_MAX);
+			break;
+		case BGR_DOM_OFF_KILLS:
+			add2limit(sd->status.bgstats.dom_off_kills,add_value,USHRT_MAX);
+			break;
+		case BGR_DOM_DEF_KILLS:
+			add2limit(sd->status.bgstats.dom_def_kills,add_value,USHRT_MAX);
+			break;
+		case BGR_BARRICADE:
+			add2limit(sd->status.bgstats.barricade_kill,add_value,USHRT_MAX);
+			break;
+		case BGR_EMPERIUM:
+			add2limit(sd->status.bgstats.emperium_kill,add_value,USHRT_MAX);
+			break;
+		case BGR_GSTONE:
+			add2limit(sd->status.bgstats.gstone_kill,add_value,USHRT_MAX);
+			break;
+		case BGR_RU_CAPTURES:
+			add2limit(sd->status.bgstats.ru_captures,add_value,USHRT_MAX);
+			break;
+		case BGR_BOSS_FLAGS:
+			add2limit(sd->status.bgstats.boss_flags,add_value,USHRT_MAX);
+			break;
+		case BGR_BOSS_KILLED:
+			add2limit(sd->status.bgstats.boss_killed,add_value,USHRT_MAX);
+			break;
+		case BGR_TD_KILL:
+			add2limit(sd->status.bgstats.td_kills,add_value,USHRT_MAX);
+			break;
+		case BGR_TD_DEATH:
+			add2limit(sd->status.bgstats.td_deaths,add_value,USHRT_MAX);
+			break;
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_rankpoints_area)
+{
+	const char *str;
+	int m, x0, y0, x1, y1, bg_id;
+	int add_value, type;
+	int fame;
+
+	bg_id = script_getnum(st,2);
+	str = script_getstr(st,3);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (!bg || (m = map_mapname2mapid(str)) < 0)
+		return SCRIPT_CMD_SUCCESS;
+
+	x0 = script_getnum(st,4);
+	y0 = script_getnum(st,5);
+	x1 = script_getnum(st,6);
+	y1 = script_getnum(st,7);
+	type = script_getnum(st,8);
+
+	if (type < BGR_FAME || type > BGR_MAX) {
+		ShowError("buildin_bg_rankpoints_area: Unknown type \"%d\".\n", type);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	add_value = script_getnum(st,9);
+	fame = script_getnum(st,10);
+	for (const auto &member : bg->members) {
+		if (member.sd->bl.m != m || member.sd->bl.x < x0 || member.sd->bl.y < y0 || member.sd->bl.x > x1 || member.sd->bl.y > y1)
+			continue;
+
+		if (fame)
+			pc_addbgpoints(member.sd,fame);
+
+		switch(type) {
+			case BGR_FAME:
+				if (!fame)
+					pc_addbgpoints(member.sd,add_value);
+				break;
+			case BGR_SKULLS:
+				add2limit(member.sd->status.bgstats.skulls,add_value,USHRT_MAX);
+				break;
+			case BGR_EOS_FLAGS:
+				add2limit(member.sd->status.bgstats.eos_flags,add_value,USHRT_MAX);
+				break;
+			case BGR_SC_STOLE:
+				add2limit(member.sd->status.bgstats.sc_stole,add_value,USHRT_MAX);
+				break;
+			case BGR_SC_CAPTURED:
+				add2limit(member.sd->status.bgstats.sc_captured,add_value,USHRT_MAX);
+				break;
+			case BGR_SC_DROPPED:
+				add2limit(member.sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+				break;
+			case BGR_CTF_TAKEN:
+				add2limit(member.sd->status.bgstats.ctf_taken,add_value,USHRT_MAX);
+				break;
+			case BGR_CTF_CAPTURED:
+				add2limit(member.sd->status.bgstats.ctf_captured,add_value,USHRT_MAX);
+				break;
+			case BGR_CTF_DROPPED:
+				add2limit(member.sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+				break;
+			case BGR_DOM_BASES:
+				add2limit(member.sd->status.bgstats.dom_bases,add_value,USHRT_MAX);
+				break;
+			case BGR_DOM_OFF_KILLS:
+				add2limit(member.sd->status.bgstats.dom_off_kills,add_value,USHRT_MAX);
+				break;
+			case BGR_DOM_DEF_KILLS:
+				add2limit(member.sd->status.bgstats.dom_def_kills,add_value,USHRT_MAX);
+				break;
+			case BGR_BARRICADE:
+				add2limit(member.sd->status.bgstats.barricade_kill,add_value,USHRT_MAX);
+				break;
+			case BGR_EMPERIUM:
+				add2limit(member.sd->status.bgstats.emperium_kill,add_value,USHRT_MAX);
+				break;
+			case BGR_GSTONE:
+				add2limit(member.sd->status.bgstats.gstone_kill,add_value,USHRT_MAX);
+				break;
+			case BGR_RU_CAPTURES:
+				add2limit(member.sd->status.bgstats.ru_captures,add_value,USHRT_MAX);
+				break;
+			case BGR_BOSS_FLAGS:
+				add2limit(member.sd->status.bgstats.boss_flags,add_value,USHRT_MAX);
+				break;
+			case BGR_BOSS_KILLED:
+				add2limit(member.sd->status.bgstats.boss_killed,add_value,USHRT_MAX);
+				break;
+			case BGR_TD_KILL:
+				add2limit(member.sd->status.bgstats.td_kills,add_value,USHRT_MAX);
+				break;
+			case BGR_TD_DEATH:
+				add2limit(member.sd->status.bgstats.td_deaths,add_value,USHRT_MAX);
+				break;
+		}
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_rankpoints_team)
+{
+	//const char *str;
+	int bg_id;
+	int type, add_value;
+	int fame;
+
+	bg_id = script_getnum(st,2);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (!bg)
+		return SCRIPT_CMD_SUCCESS;
+
+	type = script_getnum(st,3);
+
+	if (type < BGR_FAME || type > BGR_MAX) {
+		ShowError("buildin_bg_rankpoints_area: Unknown type \"%d\".\n", type);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	add_value = script_getnum(st,4);
+	fame = script_getnum(st,5);
+	for (const auto &member : bg->members) {
+
+		if (fame)
+			pc_addbgpoints(member.sd,fame);
+
+		switch(type) {
+			case BGR_FAME:
+				if (!fame)
+					pc_addbgpoints(member.sd,add_value);
+				break;
+			case BGR_SKULLS:
+				add2limit(member.sd->status.bgstats.skulls,add_value,USHRT_MAX);
+				break;
+			case BGR_EOS_FLAGS:
+				add2limit(member.sd->status.bgstats.eos_flags,add_value,USHRT_MAX);
+				break;
+			case BGR_SC_STOLE:
+				add2limit(member.sd->status.bgstats.sc_stole,add_value,USHRT_MAX);
+				break;
+			case BGR_SC_CAPTURED:
+				add2limit(member.sd->status.bgstats.sc_captured,add_value,USHRT_MAX);
+				break;
+			case BGR_SC_DROPPED:
+				add2limit(member.sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+				break;
+			case BGR_CTF_TAKEN:
+				add2limit(member.sd->status.bgstats.ctf_taken,add_value,USHRT_MAX);
+				break;
+			case BGR_CTF_CAPTURED:
+				add2limit(member.sd->status.bgstats.ctf_captured,add_value,USHRT_MAX);
+				break;
+			case BGR_CTF_DROPPED:
+				add2limit(member.sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+				break;
+			case BGR_DOM_BASES:
+				add2limit(member.sd->status.bgstats.dom_bases,add_value,USHRT_MAX);
+				break;
+			case BGR_DOM_OFF_KILLS:
+				add2limit(member.sd->status.bgstats.dom_off_kills,add_value,USHRT_MAX);
+				break;
+			case BGR_DOM_DEF_KILLS:
+				add2limit(member.sd->status.bgstats.dom_def_kills,add_value,USHRT_MAX);
+				break;
+			case BGR_BARRICADE:
+				add2limit(member.sd->status.bgstats.barricade_kill,add_value,USHRT_MAX);
+				break;
+			case BGR_EMPERIUM:
+				add2limit(member.sd->status.bgstats.emperium_kill,add_value,USHRT_MAX);
+				break;
+			case BGR_GSTONE:
+				add2limit(member.sd->status.bgstats.gstone_kill,add_value,USHRT_MAX);
+				break;
+			case BGR_RU_CAPTURES:
+				add2limit(member.sd->status.bgstats.ru_captures,add_value,USHRT_MAX);
+				break;
+			case BGR_BOSS_FLAGS:
+				add2limit(member.sd->status.bgstats.boss_flags,add_value,USHRT_MAX);
+				break;
+			case BGR_BOSS_KILLED:
+				add2limit(member.sd->status.bgstats.boss_killed,add_value,USHRT_MAX);
+				break;
+			case BGR_TD_KILL:
+				add2limit(member.sd->status.bgstats.td_kills,add_value,USHRT_MAX);
+				break;
+			case BGR_TD_DEATH:
+				add2limit(member.sd->status.bgstats.td_deaths,add_value,USHRT_MAX);
+				break;
+		}
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_queue_info)
+{
+	int queue_id, flag;
+	queue_id = script_getnum(st, 2);
+	flag = script_getnum(st, 3);
+
+	std::shared_ptr<s_battleground_queue> queue;
+	if ((queue = bg_search_queue_id(queue_id)) == nullptr) {
+		ShowError("buildin_bg_queue_info: Unknown queue id %d.\n", queue_id);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	std::shared_ptr<s_battleground_type> bg;
+	if ((bg = battleground_db.find(queue_id)) == nullptr) {
+		ShowError("buildin_bg_queue_info: Unknown battleground id %d.\n", queue_id);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	switch(flag) {
+		case 0: script_pushstrcopy(st, bg->name.c_str()); break;
+		case 1: script_pushint(st, bg->required_players); break;
+		case 2: script_pushint(st, queue->id); break;
+		case 3: script_pushint(st, queue->teama_members.size()+queue->teamb_members.size()); break;
+		default:
+			ShowError("buildin_bg_queue_info: Unknown flag type %d.\n", flag);
+			return SCRIPT_CMD_FAILURE;
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_set_data)
+{
+	int queue_id, type, val1, val2;
+	queue_id = script_getnum(st, 2);
+
+	std::shared_ptr<s_battleground_queue> queue;
+	if ((queue = bg_search_queue_id(queue_id)) == nullptr) {
+		ShowError("buildin_bg_set_data: Unknown queue id %d.\n", queue_id);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	std::shared_ptr<s_battleground_type> bg;
+	if ((bg = battleground_db.find(queue_id)) == nullptr) {
+		ShowError("buildin_bg_set_data: Unknown battleground id %d.\n", queue_id);
+		return SCRIPT_CMD_FAILURE;
+	}
+	type = script_getnum(st, 3);
+	val1 = script_getnum(st, 4);
+	val2 = script_getnum(st, 5);
+
+	switch(type) {
+		case 0:
+			if (val1 < 1) {
+				ShowError("buildin_bg_set_data: val1 cannot be lower than 1.\n");
+				return SCRIPT_CMD_FAILURE;
+			}
+			bg->required_players = val1;
+			break;
+		default:
+			ShowError("buildin_bg_set_data: Unknown type type %d.\n", type);
+			return SCRIPT_CMD_FAILURE;
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_queue_finish)
+{
+	int queue_id= script_getnum(st,2);
+
+	std::shared_ptr<s_battleground_queue> queue;
+	if ((queue = bg_search_queue_id(queue_id)) == nullptr) {
+		ShowError("buildin_bg_queue_info: Unknown queue id %d.\n", queue_id);
+		return SCRIPT_CMD_FAILURE;
+	}
+	bg_queue_clear(queue,true);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+/*==========================================
+ * Reset battle rank
+ * type :
+ *	1 : Battleground Rank
+ *	2 : War of Emperium Rank
+ *------------------------------------------*/
+BUILDIN_FUNC(battle_rank_reset)
+{
+	int type = script_getnum(st,2);
+
+	if (type < 1 && type > 2)
+		return SCRIPT_CMD_FAILURE;
+
+	if (type == 1)
+		type = RANK_BG;
+	else
+		type = RANK_WOE;
+
+	pc_rank_reset(type);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_set_cemetery)
+{
+	int bg_id,x,y,mapindex;
+	const char* str;
+	bg_id = script_getnum(st, 2);
+	str = script_getstr(st,3);
+	x = script_getnum(st,4);
+	y = script_getnum(st,5);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if (!bg)
+		return SCRIPT_CMD_FAILURE;
+
+	mapindex = mapindex_name2id(str);
+	if (!mapindex)// Invalid map
+		return SCRIPT_CMD_FAILURE;
+
+	bg->cemetery.map = mapindex;
+	bg->cemetery.x = x;
+	bg->cemetery.y = y;
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_announce)
+{
+	const char *mes = script_getstr(st, 2);
+	const char *fontColor = script_hasdata(st, 3) ? script_getstr(st, 3) : "0xFFFFFF";
+	int         fontType = script_hasdata(st, 4) ? script_getnum(st, 4) : 0x190; // default fontType (FW_NORMAL)
+	int         fontSize = script_hasdata(st, 5) ? script_getnum(st, 5) : 12;    // default fontSize
+	int         fontAlign = script_hasdata(st, 6) ? script_getnum(st, 6) : 0;     // default fontAlign
+	int         fontY = script_hasdata(st, 7) ? script_getnum(st, 7) : 0;     // default fontY
+
+	clif_broadcast2(NULL, mes, (int)strlen(mes) + 1, strtol(fontColor, (char **)NULL, 0), fontType, fontSize, fontAlign, fontY, BG_LISTEN);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+/*==========================================
+ * Return fame rank position
+ * return by @num :
+ *	0 : Battleground Rank
+ *	1 : War of Emperium Rank
+ *------------------------------------------*/
+BUILDIN_FUNC(getcharrank)
+{
+	int num;
+	TBL_PC *sd;
+
+	num = script_getnum(st,2);
+
+	if( !script_charid2sd(3,sd) ){
+		script_pushint(st,-1); //return 0, according docs
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	switch( num ) {
+	case 0: script_pushint(st,pc_famerank(sd->status.char_id, -1)); break;
+	case 1: script_pushint(st,pc_famerank(sd->status.char_id, -2)); break;
+	default:
+		ShowError("buildin_getcharrank: invalid parameter (%d).\n", num);
+		script_pushint(st,0);
+		break;
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_soundeffect)
+{
+	int bg_id = script_getnum(st,3);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_soundeffect: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	const char* name = script_getstr(st,2);
+
+	for (const auto &member : bg->members)
+		clif_soundeffect(member.sd->bl, name, 0, SELF);
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_specialeffect)
+{
+	int bg_id = script_getnum(st,3);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_specialeffect: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	int type = script_getnum(st,2);
+
+	for (const auto &member : bg->members)
+		clif_specialeffect(&member.sd->bl, type, AREA);
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_emotion)
+{
+	int bg_id = script_getnum(st,3);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_specialeffect: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	int type = script_getnum(st,2);
+
+	if (type < ET_SURPRISE || type >= ET_MAX) {
+		ShowWarning("buildin_bg_emotion: Unknown emotion %d (min=%d, max=%d).\n", type, ET_SURPRISE, (ET_MAX-1));
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	for (const auto &member : bg->members)
+		clif_emotion(&member.sd->bl, type);
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+
+BUILDIN_FUNC(bg_sc_end)
+{
+	int bg_id = script_getnum(st,3);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_sc_end: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	int type = script_getnum(st,2);
+
+	if (type > SC_NONE && type < SC_MAX) {
+		std::shared_ptr<s_status_change_db> sc_db = status_db.find( type );
+
+		if( sc_db == nullptr ){
+			ShowError( "buildin_bg_sc_end: Unknown status change %d.\n", type );
+			return SCRIPT_CMD_FAILURE;
+		}
+
+		if (sc_db->flag[SCF_NOCLEARBUFF] && sc_db->flag[SCF_NOFORCEDEND]) {
+			ShowError( "buildin_bg_sc_end: Status %d cannot be cleared.\n", type );
+			return SCRIPT_CMD_FAILURE;
+		}
+
+		for (const auto &member : bg->members)
+			status_change_end(&member.sd->bl, (sc_type)type);
+	} else {
+		for (const auto &member : bg->members)
+			status_change_clear(&member.sd->bl, 3); // remove all effects
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+/* Starts a status effect on the target unit or on the attached player.
+ *
+ * bg_sc_start  <bg_team_id>,<effect_id>,<duration>,<val1>{,<rate>,<flag>,{<unit_id>}};
+ * bg_sc_start2 <bg_team_id>,<effect_id>,<duration>,<val1>,<val2>{,<rate,<flag>,{<unit_id>}};
+ * bg_sc_start4 <bg_team_id>,<effect_id>,<duration>,<val1>,<val2>,<val3>,<val4>{,<rate,<flag>,{<unit_id>}};
+ * <flag>: enum e_status_change_start_flags
+ */
+BUILDIN_FUNC(bg_sc_start)
+{
+	int bg_id = script_getnum(st,2);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_sc_end: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	enum sc_type type;
+	int tick, val1, val2, val3, val4=0, rate, flag;
+	char start_type;
+	const char* command = script_getfuncname(st);
+
+	if(strstr(command, "4"))
+		start_type = 4;
+	else if(strstr(command, "2"))
+		start_type = 2;
+	else
+		start_type = 1;
+
+	type = (sc_type)script_getnum(st,3);
+	tick = script_getnum(st,4);
+	val1 = script_getnum(st,5);
+	flag = script_hasdata(st,6+start_type)?script_getnum(st,6+start_type):SCSTART_NOAVOID;
+	rate = script_hasdata(st,5+start_type)?min(script_getnum(st,5+start_type),10000):10000;
+
+	uint16 skill_id;
+
+	if(tick == 0 && val1 > 0 && type > SC_NONE && type < SC_MAX && (skill_id = status_db.getSkill(type)) > 0)
+	{// When there isn't a duration specified, try to get it from the skill_db
+		tick = skill_get_time(skill_id, val1);
+	}
+
+	switch(start_type) {
+		case 1:
+			for (const auto &member : bg->members)
+				status_change_start(&member.sd->bl, &member.sd->bl, type, rate, val1, 0, 0, val4, tick, flag);
+			break;
+		case 2:
+			val2 = script_getnum(st,6);
+			for (const auto &member : bg->members)
+				status_change_start(&member.sd->bl, &member.sd->bl, type, rate, val1, val2, 0, val4, tick, flag);
+			break;
+		case 4:
+			val2 = script_getnum(st,6);
+			val3 = script_getnum(st,7);
+			val4 = script_getnum(st,8);
+			for (const auto &member : bg->members)
+				status_change_start(&member.sd->bl, &member.sd->bl, type, rate, val1, val2, val3, val4, tick, flag);
+			break;
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_percentheal)
+{
+	int bg_id = script_getnum(st,2);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_sc_end: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	int hp = script_getnum(st,3);
+	int sp = script_getnum(st,4);
+
+	for (const auto &member : bg->members) {
+		if (member.sd->sc.getSCE(SC_NORECOVER_STATE))
+			continue;
+		pc_percentheal(member.sd,hp,sp);
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_team_leave)
+{
+	int bg_id = script_getnum(st,2);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg == nullptr) {
+		ShowError("buildin_bg_team_leave: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	for (const auto &member : bg->members)
+		bg_team_leave(member.sd, false, false);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_clear_buffs)
+{
+	int bg_id = script_getnum(st,2);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if (bg == nullptr) {
+		ShowError("buildin_bg_clear_buffs: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	uint8 type = script_getnum(st,3);
+
+	for (const auto &member : bg->members)
+		status_change_clear_buffs(&member.sd->bl, type);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_clear_buffs_area)
+{
+	int bg_id = script_getnum(st,2);
+	const char *str = script_getstr(st,4);
+	int m, x0, y0, x1, y1;
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if (bg == nullptr) {
+		ShowError("buildin_bg_clear_buffs_area: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	if ((m = map_mapname2mapid(str)) < 0) {
+		ShowError("buildin_bg_clear_buffs_area: unexistent map (%s).\n", str);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	uint8 type = script_getnum(st,3);
+	x0 = script_getnum(st,5);
+	y0 = script_getnum(st,6);
+	x1 = script_getnum(st,7);
+	y1 = script_getnum(st,8);
+
+	for (const auto &member : bg->members) {
+		if (member.sd->bl.m != m || member.sd->bl.x < x0 || member.sd->bl.y < y0 || member.sd->bl.x > x1 || member.sd->bl.y > y1)
+			continue;
+		status_change_clear_buffs(&member.sd->bl, type);
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_warp_cemetery)
+{
+	int bg_id= script_getnum(st,2);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if (bg == nullptr) {
+		ShowError("buildin_bg_warp_cemetery: unexistent bg team (%d).\n", bg_id);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	bg_team_warp(bg_id, bg->cemetery.map, bg->cemetery.x, bg->cemetery.y);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+/*==========================================
+ *------------------------------------------*/
+BUILDIN_FUNC(donpceventall)
+{
+	const char* event = script_getstr(st,2);
+	npc_event_doall(event);
+	return SCRIPT_CMD_SUCCESS;
+}
diff --git a/src/custom/script_def.inc b/src/custom/script_def.inc
index 3e703c2..0a39f39 100644
--- a/src/custom/script_def.inc
+++ b/src/custom/script_def.inc
@@ -10,3 +10,40 @@
 
 BUILDIN_DEF(zoneicon,"iiii"),
 
+
+//Extended Battleground [Easycore]
+BUILDIN_DEF(bg_queue_join,"si?"),
+BUILDIN_DEF(bg_queue_leave_all,""),
+BUILDIN_DEF(getcharqueue,"?"),
+BUILDIN_DEF(bg_queue_show,"?"),
+BUILDIN_DEF(viewpointmap2, "siiiii"),
+BUILDIN_DEF(bg_team_reveal, "ii"),
+BUILDIN_DEF(bg_afk_warning, "ii"),
+BUILDIN_DEF(bg_getitem, "iiii"),
+BUILDIN_DEF(bg_reward, "iiiiisiiii"),
+BUILDIN_DEF(bg_flagemblem, "i"),
+BUILDIN_DEF(bg_monster_reveal, "iii"),
+BUILDIN_DEF(bg_queue_info, "ii"),
+BUILDIN_DEF(bg_set_data, "iiii"),
+BUILDIN_DEF(bg_queue_finish, "i"),
+BUILDIN_DEF(bg_queue_transfer_all,"ss"),
+BUILDIN_DEF(donpceventall, "s"),
+BUILDIN_DEF(bg_rankpoints,"iii?"),
+BUILDIN_DEF(bg_rankpoints_team,"iiii"),
+BUILDIN_DEF(bg_rankpoints_area,"isiiiiiii"),
+BUILDIN_DEF(battle_rank_reset,"i"),
+BUILDIN_DEF(bg_set_cemetery,"isii"),
+BUILDIN_DEF(bg_announce, "s?????"),
+BUILDIN_DEF(bg_soundeffect, "si"),
+BUILDIN_DEF(bg_specialeffect, "ii"),
+BUILDIN_DEF(bg_emotion, "ii"),
+BUILDIN_DEF(bg_team_leave, "i"),
+BUILDIN_DEF(bg_clear_buffs, "ii"),
+BUILDIN_DEF(bg_clear_buffs_area, "iisiiii"),
+BUILDIN_DEF(bg_warp_cemetery, "i"),
+BUILDIN_DEF(bg_sc_end, "ii"),
+BUILDIN_DEF(bg_sc_start,"iiii???"),
+BUILDIN_DEF2(bg_sc_start,"bg_sc_start2","iiiii??"),
+BUILDIN_DEF2(bg_sc_start,"bg_sc_start4","iiiiiii??"),
+BUILDIN_DEF(bg_percentheal, "iii"),
+BUILDIN_DEF(getcharrank,"i?"),
diff --git a/src/map/battle.cpp b/src/map/battle.cpp
index d89e624..7b6b097 100644
--- a/src/map/battle.cpp
+++ b/src/map/battle.cpp
@@ -2593,9 +2593,14 @@ void battle_consume_ammo(map_session_data*sd, int skill, int lv)
 		if (!qty) qty = 1;
 	}
 
-	if (sd->equip_index[EQI_AMMO] >= 0) //Qty check should have been done in skill_check_condition
+	if (sd->equip_index[EQI_AMMO] >= 0) { //Qty check should have been done in skill_check_condition
 		pc_delitem(sd,sd->equip_index[EQI_AMMO],qty,0,1,LOG_TYPE_CONSUME);
-
+		//Extended Features BG [Easycore]
+		if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+			add2limit(sd->status.bgstats.ammo_used, qty, UINT_MAX);
+		else if (is_agit_start() && map_flag_gvg2(sd->bl.m))
+			add2limit(sd->status.wstats.ammo_used, qty, UINT_MAX);
+	}
 	sd->state.arrow_atk = 0;
 }
 
@@ -10173,6 +10178,9 @@ int battle_check_target( struct block_list *src, struct block_list *target,int f
 		{
 			sbg_id = bg_team_get_id(s_bl);
 			tbg_id = bg_team_get_id(t_bl);
+			// Extended Battleground [Easycore]
+			if (flag&(BCT_PARTY) && sbg_id == tbg_id)
+				state |= BCT_PARTY;
 		}
 		if( flag&(BCT_PARTY|BCT_ENEMY) )
 		{
diff --git a/src/map/battleground.cpp b/src/map/battleground.cpp
index 2bb37d6..2e98989 100644
--- a/src/map/battleground.cpp
+++ b/src/map/battleground.cpp
@@ -5,19 +5,24 @@
 
 #include <unordered_map>
 
-#include <common/cbasetypes.hpp>
-#include <common/malloc.hpp>
-#include <common/nullpo.hpp>
-#include <common/random.hpp>
-#include <common/showmsg.hpp>
-#include <common/strlib.hpp>
-#include <common/timer.hpp>
-#include <common/utilities.hpp>
-
+#include "../common/cbasetypes.hpp"
+#include "../common/malloc.hpp"
+#include "../common/nullpo.hpp"
+#include "../common/random.hpp"
+#include "../common/showmsg.hpp"
+#include "../common/strlib.hpp"
+#include "../common/socket.hpp"
+#include "../common/timer.hpp"
+#include "../common/utilities.hpp"
+#include "../common/utils.hpp"
+
+#include "achievement.hpp"
 #include "battle.hpp"
 #include "clif.hpp"
+#include "elemental.hpp"
 #include "guild.hpp"
 #include "homunculus.hpp"
+#include "log.hpp"
 #include "mapreg.hpp"
 #include "mercenary.hpp"
 #include "mob.hpp"
@@ -25,6 +30,8 @@
 #include "party.hpp"
 #include "pc.hpp"
 #include "pet.hpp"
+#include "quest.hpp"
+#include "skill.hpp"
 
 using namespace rathena;
 
@@ -33,6 +40,13 @@ std::unordered_map<int, std::shared_ptr<s_battleground_data>> bg_team_db;
 std::vector<std::shared_ptr<s_battleground_queue>> bg_queues;
 int bg_queue_count = 1;
 
+#define BLUE_SKULL 8965
+#define RED_SKULL 8966
+#define GREEN_SKULL 8967
+
+struct mmo_guild bg_guild[13]; // Temporal fake guild information
+const unsigned int bg_colors[13] = { 0x0000FF, 0xFF0000, 0x00FF00, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
+
 const std::string BattlegroundDatabase::getDefaultLocation() {
 	return std::string(db_path) + "/battleground_db.yml";
 }
@@ -402,6 +416,423 @@ uint64 BattlegroundDatabase::parseBodyNode(const ryml::NodeRef& node) {
 	return 1;
 }
 
+
+void bg_guild_build_data(void)
+{
+	int i, j, k, skill;
+	memset(&bg_guild, 0, sizeof(bg_guild));
+	for( i = 1; i <= 13; i++ )
+	{ // Emblem Data - Guild ID's
+		FILE* fp = NULL;
+		char path[256];
+
+		j = i - 1;
+		bg_guild[j].emblem_id = 1; // Emblem Index
+		bg_guild[j].guild_id = INT_MAX - j;
+		bg_guild[j].guild_lv = 1;
+		bg_guild[j].max_member = MAX_BG_MEMBERS;
+		bg_guild[j].skill_point = 0;
+		bg_guild[j].average_lv = 99;
+
+		// Skills
+		if( j < 3 )
+		{ // Clan Skills
+			for( k = 0; k < MAX_GUILDSKILL-1; k++ )
+			{
+				skill = k + GD_SKILLBASE;
+				bg_guild[j].skill[k].id = skill;
+				switch( skill )
+				{
+				case GD_GLORYGUILD:
+					bg_guild[j].skill[k].lv = 0;
+					break;
+				case GD_APPROVAL:
+				case GD_KAFRACONTRACT:
+				case GD_GUARDRESEARCH:
+				case GD_BATTLEORDER:
+				case GD_RESTORE:
+				case GD_EMERGENCYCALL:
+				case GD_DEVELOPMENT:
+					bg_guild[j].skill[k].lv = 1;
+					break;
+				case GD_GUARDUP:
+				case GD_REGENERATION:
+					bg_guild[j].skill[k].lv = 3;
+					break;
+				case GD_LEADERSHIP:
+				case GD_GLORYWOUNDS:
+				case GD_SOULCOLD:
+				case GD_HAWKEYES:
+					bg_guild[j].skill[k].lv = 5;
+					break;
+				case GD_EXTENSION:
+					bg_guild[j].skill[k].lv = 10;
+					break;
+				}
+			}
+		}
+		else
+		{ // Other Data
+			snprintf(bg_guild[j].name, NAME_LENGTH, "Team %d", i - 3); // Team 1, Team 2 ... Team 10
+			strncpy(bg_guild[j].master, bg_guild[j].name, NAME_LENGTH);
+			snprintf(bg_guild[j].position[0].name, NAME_LENGTH, "%s Leader", bg_guild[j].name);
+			strncpy(bg_guild[j].position[1].name, bg_guild[j].name, NAME_LENGTH);
+		}
+
+		sprintf(path, "%s/emblems/bg_%d.ebm", db_path, i);
+		if( (fp = fopen(path, "rb")) != NULL )
+		{
+			fseek(fp, 0, SEEK_END);
+			bg_guild[j].emblem_len = ftell(fp);
+			fseek(fp, 0, SEEK_SET);
+			if (fread(&bg_guild[j].emblem_data, 1, bg_guild[j].emblem_len, fp) == bg_guild[j].emblem_len) {
+				fclose(fp);
+				ShowStatus("Done reading '%s' emblem data file.\n", path);
+			} else
+				ShowStatus("Failed to read '%s'.\n", path); // Never happen
+		}
+	}
+
+	// Guild Data - Guillaume
+	strncpy(bg_guild[0].name, "Blue Team", NAME_LENGTH);
+	strncpy(bg_guild[0].master, "General Guillaume", NAME_LENGTH);
+	strncpy(bg_guild[0].position[0].name, "Blue Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[0].position[1].name, "Blue Team", NAME_LENGTH);
+
+	// Guild Data - Croix
+	strncpy(bg_guild[1].name, "Red Team", NAME_LENGTH);
+	strncpy(bg_guild[1].master, "Prince Croix", NAME_LENGTH);
+	strncpy(bg_guild[1].position[0].name, "Red Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[1].position[1].name, "Red Team", NAME_LENGTH);
+
+	// Guild Data - Traitors
+	strncpy(bg_guild[2].name, "Green Team", NAME_LENGTH);
+	strncpy(bg_guild[2].master, "Mercenary", NAME_LENGTH);
+	strncpy(bg_guild[2].position[0].name, "Green Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[2].position[1].name, "Green Team", NAME_LENGTH);
+}
+
+int bg_checkskill(struct s_battleground_data *bg, int id)
+{
+	int idx = id - GD_SKILLBASE;
+	if( idx < 0 || idx >= MAX_GUILDSKILL-1 || !bg->g )
+		return 0;
+	return bg->g->skill[idx].lv;
+}
+
+TIMER_FUNC(bg_block_skill_end)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	char output[128];
+	int idx = (int)data - GD_SKILLBASE;
+
+	if( (bg = util::umap_find(bg_team_db, id)) == NULL )
+		return 1;
+
+	if( idx < 0 || idx >= MAX_GUILDSKILL-1 )
+	{
+		ShowError("bg_block_skill_end invalid skill_id %d.\n", (int)data);
+		return 0;
+	}
+
+	if( tid != bg->skill_block_timer[idx] )
+	{
+		ShowError("bg_block_skill_end %d != %d.\n", bg->skill_block_timer[idx], tid);
+		return 0;
+	}
+
+	sprintf(output, "%s : Guild Skill %s Ready!!", bg->g->name, skill_get_desc((int)data));
+	clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+	bg->skill_block_timer[idx] = INVALID_TIMER;
+
+	return 1;
+}
+
+void bg_block_skill_start(struct s_battleground_data *bg, int skill_id, t_tick time)
+{
+	int idx = skill_id - GD_SKILLBASE;
+	if( bg == NULL || idx < 0 || idx >= MAX_GUILDSKILL-1 )
+		return;
+
+	if (bg->skill_block_timer[idx] != INVALID_TIMER)
+		delete_timer(bg->skill_block_timer[idx], bg_block_skill_end);
+
+	bg->skill_block_timer[idx] = add_timer(gettick() + time, bg_block_skill_end, bg->id, skill_id);
+}
+
+bool bg_block_skill_status(struct s_battleground_data *bg, int skill_id)
+{
+	const struct TimerData * td;
+	char output[128];
+	int idx;
+	t_tick seconds;
+
+	idx = skill_id - GD_SKILLBASE;
+	if (bg == NULL || bg->g == NULL || idx < 0 || idx >= MAX_GUILDSKILL-1 || bg->skill_block_timer[idx] == INVALID_TIMER)
+		return false;
+
+	if ((td = get_timer(bg->skill_block_timer[idx])) == NULL)
+		return false;
+
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "%s : Cannot use team skill [%s]. %lld seconds remaining................", bg->g->name, skill_get_desc(skill_id), seconds);
+	clif_bg_message(bg, 0, bg->g->name, output, strlen(output) + 1);
+
+	return true;
+}
+
+void guild_block_skill_status(map_session_data *sd, int skillid)
+{
+	if (!sd)
+		return;
+	struct mmo_guild g;
+	const struct TimerData * td;
+	char output[128];
+	int i;
+	t_tick seconds;
+	g = sd->guild->guild;
+
+	if (!SKILL_CHK_GUILD(skillid))
+		return;
+	if ((i = skill_blockpc_get(sd,skillid)) == -1)
+		return;
+	if( (td = get_timer(sd->scd[i]->timer)) == NULL )
+		return;
+
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "Guild: Cannot use skill [%s]. %lld seconds remaining................", skill_get_desc(skillid), seconds);
+	clif_guild_message(g ,0 ,output , strlen(output) + 1);
+}
+
+int guild_skills_timer(map_session_data *sd, int skillid)
+{
+	if (!sd)
+		return -2;
+	struct mmo_guild g;
+	std::shared_ptr<s_battleground_data> bg;
+	const struct TimerData * td;
+	int i;
+	g = sd->guild->guild;
+
+	if (!SKILL_CHK_GUILD(skillid))
+		return -2;
+	if (sd->bg_id) {
+		skillid -= GD_SKILLBASE;
+		if (!(bg = util::umap_find(bg_team_db, sd->bg_id)))
+			return -2;
+		if (bg->skill_block_timer[skillid] == INVALID_TIMER)
+			return -1;
+		if ((td = get_timer(bg->skill_block_timer[skillid])) == NULL )
+			return -1;
+	} else if (g.guild_id) {
+		if ((i = skill_blockpc_get(sd,skillid)) == -1)
+			return -1;
+		if( (td = get_timer(sd->scd[i]->timer)) == NULL )
+			return -1;
+	} else
+		return -2;
+
+	return (int)DIFF_TICK(td->tick,gettick())/1000;
+}
+
+int bg_reveal_pos(struct block_list *bl, va_list ap)
+{
+	map_session_data *pl_sd, *sd = NULL;
+	int flag, color;
+
+	pl_sd = (map_session_data *)bl;
+	sd = va_arg(ap,map_session_data *); // Source
+	flag = va_arg(ap,int);
+	color = va_arg(ap,int);
+
+	if( pl_sd->bg_id == sd->bg_id )
+		return 0; // Same Team
+
+	clif_viewpoint(pl_sd,sd->bl.id,flag,sd->bl.x,sd->bl.y,sd->bl.id,color);
+	return 0;
+}
+
+void bg_team_getitem(int bg_id, int nameid, int amount, int reward)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	struct item it;
+	int flag, amount2 = 0;
+
+	if (amount < 1 || !(bg = util::umap_find(bg_team_db, bg_id)) || !(item_db.exists(nameid)))
+		return;
+
+	if (reward)
+		amount2 = amount;
+
+	if(reward && battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
+
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
+
+	for (const auto &member : bg->members) {
+		if (pc_isvip(member.sd)) {
+			if(reward && battle_config.bg_reward_rates_vip)
+				amount += amount2 * battle_config.bg_reward_rates_vip / 100;
+		}
+		if ((flag = pc_additem(member.sd, &it, amount, LOG_TYPE_SCRIPT)))
+			clif_additem(member.sd, 0, 0, flag);
+	}
+}
+
+int bg_member_removeskulls(map_session_data *sd)
+{
+	int n;
+	nullpo_ret(sd);
+	if( (n = pc_search_inventory(sd,BLUE_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+	if( (n = pc_search_inventory(sd,RED_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+	if( (n = pc_search_inventory(sd,GREEN_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+
+	return 1;
+}
+
+/* ==============================================================
+bg_arena (0 EoS | 1 Boss | 2 TI | 3 CTF | 4 TD | 5 SC | 6 CON)
+bg_result (0 Won | 1 Tie | 2 Lost)
++============================================================== */
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result, int fame)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	struct item it;
+	int flag, amount_vip, kafrapoints_vip = 0;
+
+	if (amount < 1 || !(bg = util::umap_find(bg_team_db, bg_id)) || !(item_db.exists(nameid)))
+		return;
+
+	if (battle_config.bg_reward_rates != 100) { // BG Reward Rates
+		amount = amount * battle_config.bg_reward_rates / 100;
+		kafrapoints = kafrapoints * battle_config.bg_reward_rates / 100;
+	}
+
+	if (battle_config.bg_reward_rates_vip) {
+		amount_vip = amount + (amount * battle_config.bg_reward_rates_vip / 100);
+		kafrapoints_vip = kafrapoints + (kafrapoints * battle_config.bg_reward_rates_vip / 100);
+	}
+
+	bg_result = cap_value(bg_result, 0, 2);
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
+
+	for (const auto &member : bg->members) {
+		if (pc_isvip(member.sd)) {
+			if (kafrapoints_vip)
+				pc_getcash(member.sd, 0, kafrapoints_vip, LOG_TYPE_SCRIPT);
+			if ((flag = pc_additem(member.sd, &it, amount_vip, LOG_TYPE_SCRIPT)))
+				clif_additem(member.sd, 0, 0, flag);
+		} else {
+			if (kafrapoints)
+				pc_getcash(member.sd, 0, kafrapoints, LOG_TYPE_SCRIPT);
+			if ((flag = pc_additem(member.sd, &it, amount, LOG_TYPE_SCRIPT)))
+				clif_additem(member.sd, 0, 0, flag);
+		}
+		if (add_value)
+			pc_setglobalreg(member.sd, add_str(var), pc_readglobalreg(member.sd, add_str(var)) + add_value);
+		if (fame)
+			pc_addbgpoints(member.sd,fame);
+
+		achievement_update_objective(member.sd, AG_BG_DAMAGE, 1, member.sd->status.bgstats.damage_done);
+		switch(bg_result) {
+			case 0: // Won
+				add2limit(member.sd->status.bgstats.win,1,USHRT_MAX);
+				achievement_update_objective(member.sd, AG_BG_WIN, 1, 1);
+				if (member.sd->state.bmaster_flag)
+					add2limit(member.sd->status.bgstats.leader_win,1,USHRT_MAX);
+				switch(bg_arena) {
+					case 0: add2limit(member.sd->status.bgstats.eos_wins,1,USHRT_MAX); break;
+					case 1: add2limit(member.sd->status.bgstats.boss_wins,1,USHRT_MAX); break;
+					case 2: add2limit(member.sd->status.bgstats.ti_wins,1,USHRT_MAX); break;
+					case 3: add2limit(member.sd->status.bgstats.ctf_wins,1,USHRT_MAX); break;
+					case 4: add2limit(member.sd->status.bgstats.td_wins,1,USHRT_MAX); break;
+					case 5: add2limit(member.sd->status.bgstats.sc_wins,1,USHRT_MAX); break;
+					case 6: add2limit(member.sd->status.bgstats.cq_wins,1,USHRT_MAX); break;
+					case 7: add2limit(member.sd->status.bgstats.ru_wins,1,USHRT_MAX); break;
+					case 8: add2limit(member.sd->status.bgstats.dom_wins,1,USHRT_MAX); break;
+				}
+				break;
+			case 1: // Tie
+				add2limit(member.sd->status.bgstats.tie,1,USHRT_MAX);
+				achievement_update_objective(member.sd, AG_BG_TIE, 1, 1);
+				if (member.sd->state.bmaster_flag)
+					add2limit(member.sd->status.bgstats.leader_tie,1,USHRT_MAX);
+				switch( bg_arena ) {
+					case 0: add2limit(member.sd->status.bgstats.eos_tie,1,USHRT_MAX); break;
+					case 1: add2limit(member.sd->status.bgstats.boss_tie,1,USHRT_MAX); break;
+					case 2: add2limit(member.sd->status.bgstats.ti_tie,1,USHRT_MAX); break;
+					case 3: add2limit(member.sd->status.bgstats.ctf_tie,1,USHRT_MAX); break;
+					case 4: add2limit(member.sd->status.bgstats.td_tie,1,USHRT_MAX); break;
+					case 5: add2limit(member.sd->status.bgstats.sc_tie,1,USHRT_MAX); break;
+					// No Tie for Conquest or Rush
+					case 8: add2limit(member.sd->status.bgstats.dom_tie,1,USHRT_MAX); break;
+				}
+				break;
+			case 2: // Lost
+				add2limit(member.sd->status.bgstats.lost,1,USHRT_MAX);
+				achievement_update_objective(member.sd, AG_BG_LOSE, 1, 1);
+				if (member.sd->state.bmaster_flag)
+					add2limit(member.sd->status.bgstats.leader_lost,1,USHRT_MAX);
+				switch(bg_arena) {
+					case 0: add2limit(member.sd->status.bgstats.eos_lost,1,USHRT_MAX); break;
+					case 1: add2limit(member.sd->status.bgstats.boss_lost,1,USHRT_MAX); break;
+					case 2: add2limit(member.sd->status.bgstats.ti_lost,1,USHRT_MAX); break;
+					case 3: add2limit(member.sd->status.bgstats.ctf_lost,1,USHRT_MAX); break;
+					case 4: add2limit(member.sd->status.bgstats.td_lost,1,USHRT_MAX); break;
+					case 5: add2limit(member.sd->status.bgstats.sc_lost,1,USHRT_MAX); break;
+					case 6: add2limit(member.sd->status.bgstats.cq_lost,1,USHRT_MAX); break;
+					case 7: add2limit(member.sd->status.bgstats.ru_lost,1,USHRT_MAX); break;
+					case 8: add2limit(member.sd->status.bgstats.dom_lost,1,USHRT_MAX); break;
+				}
+				break;
+		}
+	}
+}
+
+/**
+ * Get how many clients are active
+ * @return login counts
+ */
+int bg_countlogin(map_session_data *sd)
+{
+	int c = 0;
+	map_session_data* pl_sd;
+	struct s_mapiterator* iter;
+	nullpo_ret(sd);
+
+	iter = mapit_getallusers();
+	for (pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter))
+	{
+		//if (session[sd->fd]->gepard_info.unique_id != session[pl_sd->fd]->gepard_info.unique_id)
+		if( session[sd->fd]->client_addr == session[pl_sd->fd]->client_addr )
+			continue;
+		if (pl_sd->bg_queue_id || bg_player_is_in_bg_map(pl_sd))
+		c++;
+	}
+	mapit_free(iter);
+	return c;
+}
+
+/**
+ * Get Team Guild structure
+ * @param bg_id: Battleground Id
+ * @return guild struct
+ */
+struct mmo_guild *bg_guild_get(int bg_id)
+{ // Return Fake Guild for BG Members
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if( bg == NULL ) return NULL;
+	return bg->g;
+}
+
+
 /**
  * Search for a battleground based on the given name
  * @param name: Battleground name
@@ -434,6 +865,21 @@ std::shared_ptr<s_battleground_queue> bg_search_queue(int queue_id)
 	return nullptr;
 }
 
+/**
+ * Search for a Battleground queue based on the given ID
+ * @param id: ID
+ * @return s_battleground_queue on success or nullptr on failure
+ */
+std::shared_ptr<s_battleground_queue> bg_search_queue_id(int id)
+{
+	for (const auto &queue : bg_queues) {
+		if (id == queue->id)
+			return queue;
+	}
+
+	return nullptr;
+}
+
 /**
  * Search for an available player in Battleground
  * @param bg: Battleground data
@@ -459,12 +905,19 @@ map_session_data* bg_getavailablesd(s_battleground_data *bg)
 bool bg_team_delete(int bg_id)
 {
 	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
+	int i;
 
 	if (bgteam) {
 		for (const auto &pl_sd : bgteam->members) {
 			bg_send_dot_remove(pl_sd.sd);
 			pl_sd.sd->bg_id = 0;
 		}
+		for(i = 0; i < MAX_GUILDSKILL-1; i++)
+		{
+			if (bgteam->skill_block_timer[i] == INVALID_TIMER)
+				continue;
+			delete_timer(bgteam->skill_block_timer[i], bg_block_skill_end);
+		}
 
 		bg_team_db.erase(bg_id);
 
@@ -504,8 +957,12 @@ void bg_send_dot_remove(map_session_data *sd)
 {
 	nullpo_retv(sd);
 
-	if( sd && sd->bg_id )
+	if (sd && sd->bg_id) {
+		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
 		clif_bg_xy_remove(sd);
+		if (bg && bg->reveal_pos && bg_player_is_in_bg_map(sd))
+			map_foreachinmap(bg_reveal_pos, sd->bl.m, BL_PC, sd, 2, 0xFFFFFF);
+	}
 	return;
 }
 
@@ -530,6 +987,40 @@ bool bg_team_join(int bg_id, map_session_data *sd, bool is_queue)
 		s_battleground_member_data member = {};
 
 		sd->bg_id = bg_id;
+
+		//Extended Battleground [Easycore]
+		sd->bg_queue_id = 0;
+		pc_update_last_action(sd);
+		sd->state.bg_afk = 0;
+
+		if (battle_config.bg_remove_buffs) {
+			if (battle_config.bg_remove_buffs&1) {
+				status_change_end(&sd->bl, SC_INCREASEAGI, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_BLESSING, INVALID_TIMER);
+			}
+			if (battle_config.bg_remove_buffs&2)
+				status_change_end(&sd->bl, SC_SPIRIT, INVALID_TIMER);
+			if (battle_config.bg_remove_buffs&4) {
+				status_change_end(&sd->bl, SC_CP_WEAPON, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_CP_SHIELD, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_CP_ARMOR, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_CP_HELM, INVALID_TIMER);
+			}
+			if (battle_config.bg_remove_buffs&8)
+				status_change_end(&sd->bl, SC_GOSPEL, INVALID_TIMER);
+			if (battle_config.bg_remove_buffs&16) {
+				status_change_end(&sd->bl, SC_KYRIE, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_ASSUMPTIO, INVALID_TIMER);
+			}
+			if (battle_config.bg_remove_buffs&32)
+				status_change_end(&sd->bl, SC_EDP, INVALID_TIMER);
+			if (battle_config.bg_remove_buffs&64) {
+				status_change_end(&sd->bl, SC_KAITE, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_KAUPE, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_KAIZEL, INVALID_TIMER);
+			}
+		}
+
 		member.sd = sd;
 		member.x = sd->bl.x;
 		member.y = sd->bl.y;
@@ -540,13 +1031,30 @@ bool bg_team_join(int bg_id, map_session_data *sd, bool is_queue)
 		}
 		bgteam->members.push_back(member);
 
+		if (bgteam->leader_char_id == 0) { // First Join = Team Leader
+			bgteam->leader_char_id = sd->status.char_id;
+			sd->state.bmaster_flag = 1;
+		}
+
 		guild_send_dot_remove(sd);
 
+		//Extended Battleground [Easycore]
+		clif_bg_belonginfo(sd);
+		clif_guild_masterormember(sd);
+		clif_name_area(&sd->bl);
+		skill_blockpc_clear(sd);
+
 		for (const auto &pl_sd : bgteam->members) {
-			if (pl_sd.sd != sd)
+			if (pl_sd.sd != sd) {
+				// Simulate Guild Information [Easycore]
+				clif_guild_basicinfo(*pl_sd.sd);
+				clif_bg_emblem(pl_sd.sd, bgteam->g);
+				clif_bg_memberlist(pl_sd.sd);
 				clif_hpmeter_single( *sd, pl_sd.sd->bl.id, pl_sd.sd->battle_status.hp, pl_sd.sd->battle_status.max_hp );
 		}
+	}
 
+		clif_guild_emblem_area(&sd->bl);
 		clif_bg_hp(sd);
 		clif_bg_xy(sd);
 		return true;
@@ -568,12 +1076,70 @@ int bg_team_leave(map_session_data *sd, bool quit, bool deserter)
 		return -1;
 
 	bg_send_dot_remove(sd);
+	bg_member_removeskulls(sd);
 
 	int bg_id = sd->bg_id;
 	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
+	//std::shared_ptr <MapGuild> g;
 
 	sd->bg_id = 0;
 
+	//Extended Battleground [Easycore]
+	sd->state.bg_afk = 0;
+	sd->state.bmaster_flag = 0;
+
+	// Remove Guild Skill Buffs
+	status_change_end(&sd->bl, SC_GUILDAURA, INVALID_TIMER);
+	status_change_end(&sd->bl, SC_BATTLEORDERS, INVALID_TIMER);
+	status_change_end(&sd->bl, SC_REGENERATION, INVALID_TIMER);
+
+	if (battle_config.bg_remove_buffs) {
+		if (battle_config.bg_remove_buffs&1) {
+			status_change_end(&sd->bl, SC_INCREASEAGI, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_BLESSING, INVALID_TIMER);
+		}
+		if (battle_config.bg_remove_buffs&2)
+			status_change_end(&sd->bl, SC_SPIRIT, INVALID_TIMER);
+		if (battle_config.bg_remove_buffs&4) {
+			status_change_end(&sd->bl, SC_CP_WEAPON, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CP_SHIELD, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CP_ARMOR, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CP_HELM, INVALID_TIMER);
+		}
+		if (battle_config.bg_remove_buffs&8)
+			status_change_end(&sd->bl, SC_GOSPEL, INVALID_TIMER);
+		if (battle_config.bg_remove_buffs&16) {
+			status_change_end(&sd->bl, SC_KYRIE, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_ASSUMPTIO, INVALID_TIMER);
+		}
+		if (battle_config.bg_remove_buffs&32)
+			status_change_end(&sd->bl, SC_EDP, INVALID_TIMER);
+		if (battle_config.bg_remove_buffs&64) {
+			status_change_end(&sd->bl, SC_KAITE, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_KAUPE, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_KAIZEL, INVALID_TIMER);
+		}
+	}
+	if (battle_config.bg_buffs_on_leave && !deserter) {
+		sc_start(&sd->bl,&sd->bl,SC_INCAGI,100,10,240000);
+		sc_start(&sd->bl,&sd->bl,SC_BLESSING,100,10,240000);
+	}
+
+	// Refresh Guild Information
+	auto g = guild_search(sd->status.guild_id);
+	if (sd && sd->status.guild_id && guild_search(sd->status.guild_id) != NULL)	{
+		clif_guild_belonginfo(*sd);
+		clif_guild_basicinfo(*sd);
+		clif_guild_allianceinfo(sd);
+		clif_guild_memberlist(*sd);
+		clif_guild_skillinfo(sd);
+		clif_guild_emblem(*sd, g->guild);
+	} else
+		clif_bg_leave_single(sd, sd->status.name, "Leaving Battleground...");
+
+	clif_name_area(&sd->bl);
+	clif_guild_emblem_area(&sd->bl);
+
 	if (bgteam) {
 		// Warping members out only applies to the Battleground Queue System
 		if (battle_config.feature_bgqueue) {
@@ -593,6 +1159,24 @@ int bg_team_leave(map_session_data *sd, bool quit, bool deserter)
 			}
 		}
 
+		// Extended Battleground [Easycore]
+		if (bgteam->leader_char_id == sd->status.char_id)
+		bgteam->leader_char_id = 0;
+
+		for (const auto &pl_sd : bgteam->members) {
+			if (pl_sd.sd != sd) {
+				if (!bgteam->leader_char_id)
+				{ // Set new Leader first on the list
+					bgteam->leader_char_id = pl_sd.sd->status.char_id;
+					pl_sd.sd->state.bmaster_flag = 1;
+				}
+				// Simulate Guild Information
+				clif_guild_basicinfo(*pl_sd.sd);
+				clif_bg_emblem(pl_sd.sd, bgteam->g);
+				clif_bg_memberlist(pl_sd.sd);
+			}
+		}
+
 		char output[CHAT_SIZE_MAX];
 
 		if (quit)
@@ -655,6 +1239,7 @@ bool bg_member_respawn(map_session_data *sd)
 int bg_create(uint16 mapindex, s_battleground_team* team)
 {
 	int bg_team_counter = 1;
+	int i;
 
 	while (bg_team_db.find(bg_team_counter) != bg_team_db.end())
 		bg_team_counter++;
@@ -671,6 +1256,13 @@ int bg_create(uint16 mapindex, s_battleground_team* team)
 	bg->die_event = team->death_event.c_str();
 	bg->active_event = team->active_event.c_str();
 
+	//Extended Battleground [Easycore]
+	bg->g = &bg_guild[team->guild_index];
+	bg->color = bg_colors[team->guild_index];
+	bg->afk_warning = true;
+	for( i = 0; i < MAX_GUILDSKILL-1; i++ )
+		bg->skill_block_timer[i] = INVALID_TIMER;
+
 	return bg->id;
 }
 
@@ -707,6 +1299,13 @@ int bg_team_get_id(struct block_list *bl)
 			if( ((TBL_MER*)bl)->master )
 				return ((TBL_MER*)bl)->master->bg_id;
 			break;
+		case BL_ELEM:
+			if( ((TBL_ELEM*)bl)->master )
+				return ((TBL_ELEM*)bl)->master->bg_id;
+			break;
+		case BL_NPC:
+			return ((TBL_NPC*)bl)->u.scr.bg_id;
+			break;
 		case BL_SKILL:
 			return ((TBL_SKILL*)bl)->group->bg_id;
 	}
@@ -742,15 +1341,40 @@ void bg_send_message(map_session_data *sd, const char *mes, int len)
 int bg_send_xy_timer_sub(std::shared_ptr<s_battleground_data> bg)
 {
 	map_session_data *sd;
+	// Extended Battleground [Easycore]
+	char output[128];
+	int idle_announce = battle_config.bg_idle_announce,
+		idle_autokick = battle_config.bg_idle_autokick;
 
 	for (auto &pl_sd : bg->members) {
 		sd = pl_sd.sd;
 
+		// Extended Battleground [Easycore]
+		if (bg->afk_warning && idle_autokick && DIFF_TICK(last_tick, sd->idletime) >= idle_autokick
+			&& bg->g && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+		{
+			sprintf(output, msg_txt(sd, 2000), sd->status.name); // [Battlegrounds] %s has been kicked for being AFK
+			clif_broadcast2(&sd->bl, output, (int)strlen(output) + 1, bg->color, 0x190, 20, 0, 0, BG);
+
+			bg_team_leave(sd, true, true);
+
+			clif_displaymessage(sd->fd, msg_txt(sd, 2001)); // You have been kicked from Battleground for your AFK status
+		}
+
 		if (sd->bl.x != pl_sd.x || sd->bl.y != pl_sd.y) { // xy update
 			pl_sd.x = sd->bl.x;
 			pl_sd.y = sd->bl.y;
 			clif_bg_xy(sd);
 		}
+		if (bg->reveal_pos && bg_player_is_in_bg_map(sd))
+			map_foreachinmap(bg_reveal_pos, sd->bl.m, BL_PC, sd, 1, bg->color);
+		// Message for AFK Idling
+		if (bg->afk_warning && idle_announce && DIFF_TICK(last_tick, sd->idletime) >= idle_announce && !sd->state.bg_afk && bg->g)
+		{ // Set AFK status and announce to the team.
+			sd->state.bg_afk = 1;
+			sprintf(output, msg_txt(sd, 2002), bg->g->name, sd->status.name); //%s : %s seems to be away. AFK Warning - player can be kicked by @reportafk command
+			clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+		}
 	}
 
 	return 0;
@@ -926,6 +1550,13 @@ bool bg_queue_check_joinable(std::shared_ptr<s_battleground_type> bg, map_sessio
 		}
 	}
 
+	// Extended Battleground [Easycore]
+	if (battle_config.bg_double_login && bg_countlogin(sd)) {
+		clif_bg_queue_apply_result(BG_APPLY_NONE, name, sd);
+		clif_displaymessage(sd->fd, msg_txt(sd, 2003)); // Double Login [Easycore]
+		return false;
+	}
+
 	if (bg->min_lvl > 0 && sd->status.base_level < bg->min_lvl) { // Check minimum level requirement
 		clif_bg_queue_apply_result(BG_APPLY_PLAYER_LEVEL, name, sd);
 		return false;
@@ -970,6 +1601,7 @@ bool bg_queue_reservation(const char *name, bool state, bool ended)
 			if (map.mapindex == mapindex) {
 				map.isReserved = state;
 				for (auto &queue : bg_queues) {
+					bg_queue_clear(queue, true);
 					if (queue->map == &map) {
 						if (ended) // The ended flag is applied from bg_reserve (bg_unbook clears it for the next queue)
 							queue->state = QUEUE_STATE_ENDED;
@@ -985,6 +1617,69 @@ bool bg_queue_reservation(const char *name, bool state, bool ended)
 	return false;
 }
 
+void bg_queue_leave_all()
+{
+	for (auto &queue : bg_queues) {
+		for (const auto &sd : queue->teama_members) {
+			clif_refresh(sd);
+			clif_bg_queue_apply_result(BG_APPLY_QUEUE_FINISHED, "Tierra Gorge", sd);
+			clif_bg_queue_entry_init(sd);
+			sd->bg_queue_id = 0;
+		}
+
+		for (const auto &sd : queue->teamb_members) {
+			clif_refresh(sd);
+			clif_bg_queue_apply_result(BG_APPLY_QUEUE_FINISHED, "Tierra Gorge", sd);
+			clif_bg_queue_entry_init(sd);
+			sd->bg_queue_id = 0;
+		}
+		bg_queue_clear(queue, true);
+	}
+	return;
+}
+
+bool bg_queue_transfer_all(const char* queue_source, const char* queue_dest)
+{
+	if (!battle_config.bg_rotation_mode) {
+		ShowWarning("bg_queue_transfer_all: this function is only available for rotation mode\n");
+		return false;
+	}
+
+	std::shared_ptr<s_battleground_type> bg_sc = bg_search_name(queue_source);
+	std::shared_ptr<s_battleground_type> bg_dst = bg_search_name(queue_dest);
+
+	if (bg_sc == nullptr || bg_dst == nullptr) {
+		ShowWarning("bg_queue_transfer_all: Could not find queue ids\n");
+		return false;
+	}
+
+	std::shared_ptr<s_battleground_queue> q_sc = bg_search_queue_id(bg_sc->id);
+	std::shared_ptr<s_battleground_queue> q_dst = bg_search_queue_id(bg_dst->id);
+
+	if (!q_sc || !q_dst)
+		return false;
+
+	bg_queue_clear(q_dst, true);
+
+	for (const auto &sd : q_sc->teama_members) {
+		q_dst->teama_members.push_back(sd);
+		sd->bg_queue_id = q_dst->queue_id;
+	}
+	for (const auto &sd : q_sc->teamb_members) {
+		q_dst->teamb_members.push_back(sd);
+		sd->bg_queue_id = q_dst->queue_id;
+	}
+
+	bg_queue_clear(q_sc, false);
+	q_sc->teama_members.clear();
+	q_sc->teamb_members.clear();
+	q_sc->teama_members.shrink_to_fit();
+	q_sc->teamb_members.shrink_to_fit();
+	q_sc->accepted_players = 0;
+	q_sc->state = QUEUE_STATE_SETUP;
+	return true;
+}
+
 /**
  * Join as an individual into a Battleground
  * @param name: Battleground name
@@ -1210,9 +1905,15 @@ void bg_queue_join_multi(const char *name, map_session_data *sd, std::vector <ma
 					continue;
 
 				pc_set_bg_queue_timer(pl_sd);				
+				if (battle_config.bg_queue_confirmation && battle_config.bg_queue_interface)
 				clif_bg_queue_lobby_notify(name, pl_sd);
+				else
+					bg_queue_on_accept_invite(pl_sd);
 			}
-		} else if (queue->state == QUEUE_STATE_SETUP && queue->teamb_members.size() >= bg->required_players && queue->teama_members.size() >= bg->required_players) // Enough players have joined
+			}
+		else if (battle_config.bg_balance_teams && queue->state == QUEUE_STATE_SETUP && (queue->teama_members.size()+queue->teamb_members.size()) >= bg->required_players)
+			bg_queue_on_ready(name, queue);
+		else if (queue->state == QUEUE_STATE_SETUP && queue->teamb_members.size() >= bg->required_players && queue->teama_members.size() >= bg->required_players) // Enough players have joined
 			bg_queue_on_ready(name, queue);
 
 		return;
@@ -1366,11 +2067,19 @@ bool bg_queue_on_ready(const char *name, std::shared_ptr<s_battleground_queue> q
 	queue->state = QUEUE_STATE_SETUP_DELAY;
 	queue->tid_expire = add_timer(gettick() + 20000, bg_on_ready_expire, 0, (intptr_t)queue->queue_id);
 
-	for (const auto &sd : queue->teama_members)
+	for (const auto &sd : queue->teama_members) {
+		if (battle_config.bg_queue_confirmation && battle_config.bg_queue_interface)
 		clif_bg_queue_lobby_notify(name, sd);
+		else
+			bg_queue_on_accept_invite(sd);
+	}
 
-	for (const auto &sd : queue->teamb_members)
+	for (const auto &sd : queue->teamb_members) {
+		if (battle_config.bg_queue_confirmation && battle_config.bg_queue_interface)
 		clif_bg_queue_lobby_notify(name, sd);
+		else
+			bg_queue_on_accept_invite(sd);
+	}
 
 	return true;
 }
@@ -1510,6 +2219,15 @@ void bg_queue_on_accept_invite(map_session_data *sd)
 	if (queue->state == QUEUE_STATE_ACTIVE) // Battleground is already active
 		bg_join_active(sd, queue);
 	else if (queue->state == QUEUE_STATE_SETUP_DELAY) {
+		// Extended Battleground [Easycore]
+		if (battle_config.bg_balance_teams) {
+			char output[CHAT_SIZE_MAX];
+			sprintf(output, msg_txt(sd, 2039), queue->accepted_players, queue->required_players * 2); // Waiting for players... (%d/%d)
+			for (const auto &sd : queue->teama_members)
+				clif_showscript(&sd->bl, output, SELF);
+			for (const auto &sd : queue->teamb_members)
+				clif_showscript(&sd->bl, output, SELF);
+		}
 		if (queue->accepted_players == queue->required_players * 2) {
 			if (queue->tid_expire != INVALID_TIMER) {
 				delete_timer(queue->tid_expire, bg_on_ready_expire);
@@ -1525,6 +2243,32 @@ void bg_queue_on_accept_invite(map_session_data *sd)
 	}
 }
 
+/**
+ * Re order queue list in order to balance by jobs [Easycore]
+ */
+void bg_queue_balance_teams(std::shared_ptr<s_battleground_queue> queue, int bg_team_1, int bg_team_2)
+{
+	std::vector<map_session_data *> list;
+	bool c = false;
+
+	for (const auto &sd : queue->teama_members)
+		list.push_back(sd);
+	for (const auto &sd : queue->teamb_members)
+		list.push_back(sd);
+
+	std::sort(list.begin(), list.end(),
+		[](map_session_data * a, map_session_data * b) -> bool
+		{ return a->class_&MAPID_UPPERMASK > b->class_&MAPID_UPPERMASK; });
+
+	for (const auto &sd : list) {
+		clif_bg_queue_entry_init(sd);
+		bg_team_join(c?bg_team_1:bg_team_2, sd, true);
+		c = !c;
+	}
+
+	return;
+}
+
 /**
  * Begin the Battleground from the given queue
  * @param queue: Battleground queue
@@ -1547,9 +2291,17 @@ void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue)
 		return;
 
 	uint16 map_idx = queue->map->mapindex;
+	//Extended Battleground [Easycore]
+	queue->map->team1.guild_index = 0;
+	queue->map->team2.guild_index = 1;
+
 	int bg_team_1 = bg_create(map_idx, &queue->map->team1);
 	int bg_team_2 = bg_create(map_idx, &queue->map->team2);
 
+	// Balance Teams
+	if (battle_config.bg_balance_teams)
+		bg_queue_balance_teams(queue, bg_team_1, bg_team_2);
+	else {
 	for (const auto &sd : queue->teama_members) {
 		clif_bg_queue_entry_init(sd);
 		bg_team_join(bg_team_1, sd, true);
@@ -1560,6 +2312,8 @@ void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue)
 		bg_team_join(bg_team_2, sd, true);
 	}
 	
+	}
+
 	mapreg_setreg(add_str(queue->map->team1.bg_id_var.c_str()), bg_team_1);
 	mapreg_setreg(add_str(queue->map->team2.bg_id_var.c_str()), bg_team_2);
 	npc_event_do(queue->map->bgcallscript.c_str());
@@ -1606,7 +2360,10 @@ void do_init_battleground(void)
 	add_timer_func_list(bg_on_ready_loopback, "bg_on_ready_loopback");
 	add_timer_func_list(bg_on_ready_expire, "bg_on_ready_expire");
 	add_timer_func_list(bg_on_ready_start, "bg_on_ready_start");
+	add_timer_func_list(bg_block_skill_end,"bg_block_skill_end");
 	add_timer_interval(gettick() + battle_config.bg_update_interval, bg_send_xy_timer, 0, 0, battle_config.bg_update_interval);
+
+	bg_guild_build_data();
 }
 
 /**
diff --git a/src/map/battleground.hpp b/src/map/battleground.hpp
index 08d2c13..bfb8292 100644
--- a/src/map/battleground.hpp
+++ b/src/map/battleground.hpp
@@ -40,6 +40,9 @@ struct s_battleground_data {
 	int team_score;
 };
 
+extern struct mmo_guild bg_guild[];
+extern const unsigned int bg_colors[];
+
 struct s_battleground_team {
 	uint16 warp_x, warp_y; ///< Team respawn coordinates
 	std::string quit_event, ///< Team NPC Event to call on log out events
diff --git a/src/map/buyingstore.cpp b/src/map/buyingstore.cpp
index f2eaea8..3effcd7 100644
--- a/src/map/buyingstore.cpp
+++ b/src/map/buyingstore.cpp
@@ -404,6 +404,13 @@ void buyingstore_trade( map_session_data* sd, uint32 account_id, unsigned int bu
 			return;
 		}
 
+		if (sd->inventory.u.items_inventory[index].card[0] == CARD0_CREATE && ((MakeDWord(sd->inventory.u.items_inventory[index].card[2], sd->inventory.u.items_inventory[index].card[3])) == (battle_config.bg_reserved_char_id || battle_config.woe_reserved_char_id) && !battle_config.bg_can_trade ))
+		{ // Items where creator's ID is important
+			clif_buyingstore_trade_failed_seller(sd, BUYINGSTORE_TRADE_SELLER_FAILED, item->itemId);
+			clif_displaymessage(sd->fd, msg_txt(sd,2004)); // Cannot Trade event reserved Items (Battleground, WoE)
+			return;
+		}
+
 		int listidx;
 
 		ARR_FIND( 0, pl_sd->buyingstore.slots, listidx, pl_sd->buyingstore.items[listidx].nameid == item->itemId );
diff --git a/src/map/chrif.cpp b/src/map/chrif.cpp
index 29f7c4b..3dd9731 100644
--- a/src/map/chrif.cpp
+++ b/src/map/chrif.cpp
@@ -1190,7 +1190,11 @@ int chrif_updatefamelist(map_session_data &sd, e_rank ranktype) {
 	WFIFOHEAD(char_fd, 11);
 	WFIFOW(char_fd,0) = 0x2b10;
 	WFIFOL(char_fd,2) = sd.status.char_id;
-	WFIFOL(char_fd,6) = sd.status.fame;
+	switch(ranktype) {
+		case RANK_BG: WFIFOL(char_fd,6) = sd.status.bgstats.points; break;
+		case RANK_WOE: WFIFOL(char_fd,6) = sd.status.wstats.points; break;
+		default: WFIFOL(char_fd,6) = sd.status.fame;
+	}
 	WFIFOB(char_fd,10) = ranktype;
 	WFIFOSET(char_fd,11);
 
@@ -1209,11 +1213,31 @@ int chrif_buildfamelist(void) {
 
 int chrif_recvfamelist(int fd) {
 	int num, size;
-	int total = 0, len = 8;
+	int total = 0, len = 12;
 
 	memset (smith_fame_list, 0, sizeof(smith_fame_list));
 	memset (chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset (taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset (bg_fame_list, 0, sizeof(bg_fame_list));
+	memset (woe_fame_list, 0, sizeof(woe_fame_list));
+
+	size = RFIFOW(fd,10); //WoE rank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&woe_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+
+	total += num;
+
+	size = RFIFOW(fd,8); //BG rank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&bg_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+
+	total += num;
 
 	size = RFIFOW(fd, 6); //Blacksmith block size
 
@@ -1257,6 +1281,8 @@ int chrif_updatefamelist_ack(int fd) {
 		case RANK_BLACKSMITH:	list = smith_fame_list;   break;
 		case RANK_ALCHEMIST:	list = chemist_fame_list; break;
 		case RANK_TAEKWON:		list = taekwon_fame_list; break;
+		case RANK_BG:			list = bg_fame_list;      break;
+		case RANK_WOE:			list = woe_fame_list;      break;
 		default: return 0;
 	}
 
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
index 103a6fa..e2b823a 100644
--- a/src/map/clif.cpp
+++ b/src/map/clif.cpp
@@ -491,7 +491,7 @@ int clif_send(const void* buf, int len, struct block_list* bl, enum send_target
 	int x0 = 0, x1 = 0, y0 = 0, y1 = 0, fd;
 	struct s_mapiterator* iter;
 
-	if( type != ALL_CLIENT )
+	if( type != ALL_CLIENT && type != BG_LISTEN)
 		nullpo_ret(bl);
 
 	sd = BL_CAST(BL_PC, bl);
@@ -499,8 +499,11 @@ int clif_send(const void* buf, int len, struct block_list* bl, enum send_target
 	switch(type) {
 
 	case ALL_CLIENT: //All player clients.
+	case BG_LISTEN:
 		iter = mapit_getallusers();
 		while( ( tsd = (map_session_data*)mapit_next( iter ) ) != nullptr ){
+			if (type == BG_LISTEN && tsd->state.bg_listen)
+				continue;
 			if( session_isActive( fd = tsd->fd ) ){
 				WFIFOHEAD( fd, len );
 				memcpy( WFIFOP( fd, 0 ), buf, len );
@@ -1094,7 +1097,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 	map_session_data* sd = BL_CAST( BL_PC, bl );
 	status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id(bl);
 
 #if PACKETVER < 20091103
 	if( !pcdb_checkid( vd->class_ ) ){
@@ -1115,7 +1118,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 		p.accessory = vd->head_bottom;
 		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id(bl);
 			p.accessory2 = GetWord( g_id, 1 );
 			p.accessory3 = GetWord( g_id, 0 );
 		}else{
@@ -1127,7 +1130,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 		p.bodypalette = vd->cloth_color;
 		p.headDir = ( sd )? sd->head_dir : 0;
 		p.GUID = g_id;
-		p.GEmblemVer = status_get_emblem_id( bl );
+		p.GEmblemVer = clif_visual_emblem_id(bl);
 		p.honor = ( sd ) ? sd->status.manner : 0;
 		p.virtue = ( sc ) ? sc->opt3 : 0;
 		p.isPKModeON = ( sd && sd->status.karma ) ? 1 : 0;
@@ -1184,7 +1187,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 #endif
 	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id(bl);
 		p.accessory2 = GetWord( g_id, 1 );
 		p.accessory3 = GetWord( g_id, 0 );
 	}else{
@@ -1199,7 +1202,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1259,7 +1262,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 	map_session_data* sd = BL_CAST( BL_PC, bl );
 	status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id(bl);
 
 #if PACKETVER < 20091103
 	if( !pcdb_checkid( vd->class_ ) ){
@@ -1280,7 +1283,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 		p.job = vd->class_;
 		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id(bl);
 			p.accessory2 = GetWord( g_id, 1 );
 			p.accessory3 = GetWord( g_id, 0 );
 		}else{
@@ -1326,7 +1329,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 #endif
 	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id(bl);
 		p.accessory2 = GetWord( g_id, 1 );
 		p.accessory3 = GetWord( g_id, 0 );
 	}else{
@@ -1341,7 +1344,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1411,7 +1414,7 @@ static void clif_set_unit_walking( struct block_list *bl, map_session_data *tsd,
 	status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
 	struct packet_unit_walking p;
-	int g_id = status_get_guild_id(bl);
+	int g_id = clif_visual_guild_id(bl);
 
 	sd = BL_CAST(BL_PC, bl);
 
@@ -1449,7 +1452,7 @@ static void clif_set_unit_walking( struct block_list *bl, map_session_data *tsd,
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id(bl);
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -2264,6 +2267,14 @@ void clif_selllist(map_session_data *sd)
 			if( !pc_can_sell_item(sd, &sd->inventory.u.items_inventory[i], nd->subtype))
 				continue;
 
+			if (sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE)
+			{ // Do not allow sell BG/WoE Consumables
+				if (battle_config.bg_reserved_char_id && MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]) == battle_config.bg_reserved_char_id)
+					continue;
+				if (battle_config.woe_reserved_char_id && MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]) == battle_config.woe_reserved_char_id)
+					continue;
+			}
+
 			if (battle_config.rental_item_novalue && sd->inventory.u.items_inventory[i].expire_time)
 				val = 0;
 			else {
@@ -8775,6 +8786,11 @@ void clif_guild_created(map_session_data *sd,int flag)
 ///     &0x01 = allow invite
 ///     &0x10 = allow expel
 void clif_guild_belonginfo( map_session_data& sd ){
+	if (sd.bg_id ) {
+		clif_bg_belonginfo(&sd);
+		return;
+	}
+
 	if( sd.guild == nullptr ){
 		return;
 	}
@@ -8903,9 +8919,12 @@ void clif_guild_masterormember(map_session_data *sd)
 /// 01b6 <guild id>.L <level>.L <member num>.L <member max>.L <exp>.L <max exp>.L <points>.L <honor>.L <virtue>.L <emblem id>.L <name>.24B <master name>.24B <manage land>.16B <zeny>.L (ZC_GUILD_INFO2)
 /// 0a84 <guild id>.L <level>.L <member num>.L <member max>.L <exp>.L <max exp>.L <points>.L <honor>.L <virtue>.L <emblem id>.L <name>.24B <manage land>.16B <zeny>.L <master char id>.L (ZC_GUILD_INFO3)
 void clif_guild_basicinfo( map_session_data& sd ){
-	if( sd.guild == nullptr ){
+	if (sd.bg_id) {
+		clif_bg_basicinfo(sd);
 		return;
 	}
+	else if (sd.guild == nullptr)
+		return;
 
 	const auto &guild = sd.guild->guild;
 	struct PACKET_ZC_GUILD_INFO p = {};
@@ -8945,16 +8964,16 @@ void clif_guild_allianceinfo(map_session_data *sd)
 	int fd,i,c;
 
 	nullpo_retv(sd);
-	auto &g = sd->guild;
-	if (!g)
+	const auto& g = (sd->bg_id ? *bg_guild_get(sd->bg_id):sd->guild->guild);
+	if (!&g)
 		return;
 
 	fd = sd->fd;
 	WFIFOHEAD(fd, MAX_GUILDALLIANCE * 32 + 4);
 	WFIFOW(fd, 0)=0x14c;
 	for(i=c=0;i<MAX_GUILDALLIANCE;i++){
-		struct guild_alliance *a=&g->guild.alliance[i];
-		if(a->guild_id>0){
+		const guild_alliance *a = &g.alliance[i];
+		if (a->guild_id) {
 			WFIFOL(fd,c*32+4)=a->opposition;
 			WFIFOL(fd,c*32+8)=a->guild_id;
 			safestrncpy(WFIFOCP(fd,c*32+12),a->name,NAME_LENGTH);
@@ -8975,6 +8994,10 @@ void clif_guild_allianceinfo(map_session_data *sd)
 ///     probably member's self-introduction (unused, no client UI/packets for editing it)
 /// 0aa5 <packet len>.W { <account>.L <char id>.L <hair style>.W <hair color>.W <gender>.W <class>.W <level>.W <contrib exp>.L <state>.L <position>.L <lastlogin>.L }* (ZC_MEMBERMGR_INFO2)
 void clif_guild_memberlist( map_session_data& sd ){
+	if (sd.bg_id ) {
+		clif_bg_memberlist(&sd);
+		return;
+	}
 	if( sd.guild == nullptr ){
 		return;
 	}
@@ -9029,8 +9052,8 @@ void clif_guild_positionnamelist(map_session_data *sd)
 	int i,fd;
 
 	nullpo_retv(sd);
-	auto &g = sd->guild;
-	if (!g)
+	const auto& g = (sd->bg_id ? *bg_guild_get(sd->bg_id) : sd->guild->guild);
+	if (!&g)
 		return;
 
 	fd = sd->fd;
@@ -9038,7 +9061,7 @@ void clif_guild_positionnamelist(map_session_data *sd)
 	WFIFOW(fd, 0)=0x166;
 	for(i=0;i<MAX_GUILDPOSITION;i++){
 		WFIFOL(fd,i*28+4)=i;
-		safestrncpy(WFIFOCP(fd,i*28+8),g->guild.position[i].name,NAME_LENGTH);
+		safestrncpy(WFIFOCP(fd,i*28+8),g.position[i].name,NAME_LENGTH);
 	}
 	WFIFOW(fd,2)=i*28+4;
 	WFIFOSET(fd,WFIFOW(fd,2));
@@ -9057,15 +9080,15 @@ void clif_guild_positioninfolist(map_session_data *sd)
 	int i,fd;
 
 	nullpo_retv(sd);
-	auto &g = sd->guild;
-	if (!g)
+	const auto& g = (sd->bg_id ? *bg_guild_get(sd->bg_id) : sd->guild->guild);
+	if (!&g)
 		return;
 
 	fd = sd->fd;
 	WFIFOHEAD(fd, MAX_GUILDPOSITION * 16 + 4);
 	WFIFOW(fd, 0)=0x160;
 	for(i=0;i<MAX_GUILDPOSITION;i++){
-		struct guild_position *p=&g->guild.position[i];
+		const guild_position *p=&g.position[i];
 		WFIFOL(fd,i*16+ 4)=i;
 		WFIFOL(fd,i*16+ 8)=p->mode;
 		WFIFOL(fd,i*16+12)=i;
@@ -9155,8 +9178,8 @@ void clif_guild_emblem_area(struct block_list* bl)
 	PACKET_ZC_CHANGE_GUILD p{};
 
 	p.packetType = HEADER_ZC_CHANGE_GUILD;
-	p.guild_id = status_get_guild_id(bl);
-	p.emblem_id = status_get_emblem_id(bl);
+	p.guild_id = clif_visual_guild_id(bl);
+	p.emblem_id = clif_visual_emblem_id(bl);
 	p.AID = bl->id;
 
 	clif_send(&p, sizeof(p), bl, AREA_WOS);
@@ -9171,27 +9194,27 @@ void clif_guild_skillinfo(map_session_data* sd)
 	int i,c;
 
 	nullpo_retv(sd);
-	auto &g = sd->guild;
-	if (!g)
+	const auto& g = (sd->bg_id ? *bg_guild_get(sd->bg_id) : sd->guild->guild);
+	if (!&g)
 		return;
 
 	fd = sd->fd;
 	WFIFOHEAD(fd, 6 + MAX_GUILDSKILL*37);
 	WFIFOW(fd,0) = 0x0162;
-	WFIFOW(fd,4) = g->guild.skill_point;
+	WFIFOW(fd,4) = g.skill_point;
 	for(i = 0, c = 0; i < MAX_GUILDSKILL; i++)
 	{
-		if(g->guild.skill[i].id > 0 && guild_check_skill_require(g->guild, g->guild.skill[i].id))
+		if(g.skill[i].id > 0 && guild_check_skill_require(g, g.skill[i].id))
 		{
-			int id = g->guild.skill[i].id;
+			int id = g.skill[i].id;
 			int p = 6 + c*37;
 			WFIFOW(fd,p+0) = id;
 			WFIFOL(fd,p+2) = skill_get_inf(id);
-			WFIFOW(fd,p+6) = g->guild.skill[i].lv;
-			WFIFOW(fd,p+8) = skill_get_sp(id, g->guild.skill[i].lv);
-			WFIFOW(fd,p+10) = skill_get_range(id, g->guild.skill[i].lv);
+			WFIFOW(fd,p+6) = g.skill[i].lv;
+			WFIFOW(fd,p+8) = skill_get_sp(id, g.skill[i].lv);
+			WFIFOW(fd,p+10) = skill_get_range(id, g.skill[i].lv);
 			safestrncpy(WFIFOCP(fd,p+12), skill_get_name(id), NAME_LENGTH);
-			WFIFOB(fd,p+36)= (g->guild.skill[i].lv < guild_skill_get_max(id) && sd == g->guild.member[0].sd) ? 1 : 0;
+			WFIFOB(fd,p+36)= (g.skill[i].lv < guild_skill_get_max(id) && sd == g.member[0].sd) ? 1 : 0;
 			c++;
 		}
 	}
@@ -10065,7 +10088,16 @@ void clif_name( struct block_list* src, struct block_list *bl, send_target targe
 				safestrncpy( packet.party_name, p->party.name, NAME_LENGTH );
 			}
 
-			if( sd->guild ){
+			// Extended Battleground [Easycore]
+			if (sd->bg_id)
+			{
+				struct mmo_guild *g = bg_guild_get(sd->bg_id);
+				int ps = -1;
+				ps = sd->state.bmaster_flag ? 0 : 1;
+				safestrncpy( packet.guild_name, g->name, NAME_LENGTH );
+				safestrncpy( packet.position_name, g->position[ps].name, NAME_LENGTH );
+			}
+			else if( sd->guild ){
 				int position;
 
 				// Will get the position of the guild the player is in
@@ -11485,6 +11517,8 @@ void clif_parse_WalkToXY(int fd, map_session_data *sd)
 	//Set last idle time... [Skotlex]
 	if (battle_config.idletime_option&IDLE_WALK)
 		sd->idletime = last_tick;
+	if (sd->bg_id)
+		pc_update_last_action(sd);
 	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_WALK)
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_WALK)
@@ -11784,6 +11818,8 @@ void clif_parse_ActionRequest_sub(map_session_data *sd, int action_type, int tar
 		pc_delinvincibletimer(sd);
 		if (battle_config.idletime_option&IDLE_ATTACK)
 			sd->idletime = last_tick;
+		if (sd->bg_id)
+			pc_update_last_action(sd);
 		if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_ATTACK)
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_ATTACK)
@@ -11818,6 +11854,8 @@ void clif_parse_ActionRequest_sub(map_session_data *sd, int action_type, int tar
 
 		if (battle_config.idletime_option&IDLE_SIT)
 			sd->idletime = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 		if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_SIT)
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_SIT)
@@ -11845,6 +11883,8 @@ void clif_parse_ActionRequest_sub(map_session_data *sd, int action_type, int tar
 		if (pc_setstand(sd, false)) {
 			if (battle_config.idletime_option&IDLE_SIT)
 				sd->idletime = last_tick;
+			if (sd && sd->bg_id)
+				pc_update_last_action(sd);
 			if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_SIT)
 				sd->idletime_hom = last_tick;
 			if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_SIT)
@@ -12102,6 +12142,8 @@ void clif_parse_DropItem(int fd, map_session_data *sd){
 
 		if (battle_config.idletime_option&IDLE_DROPITEM)
 			sd->idletime = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 		if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_DROPITEM)
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_DROPITEM)
@@ -12136,6 +12178,8 @@ void clif_parse_UseItem(int fd, map_session_data *sd)
 	//Whether the item is used or not is irrelevant, the char ain't idle. [Skotlex]
 	if (battle_config.idletime_option&IDLE_USEITEM)
 		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USEITEM)
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
@@ -12188,6 +12232,8 @@ void clif_parse_EquipItem(int fd,map_session_data *sd)
 
 	if (battle_config.idletime_option&IDLE_USEITEM)
 		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USEITEM)
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
@@ -12929,6 +12975,8 @@ void clif_parse_skill_toid( map_session_data* sd, uint16 skill_id, uint16 skill_
 	// This is done here, because homunculi and mercenaries can be triggered by AI and not by the player itself
 	if (battle_config.idletime_option&IDLE_USESKILLTOID)
 		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USESKILLTOID)
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USESKILLTOID)
@@ -12999,8 +13047,27 @@ void clif_parse_skill_toid( map_session_data* sd, uint16 skill_id, uint16 skill_
 	sd->skillitem = sd->skillitemlv = 0;
 
 	if( SKILL_CHK_GUILD(skill_id) ) {
-		if (sd->guild && sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING)
+//		if (sd->guild && sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING)
+		if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+			int idx = skill_id - GD_SKILLBASE;
+			if( idx < 0 || idx >= MAX_GUILDSKILL )
+				skill_lv = 0;
+			if(bg && bg->leader_char_id == sd->status.char_id)
+			{
+				if (bg->skill_block_timer[idx] == INVALID_TIMER)
+					skill_lv = bg_checkskill(bg.get(), skill_id);
+				else
+					skill_lv = 0;
+			}
+			else
+				skill_lv = 0;
+		}
+		else if (sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING) {
 			skill_lv = guild_checkskill(sd->guild->guild, skill_id);
+			if (guild_skills_timer(sd,skill_id) >= 0)
+				guild_block_skill_status(sd,skill_id);
+		}
 		else
 			skill_lv = 0;
 	} else {
@@ -13061,6 +13128,8 @@ static void clif_parse_UseSkillToPosSub(int fd, map_session_data *sd, uint16 ski
 	//Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
 	if (battle_config.idletime_option&IDLE_USESKILLTOPOS)
 		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USESKILLTOPOS)
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USESKILLTOPOS)
@@ -14302,11 +14371,16 @@ void clif_parse_GuildChangeMemberPosition( int fd, map_session_data *sd ){
 /// 0151 <guild id>.L
 void clif_parse_GuildRequestEmblem(int fd,map_session_data *sd)
 {
-	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
+	//int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
+	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]),i;
 
 	auto g = guild_search(guild_id);
 
-	if (g)
+	if( guild_id > INT_MAX - 13 && guild_id <= INT_MAX ) {
+		i = (INT_MAX - guild_id);
+		clif_bg_emblem(sd, &bg_guild[i]);
+	}
+	else if( (g = guild_search(guild_id)) != NULL )
 		clif_guild_emblem(*sd, g->guild);
 }
 
@@ -17559,6 +17633,43 @@ void clif_bossmapinfo( map_session_data& sd, mob_data* md, e_bossmap_info flag )
 	clif_send( &p, sizeof( p ), &sd.bl, SELF );
 }
 
+/// Check Equip extended [Easycore]
+/// 0442 <Length>.W <count>.L <Skill_list>.W (ZC_SKILL_SELECT_REQUEST).
+int clif_skill_select_list(map_session_data *sd, map_session_data *tsd) {
+	int i;
+	int fd;
+	unsigned short skills[3];
+	memset(skills, 0, sizeof(skills));
+	skills[0] = CS_EQUIPMENT;
+	skills[1] = CS_BG;
+	skills[2] = CS_WOE;
+
+	nullpo_ret(sd);
+	nullpo_ret(tsd);
+
+	fd = sd->fd;
+
+	if (!fd)
+		return 0;
+
+	WFIFOHEAD(fd, 8 + 3 * 2);
+	WFIFOW(fd, 0) = 0x442;
+
+	for (i = 0; i < 3; i++)
+		WFIFOW(fd, 8 + i * 2) = skills[i];
+
+	WFIFOW(fd, 2) = 8 + 3 * 2;
+	WFIFOL(fd, 4) = 3;
+	WFIFOSET(fd, WFIFOW(fd, 2));
+
+	sd->menuskill_id = SC_AUTOSHADOWSPELL;
+	sd->menuskill_val = 3;
+
+	sd->state.check_equip_skill = tsd->status.account_id;
+	sd->state.workinprogress = WIP_DISABLE_ALL;
+
+	return 1;
+}
 
 /// Requesting equip of a player (CZ_EQUIPWIN_MICROSCOPE).
 /// 02d6 <account id>.L
@@ -17570,6 +17681,11 @@ void clif_parse_ViewPlayerEquip(int fd, map_session_data* sd)
 	if (!tsd)
 		return;
 
+	if (battle_config.bg_extended_check_equip) {
+		clif_skill_select_list(sd, tsd);
+		return;
+	}
+
 	if (sd->bl.m != tsd->bl.m)
 		return;
 	else if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
@@ -18452,6 +18568,11 @@ void clif_parse_bg_queue_apply_request(int fd, map_session_data *sd)
 
 	nullpo_retv(sd);
 
+	if (battle_config.bg_rotation_mode || !battle_config.bg_queue_interface) {
+		clif_displaymessage(sd->fd, msg_txt(sd,2041));
+		return;
+	}
+
 	short type = RFIFOW(fd,2);
 	char name[NAME_LENGTH];
 
@@ -18479,6 +18600,9 @@ void clif_parse_bg_queue_apply_request(int fd, map_session_data *sd)
 /// 0x8d8 <result>.B <battleground name>.24B (ZC_ACK_ENTRY_QUEUE_APPLY)
 void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, map_session_data *sd)
 {
+	if (!battle_config.bg_queue_interface && result == BG_APPLY_ACCEPT)
+		return;
+
 	nullpo_retv(sd);
 
 	int fd = sd->fd;
@@ -18486,6 +18610,9 @@ void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, m
 	WFIFOHEAD(fd, packet_len(0x8d8));
 	WFIFOW(fd,0) = 0x8d8;
 	WFIFOB(fd,2) = result;
+	if (battle_config.bg_rotation_mode)
+		safestrncpy(WFIFOCP(fd,3), "Battleground Arena", NAME_LENGTH);
+	else
 		safestrncpy(WFIFOCP(fd,3), name, NAME_LENGTH);
 	WFIFOSET(fd, packet_len(0x8d8));
 }
@@ -18495,6 +18622,9 @@ void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, m
 /// 0x8d9 <battleground name>.24B <queue number>.L (ZC_NOTIFY_ENTRY_QUEUE_APPLY)
 void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
 {
+	if (!battle_config.bg_queue_interface)
+		return;
+
 	nullpo_retv(sd);
 
 	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
@@ -18508,6 +18638,9 @@ void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
 
 	WFIFOHEAD(fd, packet_len(0x8d9));
 	WFIFOW(fd,0) = 0x8d9;
+	if (battle_config.bg_rotation_mode)
+		safestrncpy(WFIFOCP(fd,2), "Battleground Arena", NAME_LENGTH);
+	else
 		safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
 	WFIFOL(fd,2+NAME_LENGTH) = queue->teama_members.size() + queue->teamb_members.size();
 	WFIFOSET(fd, packet_len(0x8d9));
@@ -18517,6 +18650,9 @@ void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
 /// 0x8db <result>.B <battleground name>.24B (ZC_ACK_ENTRY_QUEUE_CANCEL)
 void clif_bg_queue_cancel_result(bool success, const char *name, map_session_data *sd)
 {
+	if (!battle_config.bg_queue_interface)
+		return;
+
 	nullpo_retv(sd);
 
 	int fd = sd->fd;
@@ -18532,7 +18668,7 @@ void clif_bg_queue_cancel_result(bool success, const char *name, map_session_dat
 /// 0x8da <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_CANCEL)
 void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
 {
-	if (!battle_config.feature_bgqueue)
+	if (!battle_config.feature_bgqueue || !battle_config.bg_queue_interface)
 		return;
 
 	nullpo_retv(sd);
@@ -18553,6 +18689,9 @@ void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
 
 	char name[NAME_LENGTH];
 	
+	if (battle_config.bg_rotation_mode)
+		safestrncpy( name, "Battleground Arena", NAME_LENGTH );
+	else
 		safestrncpy( name, RFIFOCP( fd, 2 ), NAME_LENGTH );
 
 	clif_bg_queue_cancel_result(success, name, sd);
@@ -18562,6 +18701,9 @@ void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
 /// 0x8df <battleground name>.24B <lobby name>.24B (ZC_NOTIFY_LOBBY_ADMISSION)
 void clif_bg_queue_lobby_notify(const char *name, map_session_data *sd)
 {
+	if (!battle_config.bg_queue_interface)
+		return;
+
 	nullpo_retv(sd);
 
 	int fd = sd->fd;
@@ -18596,6 +18738,9 @@ void clif_parse_bg_queue_lobby_reply(int fd, map_session_data *sd)
 /// 0x8e1 <result>.B <battleground name>.24B <lobby name>.24B (ZC_REPLY_ACK_LOBBY_ADMISSION)
 void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbyname, map_session_data *sd)
 {
+	if (!battle_config.bg_queue_interface)
+		return;
+
 	nullpo_retv(sd);
 
 	int fd = sd->fd;
@@ -18612,10 +18757,16 @@ void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbynam
 /// 0x90a <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_RANKING)
 void clif_parse_bg_queue_request_queue_number(int fd, map_session_data *sd)
 {
+	if (!battle_config.bg_queue_interface)
+		return;
+
 	nullpo_retv(sd);
 
 	char name[NAME_LENGTH];
 
+	if (battle_config.bg_rotation_mode)
+		safestrncpy( name, "Battleground Arena", NAME_LENGTH );
+	else
 		safestrncpy( name, RFIFOCP(fd, 2), NAME_LENGTH );
 
 	clif_bg_queue_apply_notify(name, sd);
@@ -18635,6 +18786,185 @@ void clif_bg_queue_entry_init(map_session_data *sd)
 	clif_send( &p, sizeof( p ), &sd->bl, SELF );
 }
 
+void clif_bg_memberlist(map_session_data *sd)
+{
+	map_session_data *psd;
+	int fd, c, i;
+	nullpo_retv(sd);
+
+#if PACKETVER < 20161026
+	int cmd = 0x154;
+	int size = 104;
+#else
+	int cmd = 0xaa5;
+	int size = 34;
+#endif
+
+	if((fd = sd->fd) == 0 )
+		return;
+	if(!sd->bg_id)
+		return;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+	if (!bg)
+		return;
+
+	WFIFOHEAD(fd,bg->members.size() * 104 + 4);
+	WFIFOW(fd,0) = 0x154;
+	for( i = 0, c = 0; i < bg->members.size(); i++ )
+	{
+		if( (psd = bg->members[i].sd) == NULL )
+			continue;
+		WFIFOL(fd,c*104+ 4) = psd->status.account_id;
+		WFIFOL(fd,c*104+ 8) = psd->status.char_id;
+		WFIFOW(fd,c*104+12) = psd->status.hair;
+		WFIFOW(fd,c*104+14) = psd->status.hair_color;
+		WFIFOW(fd,c*104+16) = psd->status.sex;
+		WFIFOW(fd,c*104+18) = psd->status.class_;
+		WFIFOW(fd,c*104+20) = psd->status.base_level;
+		WFIFOL(fd,c*104+22) = 0; // Exp slot used to show kills
+		WFIFOL(fd,c*104+26) = 1; // Online
+		WFIFOL(fd,c*104+30) = psd->state.bmaster_flag ? 0 : 1; // Position
+		WFIFOL(fd,c*104+34)=(uint32)time(NULL);
+		memcpy(WFIFOP(fd,c*104+84),psd->status.name,NAME_LENGTH);
+
+		c++;
+	}
+	WFIFOW(fd, 2)=c*104+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+int clif_visual_guild_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	if ((bg_id = bg_team_get_id(bl)) == 0)
+		return status_get_guild_id(bl);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg && bg->g)
+		return bg->g->guild_id;
+
+	return 0;
+}
+
+int clif_visual_emblem_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	if ((bg_id = bg_team_get_id(bl)) == 0)
+		return status_get_emblem_id(bl);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg && bg->g)
+		return bg->g->emblem_id;
+
+	return 0;
+}
+
+/// Notifies the client that it is belonging to a guild (ZC_UPDATE_GDID).
+/// 016c <guild id>.L <emblem id>.L <mode>.L <ismaster>.B <inter sid>.L <guild name>.24B
+/// mode:
+///     &0x01 = allow invite
+///     &0x10 = allow expel
+void clif_bg_belonginfo(map_session_data *sd)
+{
+	struct mmo_guild *guild;
+
+	nullpo_retv(sd);
+
+	if ((guild = bg_guild_get(sd->bg_id)) == NULL)
+		return;
+
+	struct PACKET_ZC_UPDATE_GDID p = {};
+
+	p.PacketType = HEADER_ZC_UPDATE_GDID;
+	p.guildId = guild->guild_id;
+	p.emblemVersion = guild->emblem_id;
+	p.mode = 0;
+	p.isMaster = 0;
+	p.interSid = 0; // InterSID (unknown purpose)
+	safestrncpy( p.guildName, guild->name, sizeof( p.guildName ) );
+#if PACKETVER_MAIN_NUM >= 20220216
+	p.masterGID = guild->member[0].char_id;
+#endif
+
+	clif_send( &p, sizeof( p ), &sd->bl, SELF );
+}
+
+void clif_bg_emblem(map_session_data *sd, struct mmo_guild *g)
+{
+	int fd;
+
+	nullpo_retv(sd);
+	nullpo_retv(g);
+
+	if( g->emblem_len <= 0 )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,g->emblem_len+12);
+	WFIFOW(fd,0)=0x152;
+	WFIFOW(fd,2)=g->emblem_len+12;
+	WFIFOL(fd,4)=g->guild_id;
+	WFIFOL(fd,8)=g->emblem_id;
+	memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_leave_single(map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd, 66);
+	WFIFOW(fd, 0) = 0x15a;
+	memcpy(WFIFOP(fd, 2), name, NAME_LENGTH);
+	memcpy(WFIFOP(fd, 26), mes, 40);
+	WFIFOSET(fd, 66);
+}
+
+void clif_bg_basicinfo(map_session_data& sd){
+	if (!sd.bg_id){
+		return;
+	}
+
+	struct mmo_guild *guild = bg_guild_get(sd.bg_id);
+	struct PACKET_ZC_GUILD_INFO p = {};
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd.bg_id);
+	if (!bg)
+		return;
+
+	p.PacketType = HEADER_ZC_GUILD_INFO;
+	p.GDID = guild->guild_id;
+	p.level = guild->guild_lv;
+	p.userNum = bg->members.size();
+	p.maxUserNum = guild->max_member;
+	p.userAverageLevel = guild->average_lv;
+	p.exp = (uint32)cap_value( guild->exp, 0, MAX_GUILD_EXP );
+	p.maxExp = (uint32)cap_value( guild->next_exp, 0, MAX_GUILD_EXP );
+	p.point = 0; // Tax Points
+	p.honor = 0; // Honor: (left) Vulgar [-100,100] Famed (right)
+	p.virtue = 0; // Virtue: (down) Wicked [-100,100] Righteous (up)
+	p.emblemVersion = guild->emblem_id;
+	safestrncpy( p.guildname, guild->name, sizeof( p.guildname ) );
+	safestrncpy( p.manageLand, msg_txt( &sd, 300), sizeof( p.manageLand ) );
+	p.zeny = 0;
+#if PACKETVER >= 20200902
+	p.masterGID = bg->leader_char_id; // leader
+	safestrncpy( p.masterName, guild->master, sizeof( p.masterName ) );
+#elif PACKETVER_MAIN_NUM >= 20161019 || PACKETVER_RE_NUM >= 20160921 || defined(PACKETVER_ZERO)
+	p.masterGID = bg->leader_char_id; // leader
+#else
+	safestrncpy( p.masterName, guild->master, sizeof( p.masterName ) );
+#endif
+
+	clif_send( &p, sizeof( p ), &sd.bl, SELF );
+}
+
 /// Custom Fonts (ZC_NOTIFY_FONT).
 /// 02ef <account_id>.L <font id>.W
 void clif_font(map_session_data *sd)
@@ -19698,6 +20028,43 @@ void clif_parse_SkillSelectMenu(int fd, map_session_data *sd) {
 		sd->state.workinprogress = WIP_DISABLE_NONE;
 		skill_autospell(sd, RFIFOW(fd, info->pos[1]));
 	} else if (sd->menuskill_id == SC_AUTOSHADOWSPELL) {
+		// Check Equip Extended [Easycore]
+		if (sd->state.check_equip_skill) {
+			int skill = RFIFOW(fd, info->pos[1]);
+			map_session_data *tsd = map_id2sd(sd->state.check_equip_skill);
+
+			sd->state.check_equip_skill = 0;
+			sd->state.workinprogress = WIP_DISABLE_NONE;
+			clif_menuskill_clear(sd);
+
+			if (!tsd) {
+				clif_displaymessage(fd, msg_txt(sd,2005)); //Player not found.
+				return;
+			}
+
+			if (!(skill >= CS_EQUIPMENT && skill <= CS_WOE))
+				return;
+
+			switch(skill) {
+				case CS_EQUIPMENT:
+					if (sd->bl.m != tsd->bl.m)
+						return;
+					else if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
+						clif_viewequip_ack(sd, tsd);
+					else
+						clif_msg(sd, VIEW_EQUIP_FAIL);
+					break;
+				case CS_BG:
+					pc_battle_stats(sd,tsd,1);
+					break;
+				case CS_WOE:
+					pc_battle_stats(sd,tsd,2);
+					break;
+				default:
+					return;
+			}	
+			return;
+		}
 		if (pc_istrading(sd)) {
 			clif_skill_fail(sd, sd->ud.skill_id, USESKILL_FAIL_LEVEL, 0);
 			clif_menuskill_clear(sd);
@@ -25187,6 +25554,28 @@ void clif_parse_reset_skill( int fd, map_session_data* sd ){
 #endif
 }
 
+void clif_rank_info(map_session_data *sd, int points, int total, e_rank ranktype)
+{
+	char message[100];
+
+	switch(ranktype) {
+		case RANK_BG:
+			if( points < 0 )
+				sprintf(message, msg_txt(sd, 2006), points, total); // [Your Battleground Rank -%d = %d points]
+			else
+				sprintf(message, msg_txt(sd, 2007), points, total); // [Your Battleground Rank +%d = %d points]
+			break;
+		case RANK_WOE:
+			if( points < 0 )
+				sprintf(message, msg_txt(sd, 2008), points, total); // [Your War of Emperium Rank -%d = %d points]
+			else
+				sprintf(message, msg_txt(sd, 2009), points, total); // [Your War of Emperium Rank +%d = %d points]
+			break;
+	}
+	clif_displaymessage(sd->fd, message);
+}
+
+
 /*==========================================
  * Main client packet processing function
  *------------------------------------------*/
diff --git a/src/map/clif.hpp b/src/map/clif.hpp
index 9155b92..d0e2082 100644
--- a/src/map/clif.hpp
+++ b/src/map/clif.hpp
@@ -232,6 +232,7 @@ enum send_target : uint8_t {
 	BG_AREA_WOS,
 
 	CLAN,				// Clan System
+	BG_LISTEN,
 };
 
 enum broadcast_flags : uint8_t {
@@ -1254,4 +1255,18 @@ void clif_macro_reporter_status(map_session_data &sd, e_macro_report_status styp
 
 void clif_dynamicnpc_result( map_session_data& sd, e_dynamicnpc_result result );
 
+// Extended Battleground [Easycore]
+void clif_bg_belonginfo(map_session_data *sd);
+int clif_visual_guild_id(struct block_list *bl);
+int clif_visual_emblem_id(struct block_list *bl);
+void clif_bg_emblem(map_session_data *sd, struct mmo_guild *g);
+void clif_bg_memberlist(map_session_data *sd);
+void clif_bg_leave_single(map_session_data *sd, const char *name, const char *mes);
+//void clif_bg_expulsion_single(map_session_data *sd, const char *name, const char *mes);
+//void clif_bg_updatescore_team(struct battleground_data *bg);
+void clif_bg_leave_single(map_session_data *sd, const char *name, const char *mes);
+void clif_bg_basicinfo(map_session_data& sd);
+
+void clif_rank_info(map_session_data *sd, int points, int total, e_rank ranktype);
+
 #endif /* CLIF_HPP */
diff --git a/src/map/itemdb.hpp b/src/map/itemdb.hpp
index 9a48e90..642b273 100644
--- a/src/map/itemdb.hpp
+++ b/src/map/itemdb.hpp
@@ -58,6 +58,7 @@ enum item_itemid : t_itemid
 	ITEMID_POISON_BOTTLE				= 678,
 	ITEMID_EMPTY_BOTTLE					= 713,
 	ITEMID_EMPERIUM						= 714,
+	ITEMID_YELLOW_GEMSTONE				= 715,
 	ITEMID_RED_GEMSTONE					= 716,
 	ITEMID_BLUE_GEMSTONE				= 717,
 	ITEMID_ORIDECON_STONE				= 756,
diff --git a/src/map/map.cpp b/src/map/map.cpp
index d2afef1..75cbfd9 100644
--- a/src/map/map.cpp
+++ b/src/map/map.cpp
@@ -127,7 +127,7 @@ static struct block_list *bl_list[BL_LIST_MAX];
 static int bl_list_count = 0;
 
 #ifndef MAP_MAX_MSG
-	#define MAP_MAX_MSG 1550
+	#define MAP_MAX_MSG 2050
 #endif
 
 struct map_data map[MAX_MAP_PER_SERVER];
@@ -1976,6 +1976,18 @@ void map_reqnickdb(map_session_data * sd, int charid)
 
 	nullpo_retv(sd);
 
+	if (battle_config.bg_reserved_char_id && battle_config.bg_reserved_char_id == charid)
+	{
+		clif_solved_charname(sd->fd, charid, "Battleground");
+		return;
+	}
+
+	if (battle_config.woe_reserved_char_id && battle_config.woe_reserved_char_id == charid)
+	{
+		clif_solved_charname(sd->fd, charid, "WoE");
+		return;
+	}
+
 	tsd = map_charid2sd(charid);
 	if( tsd )
 	{
@@ -2084,7 +2096,7 @@ int map_quit(map_session_data *sd) {
 	if (sd->npc_id)
 		npc_event_dequeue(sd);
 
-	if (sd->bg_id)
+	if (sd && sd->bg_id)
 		bg_team_leave(sd, true, true);
 
 	if (sd->bg_queue_id > 0)
diff --git a/src/map/map.hpp b/src/map/map.hpp
index 13f1f29..7721c64 100644
--- a/src/map/map.hpp
+++ b/src/map/map.hpp
@@ -673,6 +673,12 @@ enum e_mapflag : int16 {
 	MF_NOBUYINGSTORE,
 	MF_NODYNAMICNPC,
 	MF_NOBANK,
+	// [BattleGround System] [Easycore]
+	MF_NOECALL,
+	MF_BG_CONSUME, // allows using BG consumables [Easycore]
+	MF_WOE_CONSUME, // allows using WoE consumables [Easycore]
+	MF_BG_TOPSCORE,
+	MF_BG_NOMOBMOVE,
 	MF_MAX
 };
 
diff --git a/src/map/mob.cpp b/src/map/mob.cpp
index f189b1f..186e8d0 100644
--- a/src/map/mob.cpp
+++ b/src/map/mob.cpp
@@ -1846,6 +1846,8 @@ static bool mob_ai_sub_hard(struct mob_data *md, t_tick tick)
 		if( md->bg_id && mode&MD_CANATTACK ) {
 			if( md->ud.walktimer != INVALID_TIMER )
 				return true;/* we are already moving */
+			if (map_getmapflag(md->bl.m, MF_BG_NOMOBMOVE)) // Extended Battleground [Easycore]
+				return true;
 			map_foreachinallrange (mob_ai_sub_hard_bg_ally, &md->bl, view_range, BL_PC, md, &tbl, mode);
 			if( tbl ) {
 				if( distance_blxy(&md->bl, tbl->x, tbl->y) <= 3 || unit_walktobl(&md->bl, tbl, 1, 1) )
@@ -3113,6 +3115,8 @@ int mob_dead(struct mob_data *md, struct block_list *src, int type)
 			// The master or Mercenary can increase the kill count
 			if (sd->md && src && (src->type == BL_PC || src->type == BL_MER) && mob->lv > sd->status.base_level / 2)
 				mercenary_kills(sd->md);
+			// Easycore eBG
+			pc_record_mobkills(sd,md);
 		}
 
 		if( md->npc_event[0] && !md->state.npc_killmonster ) {
@@ -4922,7 +4926,10 @@ void MobDatabase::loadingFinished() {
 				mob->status.mode = static_cast<e_mode>(mob->status.mode | MD_STATUSIMMUNE);
 				break;
 			case CLASS_BATTLEFIELD:
+				if (battle_config.bg_monsters_skillimmune)
 					mob->status.mode = static_cast<e_mode>(mob->status.mode | (MD_STATUSIMMUNE | MD_SKILLIMMUNE));
+				else
+					mob->status.mode = static_cast<e_mode>(mob->status.mode | MD_STATUSIMMUNE );
 				break;
 			case CLASS_EVENT:
 				mob->status.mode = static_cast<e_mode>(mob->status.mode | MD_FIXEDITEMDROP);
diff --git a/src/map/npc.hpp b/src/map/npc.hpp
index 935f489..030e8b7 100644
--- a/src/map/npc.hpp
+++ b/src/map/npc.hpp
@@ -185,7 +185,7 @@ struct npc_data {
 		struct {
 			struct script_code *script;
 			short xs,ys; // OnTouch area radius
-			int guild_id;
+			int guild_id, bg_id;
 			t_tick timer;
 			int timerid,timeramount,rid;
 			t_tick timertick;
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
index 1dc3263..4cf5ea4 100644
--- a/src/map/pc.cpp
+++ b/src/map/pc.cpp
@@ -93,6 +93,8 @@ int pc_expiration_tid = INVALID_TIMER;
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 const std::string AttendanceDatabase::getDefaultLocation(){
 	return std::string(db_path) + "/attendance.yml";
@@ -1009,6 +1011,333 @@ void pc_delabyssball( map_session_data& sd, int count ){
 	clif_abyssball( sd );
 }
 
+void pc_record_mobkills(map_session_data *sd, struct mob_data *md)
+{
+	nullpo_retv(sd);
+	int type = 0;
+	if (sd->guild && map_flag_gvg2(sd->bl.m) && is_agit_start()) {
+		switch(md->mob_id) {
+		case MOBID_EMPERIUM:
+			pc_addwoepoints(sd,100);
+			add2limit(sd->status.wstats.emperium_kill, 1, USHRT_MAX);
+			break;
+		case 1905:
+			pc_addwoepoints(sd,5);
+			add2limit(sd->status.wstats.barricade_kill, 1, USHRT_MAX);
+			break;
+		case MOBID_GUARDIAN_STONE1:
+		case MOBID_GUARDIAN_STONE2:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.gstone_kill, 1, USHRT_MAX);
+			break;
+		case 1285:
+		case 1286:
+		case 1287:
+		case 1899:
+		case 1900:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.guardian_kill, 1, USHRT_MAX);
+			break;
+		}
+	}
+	return;
+}
+
+void pc_record_damage(struct block_list *src, struct block_list *target, int damage)
+{
+	if (!src || !target || src == target || damage <= 0)
+		return;
+
+	struct block_list *s_bl;
+	map_session_data *sd;
+	struct mob_data *md;
+
+	if ((s_bl = battle_get_master(src)) == NULL)
+		s_bl = src;
+
+	if (s_bl->type != BL_PC)
+		return;
+
+	sd = BL_CAST(BL_PC, s_bl);
+
+	switch(target->type) {
+		case BL_PC:
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				add2limit(sd->status.bgstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.bgstats.damage_received, damage, UINT_MAX);
+				if (sd->status.bgstats.top_damage < damage)
+					sd->status.bgstats.top_damage = damage;
+			}
+			else if (map_flag_gvg2(src->m) && is_agit_start()) {
+				add2limit(sd->status.wstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.wstats.damage_received, damage, UINT_MAX);
+				if (sd->status.wstats.top_damage < damage)
+					sd->status.wstats.top_damage = damage;
+			}
+			break;
+		case BL_MOB: {
+			if ((md = BL_CAST(BL_MOB, target))== NULL)
+				return;
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				if (md->mob_id >= 21406 || md->mob_id <= 21408)
+				add2limit(sd->status.bgstats.boss_damage, damage, UINT_MAX);
+			} else if (map_flag_gvg2(src->m) && is_agit_start()) {
+				switch(md->mob_id) {
+					case MOBID_EMPERIUM:
+						add2limit(sd->status.wstats.emperium_damage, damage, UINT_MAX);
+						break;
+					case 1905:
+						add2limit(sd->status.wstats.barricade_damage, damage, UINT_MAX);
+						break;
+					case MOBID_GUARDIAN_STONE1:
+					case MOBID_GUARDIAN_STONE2:
+						add2limit(sd->status.wstats.gstone_damage, damage, UINT_MAX);
+						break;
+					default:
+						add2limit(sd->status.wstats.guardian_damage, damage, UINT_MAX);
+						break;
+				}
+			}
+			break;
+		}
+	}
+}
+
+void pc_rank_reset(int type)
+{
+	map_session_data *sd = NULL;
+	struct s_mapiterator* iter = NULL;
+	//int i;
+
+	iter = mapit_getallusers();
+	for (sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter))
+	{
+		switch(type) {
+			case RANK_BG: // Battleground Stats}
+				sd->status.bgstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+			case RANK_WOE: // WoE Ranking Reset
+				sd->status.wstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+		}
+	}
+	mapit_free(iter);
+
+	switch(type) {
+		case RANK_BG:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_bg` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+		case RANK_WOE:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_wstats` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+	}
+
+	chrif_buildfamelist();
+}
+
+void pc_battle_stats(map_session_data *sd, map_session_data *tsd, int flag)
+{
+	if (!sd || !tsd)
+		return;
+
+	char output[CHAT_SIZE_MAX];
+
+	// Battleground Stats
+	if (flag == 1) {
+		if (sd != tsd && tsd->status.bgstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "============ BATTLEGROUND STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_)); clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-1))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-1),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.kill_count, tsd->status.bgstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.bgstats.damage_done,tsd->status.bgstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.bgstats.damage_received, tsd->status.bgstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Deserter times: %d", tsd->status.bgstats.deserter);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.bgstats.hp_heal_potions, tsd->status.bgstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.bgstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (tsd->status.bgstats.yellow_gemstones || tsd->status.bgstats.red_gemstones|| tsd->status.bgstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.bgstats.yellow_gemstones, tsd->status.bgstats.red_gemstones, tsd->status.bgstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.bgstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.zeny_used || tsd->status.bgstats.spiritb_used || tsd->status.bgstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.bgstats.zeny_used, tsd->status.bgstats.spiritb_used, tsd->status.bgstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.leader_win || tsd->status.bgstats.leader_lost || tsd->status.bgstats.leader_tie) {
+			sprintf(output, "    Leader wins: %d    -    Leader lost: %d    -    Leader draw: %d", tsd->status.bgstats.leader_win, tsd->status.bgstats.leader_lost, tsd->status.bgstats.leader_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ti_wins || tsd->status.bgstats.ti_lost || tsd->status.bgstats.ti_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Triple Inferno ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ti_wins, tsd->status.bgstats.ti_lost, tsd->status.bgstats.ti_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Skulls (points): %d", tsd->status.bgstats.skulls);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.eos_wins || tsd->status.bgstats.eos_lost || tsd->status.bgstats.eos_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Eye of the Storm ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.eos_wins, tsd->status.bgstats.eos_lost, tsd->status.bgstats.eos_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flags: %d    -    Bases: %d", tsd->status.bgstats.eos_flags, tsd->status.bgstats.eos_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.boss_wins || tsd->status.bgstats.boss_lost || tsd->status.bgstats.boss_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Tierra Bossnia ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.boss_wins, tsd->status.bgstats.boss_lost, tsd->status.bgstats.boss_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Boss kills: %d    -    Boss damage: %d    -    Flags: %d", tsd->status.bgstats.boss_killed, tsd->status.bgstats.eos_bases, tsd->status.bgstats.boss_flags);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.td_wins || tsd->status.bgstats.td_lost || tsd->status.bgstats.td_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Team Deathmatch ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.td_wins, tsd->status.bgstats.td_lost, tsd->status.bgstats.td_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.td_kills, tsd->status.bgstats.td_deaths);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.dom_wins || tsd->status.bgstats.dom_lost || tsd->status.bgstats.dom_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Domination ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.dom_wins, tsd->status.bgstats.dom_lost, tsd->status.bgstats.dom_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Offensive Kills: %d    -    Defensive Kills: %d", tsd->status.bgstats.dom_off_kills, tsd->status.bgstats.dom_def_kills);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Bases: %d", tsd->status.bgstats.dom_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.sc_wins || tsd->status.bgstats.sc_lost || tsd->status.bgstats.sc_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Stone Control ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.sc_wins, tsd->status.bgstats.sc_lost, tsd->status.bgstats.sc_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d    -    Stone Stolen: %d-    Stone Dropped: %d", tsd->status.bgstats.sc_captured, tsd->status.bgstats.sc_stole, tsd->status.bgstats.sc_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ctf_wins || tsd->status.bgstats.ctf_lost || tsd->status.bgstats.ctf_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Capture the Flag ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ctf_wins, tsd->status.bgstats.ctf_lost, tsd->status.bgstats.ctf_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flag captures: %d    -    Flag taken: %d    -    Flag Dropped: %d", tsd->status.bgstats.ctf_captured, tsd->status.bgstats.ctf_taken, tsd->status.bgstats.ctf_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.cq_wins || tsd->status.bgstats.cq_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Conquest ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.cq_wins, tsd->status.bgstats.cq_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Emperium kills: %d    -    Barricade Kills: %d", tsd->status.bgstats.emperium_kill, tsd->status.bgstats.barricade_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Guardian Stone kills: %d", tsd->status.bgstats.gstone_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ru_wins || tsd->status.bgstats.ru_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Rush ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.ru_wins, tsd->status.bgstats.ru_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d", tsd->status.bgstats.ru_captures);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+	// War of Emperium Stats
+	} else {
+		if (sd != tsd && tsd->status.wstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "============ WAR OF EMPERIUM STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_));
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-2))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-2),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.wstats.kill_count, tsd->status.wstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.wstats.damage_done,tsd->status.wstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.wstats.damage_received, tsd->status.wstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.wstats.hp_heal_potions, tsd->status.wstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.wstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Emperium kills: %d    -    Emperium damage: %d", tsd->status.wstats.emperium_kill, tsd->status.wstats.emperium_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Barricade kills: %d    -    Barricade damage: %d", tsd->status.wstats.barricade_kill, tsd->status.wstats.barricade_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Guardian kills: %d    -    Guardian damage: %d", tsd->status.wstats.guardian_kill, tsd->status.wstats.guardian_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (tsd->status.wstats.yellow_gemstones || tsd->status.wstats.red_gemstones|| tsd->status.wstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.wstats.yellow_gemstones, tsd->status.wstats.red_gemstones, tsd->status.wstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.wstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.zeny_used || tsd->status.wstats.spiritb_used || tsd->status.wstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.wstats.zeny_used, tsd->status.wstats.spiritb_used, tsd->status.wstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+	}
+}
+
+/**
+* Increases a player's battleground points and displays a notice to him
+* @param sd Player
+* @param count BG Point
+*/
+void pc_addbgpoints(map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.bgstats.points += count;
+	if (sd->status.bgstats.points > MAX_FAME)
+		sd->status.bgstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.bgstats.points,RANK_BG);
+	chrif_updatefamelist(*sd, RANK_BG);
+}
+
+/**
+* Increases a player's war of emperium points and displays a notice to him
+* @param sd Player
+* @param count WoE Point
+*/
+void pc_addwoepoints(map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.wstats.points += count;
+	if (sd->status.wstats.points > MAX_FAME)
+		sd->status.wstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.wstats.points,RANK_WOE);
+	chrif_updatefamelist(*sd, RANK_WOE);
+}
+
 /**
 * Increases a player's fame points and displays a notice to him
 * @param sd Player
@@ -1046,6 +1375,22 @@ bool pc_addfame(map_session_data &sd, int count)
 unsigned char pc_famerank(uint32 char_id, int job)
 {
 	uint8 i;
+	// Battleground Rank [Easycore]
+	if (job == -1) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+			if(bg_fame_list[i].id == char_id)
+				return i + 1;
+		}
+		return 0;
+	}
+	// War of Emperium Rank [Easycore]
+	else if (job == -2) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+			if(woe_fame_list[i].id == char_id)
+				return i + 1;
+		}
+		return 0;
+	}
 
 	switch(job){
 		case MAPID_BLACKSMITH: // Blacksmith
@@ -5851,9 +6196,18 @@ int pc_getcash(map_session_data *sd, int cash, int points, e_log_pick_type type)
  * @return Stored index in inventory, or -1 if not found.
  **/
 short pc_search_inventory(map_session_data *sd, t_itemid nameid) {
-	short i;
+	short i,x,y;
 	nullpo_retr(-1, sd);
 
+	if (map_getmapflag(sd->bl.m, MF_BG_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, x, sd->inventory.u.items_inventory[x].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[x].card[2], sd->inventory.u.items_inventory[x].card[3]) == battle_config.bg_reserved_char_id ) && (sd->inventory.u.items_inventory[x].amount > 0 || nameid == 0) );
+			if( x < MAX_INVENTORY ) return x;
+	}
+	if (map_getmapflag(sd->bl.m, MF_WOE_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, y, sd->inventory.u.items_inventory[y].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[y].card[2], sd->inventory.u.items_inventory[y].card[3]) == battle_config.woe_reserved_char_id ) && (sd->inventory.u.items_inventory[y].amount > 0 || nameid == 0) );
+			if( y < MAX_INVENTORY ) return y;
+	}
+
 	ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && (sd->inventory.u.items_inventory[i].amount > 0 || nameid == 0) );
 	return ( i < MAX_INVENTORY ) ? i : -1;
 }
@@ -6376,6 +6730,13 @@ int pc_useitem(map_session_data *sd,int n)
 		return 0;
 	}
 
+	if( sd->inventory.u.items_inventory[n].card[0] == CARD0_CREATE) {
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME))
+			return 0;
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME))
+			return 0;
+	}
+
 	sd->itemid = item.nameid;
 	sd->itemindex = n;
 	if(sd->catch_target_class != PET_CATCH_FAIL) //Abort pet catching.
@@ -9788,6 +10149,24 @@ int pc_dead(map_session_data *sd,struct block_list *src)
 			// To-do: Receive exp on certain occasions
 #endif
 		}
+		// Extended Battleground [Easycore]
+		if (sd && sd->bg_id) {
+			achievement_update_objective(sd, AG_BG_DIE, 1, 1);
+			add2limit(sd->status.bgstats.death_count, 1, USHRT_MAX);
+		}
+		if (ssd->bg_id && ssd->bg_id != sd->bg_id) {
+			achievement_update_objective(ssd, AG_BG_DAMAGE, 1, ssd->status.bgstats.damage_done);
+			achievement_update_objective(ssd, AG_BG_KILL, 1, 1);
+			add2limit(ssd->status.bgstats.kill_count, 1, USHRT_MAX);
+		}
+
+		if (map_flag_gvg2(sd->bl.m) && is_agit_start()) {
+			achievement_update_objective(sd, AG_WOE_DAMAGE, 1, sd->status.wstats.damage_done);
+			achievement_update_objective(sd, AG_WOE_DIE, 1, 1);
+			achievement_update_objective(ssd, AG_WOE_KILL, 1, 1);
+			add2limit(sd->status.wstats.death_count, 1, USHRT_MAX);
+			add2limit(ssd->status.wstats.kill_count, 1, USHRT_MAX);
+		}
 	}
 
 	if(battle_config.bone_drop==2
@@ -10530,6 +10909,11 @@ int pc_itemheal(map_session_data *sd, t_itemid itemid, int hp, int sp)
 		tmp = hp * bonus / 100; // Overflow check
 		if (bonus != 100 && tmp > hp)
 			hp = tmp;
+		//Extended Features BG [Easycore]
+		if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id)
+			add2limit(sd->status.bgstats.hp_heal_potions, 1, UINT_MAX);
+		else if (sd->guild && map_flag_gvg2(sd->bl.m) && is_agit_start())
+			add2limit(sd->status.wstats.hp_heal_potions, 1, UINT_MAX);
 	}
 	if (sp) {
 		bonus = 100 + (sd->battle_status.int_ * 2) + pc_checkskill(sd, MG_SRECOVERY) * 10 + pc_checkskill(sd, AM_LEARNINGPOTION) * 5;
@@ -10552,6 +10936,11 @@ int pc_itemheal(map_session_data *sd, t_itemid itemid, int hp, int sp)
 		tmp = sp * bonus / 100; // Overflow check
 		if (bonus != 100 && tmp > sp)
 			sp = tmp;
+		//Extended Features BG [Easycore]
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.sp_heal_potions, 1, UINT_MAX);
+		else if (sd->guild && map_flag_gvg2(sd->bl.m) && is_agit_start())
+			add2limit(sd->status.wstats.sp_heal_potions, 1, UINT_MAX);
 	}
 	if (sd->sc.count) {
 		// Critical Wound and Death Hurt stack
@@ -11160,6 +11549,12 @@ bool pc_candrop(map_session_data *sd, struct item *item)
 		return false;
 	if( !pc_can_give_items(sd) || sd->sc.cant.drop) //check if this GM level can drop items
 		return false;
+	if( item->card[0] == CARD0_CREATE) {
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.bg_reserved_char_id)
+			return false;
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.woe_reserved_char_id)
+			return false;
+	}
 	return (itemdb_isdropable(item, pc_get_group_level(sd)));
 }
 
@@ -15814,6 +16209,27 @@ uint64 CaptchaDatabase::parseBodyNode(const ryml::NodeRef &node) {
 	return 1;
 }
 
+/***********************************************************
+* Update Idle PC Timer
+***********************************************************/
+int pc_update_last_action(map_session_data *sd)
+{
+	if (!sd->bg_id)
+		return 1;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+	sd->idletime = last_tick;
+
+	if (bg && sd->state.bg_afk)
+	{ // Battleground AFK announce
+		char output[128];
+		sprintf(output, msg_txt(NULL, 2010), bg->g->name, sd->status.name); // %s : %s is no longer AFK...
+		clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+		sd->state.bg_afk = 0;
+	}
+
+	return 1;
+}
+
 /*==========================================
  * pc Init/Terminate
  *------------------------------------------*/
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
index 22e2c8a..da8bd5f 100644
--- a/src/map/pc.hpp
+++ b/src/map/pc.hpp
@@ -455,6 +455,11 @@ public:
 		bool roulette_open;
 		t_itemid item_reform;
 		uint64 item_enchant_index;
+		// Extended Battleground [Easycore]
+		unsigned bg_afk : 1;
+		unsigned int bg_listen : 1;
+		int check_equip_skill;
+		unsigned int bmaster_flag : 1; // Extended Battleground [Easycore]
 	} state;
 	struct {
 		unsigned char no_weapon_damage, no_magic_damage, no_misc_damage;
@@ -1657,6 +1662,8 @@ bool pc_set_hate_mob(map_session_data *sd, int pos, struct block_list *bl);
 extern struct fame_list smith_fame_list[MAX_FAME_LIST];
 extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
 extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
+extern struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 void pc_readdb(void);
 void do_init_pc(void);
@@ -1748,6 +1755,15 @@ void pc_macro_detector_disconnect(map_session_data &sd);
 void pc_macro_reporter_area_select(map_session_data &sd, const int16 x, const int16 y, const int8 radius);
 void pc_macro_reporter_process(map_session_data &sd, int32 reporter_account_id = -1);
 
+// Extended Battleground [Easycore]
+int pc_update_last_action(map_session_data *sd);
+void pc_addbgpoints(map_session_data *sd,int count);
+void pc_addwoepoints(map_session_data *sd,int count);
+void pc_battle_stats(map_session_data *sd, map_session_data *tsd, int flag);
+void pc_rank_reset(int type);
+void pc_record_damage(struct block_list *src, struct block_list *target, int damage);
+void pc_record_mobkills(map_session_data *sd, struct mob_data *md);
+
 #ifdef MAP_GENERATOR
 void pc_reputation_generate();
 #endif
diff --git a/src/map/script.cpp b/src/map/script.cpp
index d6b1939..f706851 100644
--- a/src/map/script.cpp
+++ b/src/map/script.cpp
@@ -21285,6 +21285,15 @@ BUILDIN_FUNC(bg_get_data)
 			mapreg_setreg(add_str("$@arenamemberscount"), i);
 			script_pushint(st, i);
 			break;
+		case 2:
+			script_pushconststr(st, bg->g ? bg->g->name : "null");
+			break;
+		case 3:
+			script_pushconststr(st, bg->g ? bg->g->master : "null");
+			break;
+		case 4:
+			script_pushint(st, bg->color);
+			break;
 		default:
 			ShowError("script:bg_get_data: unknown data identifier %d\n", type);
 			break;
diff --git a/src/map/script.hpp b/src/map/script.hpp
index 3c0c6b1..c350d9e 100644
--- a/src/map/script.hpp
+++ b/src/map/script.hpp
@@ -2180,6 +2180,32 @@ enum e_iteminfo : uint8 {
 	ITEMINFO_SUBTYPE,
 };
 
+/* Extended Battleground [Easycore] */
+enum rankpoints_type {
+	BGR_FAME,
+	BGR_SKULLS,
+	BGR_EOS_FLAGS,
+	BGR_SC_STOLE,
+	BGR_SC_CAPTURED,
+	BGR_SC_DROPPED,
+	BGR_CTF_TAKEN,
+	BGR_CTF_CAPTURED,
+	BGR_CTF_DROPPED,
+	BGR_DOM_BASES,
+	BGR_DOM_OFF_KILLS,
+	BGR_DOM_DEF_KILLS,
+	BGR_BARRICADE,
+	BGR_EMPERIUM,
+	BGR_GSTONE,
+	BGR_RU_CAPTURES,
+	BGR_BOSS_FLAGS,
+	BGR_BOSS_KILLED,
+	BGR_TD_KILL,
+	BGR_TD_DEATH,
+	BGR_MAX
+};
+
+
 class ConstantDatabase : public YamlDatabase {
 public:
 	ConstantDatabase() : YamlDatabase("CONSTANT_DB", 1) {
diff --git a/src/map/script_constants.hpp b/src/map/script_constants.hpp
index 987c676..83255e8 100644
--- a/src/map/script_constants.hpp
+++ b/src/map/script_constants.hpp
@@ -557,6 +557,19 @@
 	export_constant(MF_NOBUYINGSTORE);
 	export_constant(MF_NODYNAMICNPC);
 	export_constant(MF_NOBANK);
+	// Battleground Extended [Easycore]
+	export_constant(MF_NOECALL);
+	export_constant(MF_BG_CONSUME);
+	export_constant(MF_WOE_CONSUME);
+	export_constant(MF_BG_TOPSCORE);
+	export_constant(MF_BG_NOMOBMOVE);
+	// Required for Extended BG
+	export_constant(SCCB_BUFFS);
+	export_constant(SCCB_DEBUFFS);
+	export_constant(SCCB_REFRESH);
+	export_constant(SCCB_CHEM_PROTECT);
+	export_constant(SCCB_LUXANIMA);
+	export_constant(SCCB_HERMODE);
 
 	/* setcell types */
 	export_constant(CELL_WALKABLE);
@@ -7033,6 +7046,18 @@
 	export_constant(AG_ENCHANT_SUCCESS);
 	export_constant(AG_SPEND_ZENY);
 	export_constant(AG_TAMING);
+	// Extended Battleground [Easycore]
+	export_constant(AG_BG_WIN);
+	export_constant(AG_BG_LOSE);
+	export_constant(AG_BG_TIE);
+	export_constant(AG_BG_KILL);
+	export_constant(AG_BG_DIE);
+	export_constant(AG_BG_DAMAGE);
+	export_constant(AG_BG_HEAL);
+	export_constant(AG_WOE_KILL);
+	export_constant(AG_WOE_DIE);
+	export_constant(AG_WOE_DAMAGE);
+	export_constant(AG_WOE_HEAL);
 
 	/* achievement info */
 	export_constant(ACHIEVEINFO_COUNT1);
@@ -10422,6 +10447,28 @@
 	export_constant(MER_DIETER);
 	export_constant(MER_ELEANOR);
 
+	/* Extended Battleground [Easycore] */
+	export_constant(BGR_FAME);
+	export_constant(BGR_SKULLS);
+	export_constant(BGR_EOS_FLAGS);
+	export_constant(BGR_SC_STOLE);
+	export_constant(BGR_SC_CAPTURED);
+	export_constant(BGR_SC_DROPPED);
+	export_constant(BGR_CTF_TAKEN);
+	export_constant(BGR_CTF_CAPTURED);
+	export_constant(BGR_CTF_DROPPED);
+	export_constant(BGR_DOM_BASES);
+	export_constant(BGR_DOM_OFF_KILLS);
+	export_constant(BGR_DOM_DEF_KILLS);
+	export_constant(BGR_BARRICADE);
+	export_constant(BGR_EMPERIUM);
+	export_constant(BGR_GSTONE);
+	export_constant(BGR_RU_CAPTURES);
+	export_constant(BGR_BOSS_FLAGS);
+	export_constant(BGR_BOSS_KILLED);
+	export_constant(BGR_TD_KILL);
+	export_constant(BGR_TD_DEATH);
+
 	#undef export_constant
 	#undef export_constant2
 	#undef export_parameter
diff --git a/src/map/skill.cpp b/src/map/skill.cpp
index 2451613..3783c67 100644
--- a/src/map/skill.cpp
+++ b/src/map/skill.cpp
@@ -855,6 +855,24 @@ bool skill_isNotOk(uint16 skill_id, map_session_data *sd)
 		return true;
 	}
 
+	// Extended Battleground [Easycore]
+	if (SKILL_CHK_GUILD(skill_id)) {
+		if (sd->bg_id) {
+			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+			if (bg && bg_block_skill_status(bg.get(), skill_id))
+				return true;
+			else
+				return false;
+		} else {
+			if (skill_blockpc_get(sd, skill_id) != -1) {
+				char output[CHAT_SIZE_MAX];
+				snprintf(output, sizeof(output), msg_txt(sd, 2040), skill_get_desc(skill_id), guild_skills_timer(sd,skill_id)); // [%s] ready in %ds
+				clif_messagecolor(&sd->bl, color_table[COLOR_RED], output, false, GUILD);
+				return true;
+			}
+		}
+	}
+
 	if (skill_blockpc_get(sd, skill_id) != -1){
 		clif_skill_fail(sd,skill_id,USESKILL_FAIL_SKILLINTERVAL,0);
 		return true;
@@ -7338,7 +7356,24 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			clif_skill_nodamage (src, bl, skill_id, heal, 1);
 			if( tsc && tsc->getSCE(SC_AKAITSUKI) && heal && skill_id != HLIF_HEAL )
 				heal = ~heal + 1;
-			t_exp heal_get_jobexp = status_heal(bl,heal,0,0);
+			int heal_get_jobexp = status_heal(bl,heal,0,0);
+			// Extended Features BG [Easycore]
+			if (sd && dstsd) {
+				if (map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id) {
+					if (sd->bg_id == dstsd->bg_id) {
+						achievement_update_objective(sd, AG_BG_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.bgstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.bgstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+				else if (is_agit_start() && map_flag_gvg2(src->m) && sd->guild && dstsd->guild) {
+					if (sd->guild == dstsd->guild) {
+						achievement_update_objective(sd, AG_WOE_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.wstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.wstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+			}
 
 			if(sd && dstsd && heal > 0 && sd != dstsd && battle_config.heal_exp > 0){
 				heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
@@ -8077,6 +8112,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 
 	case CD_COMPETENTIA:
 		if (sd == nullptr || sd->status.party_id == 0 || (flag & 1)) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			int hp_amount = tstatus->max_hp * (20 * skill_lv) / 100;
 			int sp_amount = tstatus->max_sp * (20 * skill_lv) / 100;
 
@@ -8087,7 +8124,10 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			status_heal(bl, 0, sp_amount, 0);
 
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if (sd)
+		}
+		else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
 				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		break;
 
@@ -8383,7 +8423,10 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 				}
 
 				clif_skill_nodamage(src, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, src->id, i, 0, skill_get_time(skill_id, skill_lv)));
-			} else if (sd)
+			}
+			else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
 				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		}
 		break;
@@ -8792,13 +8835,16 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case PR_MAGNIFICAT:
 	case PR_GLORIA:
 		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
-
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			// Animations don't play when outside visible range
 			if (check_distance_bl(src, bl, AREA_SIZE))
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, 1);
 
 			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
 		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
 		else if (sd)
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
 		break;
@@ -8813,10 +8859,15 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case NV_HELPANGEL:
 	case IG_GUARDIAN_SHIELD:
 	case IG_ULTIMATE_SACRIFICE:// Is the animation on this skill correct? Check if its on caster only or all affected. [Rytech]
-		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) )
+		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
-		else if (sd)
-		{
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd) {
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
 			if (skill_id == IG_ULTIMATE_SACRIFICE)
 				status_set_hp(src, 1, 0);
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
@@ -8840,16 +8891,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case BS_OVERTHRUST:
 		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
 			int weapontype = skill_get_weapontype(skill_id);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			if (!weapontype || !dstsd || pc_check_weapontype(dstsd, weapontype)) {
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
 					sc_start2(src, bl, type, 100, skill_lv, (src == bl) ? 1 : 0, skill_get_time(skill_id, skill_lv)));
 			}
-		} else if (sd) {
-			party_foreachsamemap(skill_area_sub,
-				sd,skill_get_splash(skill_id, skill_lv),
-				src,skill_id,skill_lv,tick, flag|BCT_PARTY|1,
-				skill_castend_nodamage_id);
 		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
 		break;
 
 	case BS_MAXIMIZE:
@@ -10251,6 +10303,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		// Updated to block Slim Pitcher from working on barricades and guardian stones.
 		if (dstmd && (dstmd->mob_id == MOBID_EMPERIUM || status_get_class_(bl) == CLASS_BATTLEFIELD))
 			break;
+		if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+			break;
 		if (potion_hp || potion_sp) {
 			int hp = potion_hp, sp = potion_sp;
 			hp = hp * (100 + (tstatus->vit * 2))/100;
@@ -10437,24 +10491,32 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case GD_RESTORE:
 	case GD_EMERGENCY_MOVE:
 		if(flag&1) {
-			if (status_get_guild_id(src) == status_get_guild_id(bl)) {				
+			if (status_get_guild_id(src) == status_get_guild_id(bl) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src) == bg_team_get_id(bl))) {
 				if( skill_id == GD_RESTORE )
 					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
 				else
 					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
 			}
-		} else if (status_get_guild_id(src)) {
+		} else if (status_get_guild_id(src) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src))) {
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			map_foreachinallrange(skill_area_sub, src,
 				skill_get_splash(skill_id, skill_lv), BL_PC,
-				src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
+				src,skill_id,skill_lv,tick, flag|BCT_NOENEMY|1,
 				skill_castend_nodamage_id);
-			if (sd)
+			if (sd) {
+				std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
 #ifdef RENEWAL
+				if (bg && sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_cooldown(skill_id, skill_lv));
+				else
 					skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
 #else
+				if (bg && sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_time2(skill_id, skill_lv));
+				else
 					guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
 #endif
+		}
 		}
 		break;
 	case GD_EMERGENCYCALL:
@@ -10463,9 +10525,18 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			int8 dx[9] = {-1, 1, 0, 0,-1, 1,-1, 1, 0};
 			int8 dy[9] = { 0, 0, 1,-1, 1,-1,-1, 1, 0};
 			uint8 j = 0, calls = 0, called = 0;
-			// i don't know if it actually summons in a circle, but oh well. ;P
+			struct mmo_guild *g = NULL;
+			std::shared_ptr<s_battleground_data> bg = nullptr;
+			int max_member;
+			if (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src)) {
+				bg = util::umap_find(bg_team_db, bg_team_get_id(src));
+				max_member = bg->members.size();
+			} else {
+				//g = sd?sd->guild:guild_search(status_get_guild_id(src));
 			auto g = sd?sd->guild:guild_search(status_get_guild_id(src));
-			if (!g)
+				max_member = g->guild.max_member;
+			}
+			if (!g && !bg)
 				break;
 
 			if (skill_id == GD_ITEMEMERGENCYCALL)
@@ -10477,11 +10548,14 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 				}
 
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-			for (i = 0; i < g->guild.max_member && (!calls || (calls && called < calls)); i++, j++) {
+			//for (i = 0; i < g->guild.max_member && (!calls || (calls && called < calls)); i++, j++) {
+			for (i = 0; i < max_member && (!calls || (calls && called < calls)); i++, j++) {
 				if (j > 8)
 					j = 0;
-				if ((dstsd = g->guild.member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
-					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
+//				if ((dstsd = g->guild.member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+//					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
+				if ((dstsd = bg?bg->members[i].sd:g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m) && !bg)
 						continue;
 					if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, pc_get_group_level(dstsd)))
 						continue;
@@ -10491,12 +10565,19 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 						called++;
 				}
 			}
-			if (sd)
+			if (sd) {
 #ifdef RENEWAL
+				if (sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_cooldown(skill_id, skill_lv));
+				else
 				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
 #else
+				if (sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_time2(skill_id, skill_lv));
+				else
 				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
 #endif
+		}
 		}
 		break;
 	case GD_CHARGESHOUT_FLAG:
@@ -10931,9 +11012,14 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		{
 			int bless_lv = ((sd) ? pc_checkskill(sd,AL_BLESSING) : skill_get_max(AL_BLESSING)) + (((sd) ? sd->status.job_level : 50) / 10);
 			int agi_lv = ((sd) ? pc_checkskill(sd,AL_INCAGI) : skill_get_max(AL_INCAGI)) + (((sd) ? sd->status.job_level : 50) / 10);
-			if( sd == NULL || sd->status.party_id == 0 || flag&1 )
+			if( sd == NULL || sd->status.party_id == 0 || flag&1 ) {
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,
 					(skill_id == AB_CLEMENTIA)? bless_lv : (skill_id == AB_CANTO)? agi_lv : skill_lv, skill_get_time(skill_id,skill_lv)));
+			}
+			else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
 			else if( sd )
 				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		}
@@ -10942,11 +11028,16 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case AB_PRAEFATIO:
 	case AB_RENOVATIO:
 		if( !sd || sd->status.party_id == 0 || flag&1 ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			if (skill_id == AB_PRAEFATIO)
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1 ), skill_get_time(skill_id, skill_lv)));
 			else
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		break;
 
@@ -10954,6 +11045,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		if( !sd || sd->status.party_id == 0 || flag&1 ) {
 			if( sd && tstatus && !battle_check_undead(tstatus->race, tstatus->def_ele) && !tsc->getSCE(SC_BERSERK) ) {
 				int partycount = (sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;
 
 				i = skill_calc_heal(src, bl, AL_HEAL, pc_checkskill(sd, AL_HEAL), true);
 
@@ -10967,7 +11060,10 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 					i = ~i + 1;
 				status_heal(bl, i, 0, 0);
 			}
-		} else if( sd )
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		break;
 
@@ -11002,6 +11098,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 
 	case AB_LAUDAAGNUS:
 		if( flag&1 || !sd || !sd->status.party_id ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			if( tsc && (tsc->getSCE(SC_FREEZE) || tsc->getSCE(SC_STONE) || tsc->getSCE(SC_BLIND) ||
 				tsc->getSCE(SC_BURNING) || tsc->getSCE(SC_FREEZING) || tsc->getSCE(SC_CRYSTALIZE))) {
 				// Success Chance: (60 + 10 * Skill Level) %
@@ -11015,13 +11113,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			} else //Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
 					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
 		break;
 
 	case AB_LAUDARAMUS:
 		if( flag&1 || !sd || !sd->status.party_id ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			if( tsc && (tsc->getSCE(SC_SLEEP) || tsc->getSCE(SC_STUN) || tsc->getSCE(SC_MANDRAGORA) || tsc->getSCE(SC_SILENCE) || tsc->getSCE(SC_DEEPSLEEP)) ){
 				// Success Chance: (60 + 10 * Skill Level) %
 				if( rnd()%100 > 60+10*skill_lv )  break;
@@ -11033,9 +11135,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			} else // Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
 					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
 		break;
 
 	case AB_CLEARANCE:
@@ -11616,8 +11720,15 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case MI_RUSH_WINDMILL:
 	case MI_ECHOSONG:
 		if( !sd || !sd->status.party_id || (flag & 1) ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
+		}
+		else if (sd && sd->bg_id) {
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 		} else if( sd ) {
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
@@ -12518,23 +12629,32 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case SU_MEOWMEOW:
 		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
 			int duration = skill_get_time(skill_id, skill_lv);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 
 			if (skill_id == SU_BUNCHOFSHRIMP && pc_checkskill(sd, SU_SPIRITOFSEA))
 				duration += skill_get_time2(SU_BUNCHOFSHRIMP, skill_lv);
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, duration));
-		} else if (sd) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
 		break;
 
 	case SU_SHRIMPARTY:
 		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
 			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
 			if (sd && (i = pc_checkskill(sd, SU_FRESHSHRIMP)) > 0) {
 				clif_skill_nodamage(bl, bl, SU_FRESHSHRIMP, i, 1);
 				sc_start(src, bl, SC_FRESHSHRIMP, 100, i, skill_get_time(SU_FRESHSHRIMP, i));
 			}
-		} else if (sd)
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		break;
 
@@ -17612,7 +17732,10 @@ bool skill_check_condition_castbegin(map_session_data* sd, uint16 skill_id, uint
 		case GD_EMERGENCYCALL:
 		case GD_ITEMEMERGENCYCALL:
 			// other checks were already done in skill_isNotOk()
-			if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
+			if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+				if (sd->bg_id && !sd->state.bmaster_flag)
+					return false;
+			} else if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
 				return false;
 			break;
 
@@ -18552,6 +18675,11 @@ void skill_consume_requirement(map_session_data *sd, uint16 skill_id, uint16 ski
 			if( sd->status.zeny < require.zeny )
 				require.zeny = sd->status.zeny;
 			pc_payzeny(sd,require.zeny,LOG_TYPE_CONSUME);
+			//Extended Features BG [Easycore]
+			if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+				add2limit(sd->status.bgstats.zeny_used, require.zeny, UINT_MAX);
+			else if (is_agit_start() && map_flag_gvg2(sd->bl.m))
+				add2limit(sd->status.wstats.zeny_used, require.zeny, UINT_MAX);
 		}
 	}
 
@@ -18594,6 +18722,39 @@ void skill_consume_requirement(map_session_data *sd, uint16 skill_id, uint16 ski
 
 			if( (n = pc_search_inventory(sd,require.itemid[i])) >= 0 )
 				pc_delitem(sd,n,require.amount[i],0,1,LOG_TYPE_CONSUME);
+
+			// Extended Features BG [Easycore]
+			if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+				switch( require.itemid[i] ) {
+				case ITEMID_POISON_BOTTLE:
+					add2limit(sd->status.bgstats.poison_bottles, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_YELLOW_GEMSTONE:
+					add2limit(sd->status.bgstats.yellow_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_RED_GEMSTONE:
+					add2limit(sd->status.bgstats.red_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_BLUE_GEMSTONE:
+					add2limit(sd->status.bgstats.blue_gemstones, require.amount[i], UINT_MAX);
+					break;
+				}
+			} else if (is_agit_start() && map_flag_gvg2(sd->bl.m)) {
+				switch( require.itemid[i] ) {
+				case ITEMID_POISON_BOTTLE:
+					add2limit(sd->status.wstats.poison_bottles, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_YELLOW_GEMSTONE:
+					add2limit(sd->status.wstats.yellow_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_RED_GEMSTONE:
+					add2limit(sd->status.wstats.red_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_BLUE_GEMSTONE:
+					add2limit(sd->status.wstats.blue_gemstones, require.amount[i], UINT_MAX);
+					break;
+				}
+			}
 		}
 	}
 }
@@ -19767,6 +19928,9 @@ int skill_frostjoke_scream(struct block_list *bl, va_list ap)
 		if ( sd && sd->sc.option&(OPTION_INVISIBLE|OPTION_MADOGEAR) )
 			return 0;//Frost Joke / Scream cannot target invisible or MADO Gear characters [Ind]
 	}
+	// Extended Battleground [Easycore]
+	if (map_getmapflag(bl->m, MF_BATTLEGROUND) && map_getcell(bl->m, bl->x, bl->y, CELL_CHKBASILICA))
+		return 0;
 	//It has been reported that Scream/Joke works the same regardless of woe-setting. [Skotlex]
 	if(battle_check_target(src,bl,BCT_ENEMY) > 0)
 		skill_additional_effect(src,bl,skill_id,skill_lv,BF_MISC,ATK_DEF,tick);
diff --git a/src/map/skill.hpp b/src/map/skill.hpp
index c1ac243..04875fc 100644
--- a/src/map/skill.hpp
+++ b/src/map/skill.hpp
@@ -1504,6 +1504,11 @@ enum e_skill {
 	NPC_CURSE_OF_BLUE_CUBE,
 	NPC_KILLING_AURA,	// 783
 
+	//Extended Check Equipment [Easycore]
+	CS_EQUIPMENT = 792,
+	CS_BG,
+	CS_WOE,
+
 	KN_CHARGEATK = 1001,
 	CR_SHRINK,
 	AS_SONICACCEL,
diff --git a/src/map/status.cpp b/src/map/status.cpp
index 9090c29..8318975 100644
--- a/src/map/status.cpp
+++ b/src/map/status.cpp
@@ -1555,6 +1555,10 @@ int status_damage(struct block_list *src,struct block_list *target,int64 dhp, in
 		case BL_ELEM: elemental_heal((TBL_ELEM*)target,hp,sp); break;
 	}
 
+	// Extended Features BG [Easycore]
+	if (src && src->type == BL_PC)
+		pc_record_damage(src,target,hp);
+
 	if( src && target->type == BL_PC && ((TBL_PC*)target)->disguise ) { // Stop walking when attacked in disguise to prevent walk-delay bug
 		unit_stop_walking( target, 1 );
 	}
diff --git a/src/map/trade.cpp b/src/map/trade.cpp
index c766b67..feabf22 100644
--- a/src/map/trade.cpp
+++ b/src/map/trade.cpp
@@ -8,6 +8,7 @@
 
 #include <common/nullpo.hpp>
 #include <common/socket.hpp>
+#include "../common/utils.hpp"
 
 #include "atcommand.hpp"
 #include "battle.hpp"
@@ -392,6 +393,13 @@ void trade_tradeadditem(map_session_data *sd, short index, short amount)
 		return;
 	}
 
+	if( item->card[0]==CARD0_CREATE && (MakeDWord(item->card[2],item->card[3])== (battle_config.bg_reserved_char_id || battle_config.woe_reserved_char_id )&& !battle_config.bg_can_trade) )
+	{	// "Battleground's Items"
+		clif_displaymessage (sd->fd, msg_txt(sd,260));
+		clif_tradeitemok(*sd, index+2, EXITEM_ADD_FAILED_CLOSED);
+		return;
+	}
+
 	if( ((item->bound == BOUND_ACCOUNT || item->bound > BOUND_GUILD) || (item->bound == BOUND_GUILD && sd->status.guild_id != target_sd->status.guild_id)) && !pc_can_give_bounded_items(sd) ) { // Item Bound
 		clif_displaymessage(sd->fd, msg_txt(sd,293));
 		clif_tradeitemok(*sd, index, EXITEM_ADD_FAILED_CLOSED);
